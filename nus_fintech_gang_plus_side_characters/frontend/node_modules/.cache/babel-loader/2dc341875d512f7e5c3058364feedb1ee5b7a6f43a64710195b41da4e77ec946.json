{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForSigningBatch = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;\nconst coretypes_1 = require(\"./coretypes\");\nconst ledger_hashes_1 = require(\"./ledger-hashes\");\nObject.defineProperty(exports, \"decodeLedgerData\", {\n  enumerable: true,\n  get: function () {\n    return ledger_hashes_1.decodeLedgerData;\n  }\n});\nconst enums_1 = require(\"./enums\");\nObject.defineProperty(exports, \"XrplDefinitionsBase\", {\n  enumerable: true,\n  get: function () {\n    return enums_1.XrplDefinitionsBase;\n  }\n});\nObject.defineProperty(exports, \"TRANSACTION_TYPES\", {\n  enumerable: true,\n  get: function () {\n    return enums_1.TRANSACTION_TYPES;\n  }\n});\nObject.defineProperty(exports, \"DEFAULT_DEFINITIONS\", {\n  enumerable: true,\n  get: function () {\n    return enums_1.DEFAULT_DEFINITIONS;\n  }\n});\nconst xrpl_definitions_1 = require(\"./enums/xrpl-definitions\");\nObject.defineProperty(exports, \"XrplDefinitions\", {\n  enumerable: true,\n  get: function () {\n    return xrpl_definitions_1.XrplDefinitions;\n  }\n});\nconst types_1 = require(\"./types\");\nObject.defineProperty(exports, \"coreTypes\", {\n  enumerable: true,\n  get: function () {\n    return types_1.coreTypes;\n  }\n});\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst {\n  signingData,\n  signingClaimData,\n  multiSigningData,\n  signingBatchData,\n  binaryToJSON,\n  serializeObject\n} = coretypes_1.binary;\n/**\n * Decode a transaction\n *\n * @param binary hex-string of the encoded transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns the JSON representation of the transaction\n */\nfunction decode(binary, definitions) {\n  if (typeof binary !== 'string') {\n    throw new Error('binary must be a hex string');\n  }\n  return binaryToJSON(binary, definitions);\n}\nexports.decode = decode;\n/**\n * Encode a transaction\n *\n * @param json The JSON representation of a transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n *\n * @returns A hex-string of the encoded transaction\n */\nfunction encode(json, definitions) {\n  if (typeof json !== 'object') {\n    throw new Error();\n  }\n  return (0, utils_1.bytesToHex)(serializeObject(json, {\n    definitions\n  }));\n}\nexports.encode = encode;\n/**\n * Encode a transaction and prepare for signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForSigning(json, definitions) {\n  if (typeof json !== 'object') {\n    throw new Error();\n  }\n  return (0, utils_1.bytesToHex)(signingData(json, coretypes_1.HashPrefix.transactionSig, {\n    definitions\n  }));\n}\nexports.encodeForSigning = encodeForSigning;\n/**\n * Encode a payment channel claim for signing.\n *\n * @param json JSON object representing the claim.\n * @returns a hex string of the encoded claim.\n */\nfunction encodeForSigningClaim(json) {\n  if (typeof json !== 'object') {\n    throw new Error();\n  }\n  return (0, utils_1.bytesToHex)(signingClaimData(json));\n}\nexports.encodeForSigningClaim = encodeForSigningClaim;\n/**\n * Encode a transaction and prepare for multi-signing.\n *\n * @param json JSON object representing the transaction.\n * @param signer string representing the account to sign the transaction with.\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction.\n */\nfunction encodeForMultisigning(json, signer, definitions) {\n  if (typeof json !== 'object') {\n    throw new Error();\n  }\n  const definitionsOpt = definitions ? {\n    definitions\n  } : undefined;\n  return (0, utils_1.bytesToHex)(multiSigningData(json, signer, definitionsOpt));\n}\nexports.encodeForMultisigning = encodeForMultisigning;\n/**\n * Encode a Batch transaction for signing.\n *\n * @param json JSON object representing the transaction.\n * @returns a hex string of the encoded transaction.\n */\nfunction encodeForSigningBatch(json) {\n  if (typeof json !== 'object') {\n    throw new Error('Need an object to encode a Batch transaction');\n  }\n  return (0, utils_1.bytesToHex)(signingBatchData(json));\n}\nexports.encodeForSigningBatch = encodeForSigningBatch;\n/**\n * Encode a quality value\n *\n * @param value string representation of a number\n * @returns a hex-string representing the quality\n */\nfunction encodeQuality(value) {\n  if (typeof value !== 'string') {\n    throw new Error();\n  }\n  return (0, utils_1.bytesToHex)(coretypes_1.quality.encode(value));\n}\nexports.encodeQuality = encodeQuality;\n/**\n * Decode a quality value\n *\n * @param value hex-string of a quality\n * @returns a string representing the quality\n */\nfunction decodeQuality(value) {\n  if (typeof value !== 'string') {\n    throw new Error();\n  }\n  return coretypes_1.quality.decode(value).toString();\n}\nexports.decodeQuality = decodeQuality;","map":{"version":3,"names":["coretypes_1","require","ledger_hashes_1","Object","defineProperty","exports","enumerable","get","decodeLedgerData","enums_1","XrplDefinitionsBase","TRANSACTION_TYPES","DEFAULT_DEFINITIONS","xrpl_definitions_1","XrplDefinitions","types_1","coreTypes","utils_1","signingData","signingClaimData","multiSigningData","signingBatchData","binaryToJSON","serializeObject","binary","decode","definitions","Error","encode","json","bytesToHex","encodeForSigning","HashPrefix","transactionSig","encodeForSigningClaim","encodeForMultisigning","signer","definitionsOpt","undefined","encodeForSigningBatch","encodeQuality","value","quality","decodeQuality","toString"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/ripple-binary-codec/src/index.ts"],"sourcesContent":["import { quality, binary, HashPrefix } from './coretypes'\nimport { decodeLedgerData } from './ledger-hashes'\nimport { ClaimObject, BatchObject } from './binary'\nimport { JsonObject } from './types/serialized-type'\nimport {\n  XrplDefinitionsBase,\n  TRANSACTION_TYPES,\n  DEFAULT_DEFINITIONS,\n} from './enums'\nimport { XrplDefinitions } from './enums/xrpl-definitions'\nimport { coreTypes } from './types'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\n\nconst {\n  signingData,\n  signingClaimData,\n  multiSigningData,\n  signingBatchData,\n  binaryToJSON,\n  serializeObject,\n} = binary\n\n/**\n * Decode a transaction\n *\n * @param binary hex-string of the encoded transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns the JSON representation of the transaction\n */\nfunction decode(binary: string, definitions?: XrplDefinitionsBase): JsonObject {\n  if (typeof binary !== 'string') {\n    throw new Error('binary must be a hex string')\n  }\n  return binaryToJSON(binary, definitions)\n}\n\n/**\n * Encode a transaction\n *\n * @param json The JSON representation of a transaction\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n *\n * @returns A hex-string of the encoded transaction\n */\nfunction encode(json: object, definitions?: XrplDefinitionsBase): string {\n  if (typeof json !== 'object') {\n    throw new Error()\n  }\n  return bytesToHex(serializeObject(json as JsonObject, { definitions }))\n}\n\n/**\n * Encode a transaction and prepare for signing\n *\n * @param json JSON object representing the transaction\n * @param signer string representing the account to sign the transaction with\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction\n */\nfunction encodeForSigning(\n  json: object,\n  definitions?: XrplDefinitionsBase,\n): string {\n  if (typeof json !== 'object') {\n    throw new Error()\n  }\n  return bytesToHex(\n    signingData(json as JsonObject, HashPrefix.transactionSig, {\n      definitions,\n    }),\n  )\n}\n\n/**\n * Encode a payment channel claim for signing.\n *\n * @param json JSON object representing the claim.\n * @returns a hex string of the encoded claim.\n */\nfunction encodeForSigningClaim(json: object): string {\n  if (typeof json !== 'object') {\n    throw new Error()\n  }\n  return bytesToHex(signingClaimData(json as ClaimObject))\n}\n\n/**\n * Encode a transaction and prepare for multi-signing.\n *\n * @param json JSON object representing the transaction.\n * @param signer string representing the account to sign the transaction with.\n * @param definitions Custom rippled types to use instead of the default. Used for sidechains and amendments.\n * @returns a hex string of the encoded transaction.\n */\nfunction encodeForMultisigning(\n  json: object,\n  signer: string,\n  definitions?: XrplDefinitionsBase,\n): string {\n  if (typeof json !== 'object') {\n    throw new Error()\n  }\n\n  const definitionsOpt = definitions ? { definitions } : undefined\n  return bytesToHex(\n    multiSigningData(json as JsonObject, signer, definitionsOpt),\n  )\n}\n\n/**\n * Encode a Batch transaction for signing.\n *\n * @param json JSON object representing the transaction.\n * @returns a hex string of the encoded transaction.\n */\nfunction encodeForSigningBatch(json: object): string {\n  if (typeof json !== 'object') {\n    throw new Error('Need an object to encode a Batch transaction')\n  }\n  return bytesToHex(signingBatchData(json as BatchObject))\n}\n\n/**\n * Encode a quality value\n *\n * @param value string representation of a number\n * @returns a hex-string representing the quality\n */\nfunction encodeQuality(value: string): string {\n  if (typeof value !== 'string') {\n    throw new Error()\n  }\n  return bytesToHex(quality.encode(value))\n}\n\n/**\n * Decode a quality value\n *\n * @param value hex-string of a quality\n * @returns a string representing the quality\n */\nfunction decodeQuality(value: string): string {\n  if (typeof value !== 'string') {\n    throw new Error()\n  }\n  return quality.decode(value).toString()\n}\n\nexport {\n  decode,\n  encode,\n  encodeForSigning,\n  encodeForSigningClaim,\n  encodeForMultisigning,\n  encodeForSigningBatch,\n  encodeQuality,\n  decodeQuality,\n  decodeLedgerData,\n  TRANSACTION_TYPES,\n  XrplDefinitions,\n  XrplDefinitionsBase,\n  DEFAULT_DEFINITIONS,\n  coreTypes,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}