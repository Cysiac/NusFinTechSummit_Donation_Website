{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.multisign = exports.verifySignature = void 0;\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst ripple_keypairs_1 = require(\"ripple-keypairs\");\nconst errors_1 = require(\"../errors\");\nconst transactions_1 = require(\"../models/transactions\");\nconst utils_1 = require(\"./utils\");\nfunction multisign(transactions) {\n  if (transactions.length === 0) {\n    throw new errors_1.ValidationError('There were 0 transactions to multisign');\n  }\n  const decodedTransactions = transactions.map(txOrBlob => {\n    return (0, utils_1.getDecodedTransaction)(txOrBlob);\n  });\n  decodedTransactions.forEach(tx => {\n    (0, transactions_1.validate)(tx);\n    if (tx.Signers == null || tx.Signers.length === 0) {\n      throw new errors_1.ValidationError(\"For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.\");\n    }\n    if (tx.SigningPubKey !== '') {\n      throw new errors_1.ValidationError('SigningPubKey must be an empty string for all transactions when multisigning.');\n    }\n  });\n  validateTransactionEquivalence(decodedTransactions);\n  return (0, ripple_binary_codec_1.encode)(getTransactionWithAllSigners(decodedTransactions));\n}\nexports.multisign = multisign;\nfunction verifySignature(tx, publicKey) {\n  const decodedTx = (0, utils_1.getDecodedTransaction)(tx);\n  let key = publicKey;\n  if (typeof decodedTx.TxnSignature !== 'string' || !decodedTx.TxnSignature) {\n    throw new Error('Transaction is missing a signature, TxnSignature');\n  }\n  if (!key) {\n    if (typeof decodedTx.SigningPubKey !== 'string' || !decodedTx.SigningPubKey) {\n      throw new Error('Transaction is missing a public key, SigningPubKey');\n    }\n    key = decodedTx.SigningPubKey;\n  }\n  return (0, ripple_keypairs_1.verify)((0, ripple_binary_codec_1.encodeForSigning)(decodedTx), decodedTx.TxnSignature, key);\n}\nexports.verifySignature = verifySignature;\nfunction validateTransactionEquivalence(transactions) {\n  const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), {\n    Signers: null\n  }));\n  if (transactions.slice(1).some(tx => JSON.stringify(Object.assign(Object.assign({}, tx), {\n    Signers: null\n  })) !== exampleTransaction)) {\n    throw new errors_1.ValidationError('txJSON is not the same for all signedTransactions');\n  }\n}\nfunction getTransactionWithAllSigners(transactions) {\n  const sortedSigners = transactions.flatMap(tx => {\n    var _a;\n    return (_a = tx.Signers) !== null && _a !== void 0 ? _a : [];\n  }).sort((signer1, signer2) => (0, utils_1.compareSigners)(signer1.Signer, signer2.Signer));\n  return Object.assign(Object.assign({}, transactions[0]), {\n    Signers: sortedSigners\n  });\n}","map":{"version":3,"names":["ripple_binary_codec_1","require","ripple_keypairs_1","errors_1","transactions_1","utils_1","multisign","transactions","length","ValidationError","decodedTransactions","map","txOrBlob","getDecodedTransaction","forEach","tx","validate","Signers","SigningPubKey","validateTransactionEquivalence","encode","getTransactionWithAllSigners","exports","verifySignature","publicKey","decodedTx","key","TxnSignature","Error","verify","encodeForSigning","exampleTransaction","JSON","stringify","Object","assign","slice","some","sortedSigners","flatMap","_a","sort","signer1","signer2","compareSigners","Signer"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/Wallet/signer.ts"],"sourcesContent":["import { encode, encodeForSigning } from 'ripple-binary-codec'\nimport { verify } from 'ripple-keypairs'\n\nimport { ValidationError } from '../errors'\nimport { Signer } from '../models/common'\nimport { Transaction, validate } from '../models/transactions'\n\nimport { compareSigners, getDecodedTransaction } from './utils'\n\n/**\n * Takes several transactions with Signer fields (in object or blob form) and creates a\n * single transaction with all Signers that then gets signed and returned.\n *\n * @param transactions - An array of signed Transactions (in object or blob form) to combine into a single signed Transaction.\n * @returns A single signed Transaction which has all Signers from transactions within it.\n * @throws ValidationError if:\n * - There were no transactions given to sign\n * - The SigningPubKey field is not the empty string in any given transaction\n * - Any transaction is missing a Signers field.\n * @category Signing\n */\nfunction multisign(transactions: Array<Transaction | string>): string {\n  if (transactions.length === 0) {\n    throw new ValidationError('There were 0 transactions to multisign')\n  }\n\n  const decodedTransactions: Transaction[] = transactions.map(\n    (txOrBlob: string | Transaction) => {\n      return getDecodedTransaction(txOrBlob)\n    },\n  )\n\n  decodedTransactions.forEach((tx) => {\n    /*\n     * This will throw a more clear error for JS users if any of the supplied transactions has incorrect formatting\n     */\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- validate does not accept Transaction type\n    validate(tx as unknown as Record<string, unknown>)\n    if (tx.Signers == null || tx.Signers.length === 0) {\n      throw new ValidationError(\n        \"For multisigning all transactions must include a Signers field containing an array of signatures. You may have forgotten to pass the 'forMultisign' parameter when signing.\",\n      )\n    }\n\n    if (tx.SigningPubKey !== '') {\n      throw new ValidationError(\n        'SigningPubKey must be an empty string for all transactions when multisigning.',\n      )\n    }\n  })\n\n  validateTransactionEquivalence(decodedTransactions)\n\n  return encode(getTransactionWithAllSigners(decodedTransactions))\n}\n\n/**\n * Verifies that the given transaction has a valid signature based on public-key encryption.\n *\n * @param tx - A transaction to verify the signature of. (Can be in object or encoded string format).\n * @param [publicKey] Specific public key to use to verify. If not specified the `SigningPublicKey` of tx will be used.\n * @returns Returns true if tx has a valid signature, and returns false otherwise.\n * @throws Error when transaction is missing TxnSignature\n * @throws Error when publicKey is not provided and transaction is missing SigningPubKey\n * @category Utilities\n */\nfunction verifySignature(\n  tx: Transaction | string,\n  publicKey?: string,\n): boolean {\n  const decodedTx: Transaction = getDecodedTransaction(tx)\n  let key = publicKey\n\n  // Need a SignedTransaction class where TxnSignature is not optional.\n  if (typeof decodedTx.TxnSignature !== 'string' || !decodedTx.TxnSignature) {\n    throw new Error('Transaction is missing a signature, TxnSignature')\n  }\n\n  if (!key) {\n    // Need a SignedTransaction class where TxnSignature is not optional.\n    if (\n      typeof decodedTx.SigningPubKey !== 'string' ||\n      !decodedTx.SigningPubKey\n    ) {\n      throw new Error('Transaction is missing a public key, SigningPubKey')\n    }\n    key = decodedTx.SigningPubKey\n  }\n\n  return verify(encodeForSigning(decodedTx), decodedTx.TxnSignature, key)\n}\n\n/**\n * The transactions should all be equal except for the 'Signers' field.\n *\n * @param transactions - An array of Transactions which are expected to be equal other than 'Signers'.\n * @throws ValidationError if the transactions are not equal in any field other than 'Signers'.\n */\nfunction validateTransactionEquivalence(transactions: Transaction[]): void {\n  const exampleTransaction = JSON.stringify({\n    ...transactions[0],\n    Signers: null,\n  })\n  if (\n    transactions\n      .slice(1)\n      .some(\n        (tx) => JSON.stringify({ ...tx, Signers: null }) !== exampleTransaction,\n      )\n  ) {\n    throw new ValidationError(\n      'txJSON is not the same for all signedTransactions',\n    )\n  }\n}\n\nfunction getTransactionWithAllSigners(\n  transactions: Transaction[],\n): Transaction {\n  // Signers must be sorted in the combined transaction - See compareSigners' documentation for more details\n  const sortedSigners: Signer[] = transactions\n    .flatMap((tx) => tx.Signers ?? [])\n    .sort((signer1, signer2) => compareSigners(signer1.Signer, signer2.Signer))\n\n  return { ...transactions[0], Signers: sortedSigners }\n}\n\nexport { verifySignature, multisign }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}