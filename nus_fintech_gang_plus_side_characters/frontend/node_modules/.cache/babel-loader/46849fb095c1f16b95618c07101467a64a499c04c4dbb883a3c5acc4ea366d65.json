{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.requestFunding = exports.getStartingBalance = exports.generateWalletToFund = void 0;\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst errors_1 = require(\"../errors\");\nconst defaultFaucets_1 = require(\"./defaultFaucets\");\nconst _1 = require(\".\");\nconst INTERVAL_SECONDS = 1;\nconst MAX_ATTEMPTS = 20;\nfunction generateWalletToFund(wallet) {\n  if (wallet && (0, ripple_address_codec_1.isValidClassicAddress)(wallet.classicAddress)) {\n    return wallet;\n  }\n  return _1.Wallet.generate();\n}\nexports.generateWalletToFund = generateWalletToFund;\nfunction getStartingBalance(client, classicAddress) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let startingBalance = 0;\n    try {\n      startingBalance = Number(yield client.getXrpBalance(classicAddress));\n    } catch (_a) {}\n    return startingBalance;\n  });\n}\nexports.getStartingBalance = getStartingBalance;\nfunction requestFunding(options, client, startingBalance, walletToFund, postBody) {\n  var _a, _b, _c;\n  return __awaiter(this, void 0, void 0, function* () {\n    const hostname = (_a = options.faucetHost) !== null && _a !== void 0 ? _a : (0, defaultFaucets_1.getFaucetHost)(client);\n    if (!hostname) {\n      throw new errors_1.XRPLFaucetError('No faucet hostname could be derived');\n    }\n    const pathname = (_b = options.faucetPath) !== null && _b !== void 0 ? _b : (0, defaultFaucets_1.getFaucetPath)(hostname);\n    const response = yield fetch(`https://${hostname}${pathname}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(postBody)\n    });\n    if (response.ok && ((_c = response.headers.get('Content-Type')) === null || _c === void 0 ? void 0 : _c.startsWith('application/json'))) {\n      const body = yield response.json();\n      const classicAddress = body.account.classicAddress;\n      return processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance);\n    }\n    return processError(response);\n  });\n}\nexports.requestFunding = requestFunding;\nfunction processSuccessfulResponse(client, classicAddress, walletToFund, startingBalance) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!classicAddress) {\n      return Promise.reject(new errors_1.XRPLFaucetError(`The faucet account is undefined`));\n    }\n    const updatedBalance = yield getUpdatedBalance(client, classicAddress, startingBalance);\n    if (updatedBalance > startingBalance) {\n      return {\n        wallet: walletToFund,\n        balance: updatedBalance\n      };\n    }\n    throw new errors_1.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`);\n  });\n}\nfunction processError(response) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    const errorData = {\n      contentType: (_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : undefined,\n      statusCode: response.status\n    };\n    const clone = response.clone();\n    try {\n      const body = yield response.json();\n      errorData.body = body;\n    } catch (_b) {\n      errorData.body = yield clone.text();\n    }\n    return Promise.reject(new errors_1.XRPLFaucetError(`Request failed: ${JSON.stringify(errorData)}`));\n  });\n}\nfunction getUpdatedBalance(client, address, originalBalance) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      let attempts = MAX_ATTEMPTS;\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n        if (attempts < 0) {\n          clearInterval(interval);\n          resolve(originalBalance);\n        } else {\n          attempts -= 1;\n        }\n        try {\n          let newBalance;\n          try {\n            newBalance = Number(yield client.getXrpBalance(address));\n          } catch (_a) {}\n          if (newBalance > originalBalance) {\n            clearInterval(interval);\n            resolve(newBalance);\n          }\n        } catch (err) {\n          clearInterval(interval);\n          if (err instanceof Error) {\n            reject(new errors_1.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err.message}`));\n          }\n          reject(err);\n        }\n      }), INTERVAL_SECONDS * 1000);\n    });\n  });\n}","map":{"version":3,"names":["ripple_address_codec_1","require","errors_1","defaultFaucets_1","_1","INTERVAL_SECONDS","MAX_ATTEMPTS","generateWalletToFund","wallet","isValidClassicAddress","classicAddress","Wallet","generate","exports","getStartingBalance","client","startingBalance","Number","getXrpBalance","_a","requestFunding","options","walletToFund","postBody","hostname","faucetHost","getFaucetHost","XRPLFaucetError","pathname","_b","faucetPath","getFaucetPath","response","fetch","method","headers","body","JSON","stringify","ok","_c","get","startsWith","json","account","processSuccessfulResponse","processError","Promise","reject","updatedBalance","getUpdatedBalance","balance","errorData","contentType","undefined","statusCode","status","clone","text","address","originalBalance","resolve","attempts","interval","setInterval","__awaiter","clearInterval","newBalance","err","Error","message"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/Wallet/fundWallet.ts"],"sourcesContent":["import { isValidClassicAddress } from 'ripple-address-codec'\n\nimport type { Client } from '../client'\nimport { XRPLFaucetError } from '../errors'\n\nimport { FaucetWallet, getFaucetHost, getFaucetPath } from './defaultFaucets'\n\nimport { Wallet } from '.'\n\n// Interval to check an account balance\nconst INTERVAL_SECONDS = 1\n// Maximum attempts to retrieve a balance\nconst MAX_ATTEMPTS = 20\n\nexport interface FundingOptions {\n  /**\n   *  A custom amount to fund, if undefined or null, the default amount will be 1000.\n   */\n  amount?: string\n  /**\n   * A custom host for a faucet server. On devnet, testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n   * attempt to determine the correct server automatically. In other environments, or if you would like to customize\n   * the faucet host in devnet or testnet, you should provide the host using this option.\n   */\n  faucetHost?: string\n  /**\n   * A custom path for a faucet server. On devnet,\n   * testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n   * attempt to determine the correct path automatically. In other environments,\n   * or if you would like to customize the faucet path in devnet or testnet,\n   * you should provide the path using this option.\n   * Ex: client.fundWallet(null,{'faucet.altnet.rippletest.net', '/accounts'})\n   * specifies a request to 'faucet.altnet.rippletest.net/accounts' to fund a new wallet.\n   */\n  faucetPath?: string\n  /**\n   * An optional field to indicate the use case context of the faucet transaction\n   * Ex: integration test, code snippets.\n   */\n  usageContext?: string\n}\n\n/**\n * Parameters to pass into a faucet request to fund an XRP account.\n */\nexport interface FaucetRequestBody {\n  /**\n   * The address to fund. If no address is provided the faucet will fund a random account.\n   */\n  destination?: string\n  /**\n   * The total amount of XRP to fund the account with.\n   */\n  xrpAmount?: string\n  /**\n   * An optional field to indicate the use case context of the faucet transaction\n   * Ex: integration test, code snippets.\n   */\n  usageContext?: string\n  /**\n   * Information about the context of where the faucet is being called from.\n   * Ex: xrpl.js or xrpl-py\n   */\n  userAgent: string\n}\n\n/**\n * Generate a new wallet to fund if no existing wallet is provided or its address is invalid.\n *\n * @param wallet - Optional existing wallet.\n * @returns The wallet to fund.\n */\nexport function generateWalletToFund(wallet?: Wallet | null): Wallet {\n  if (wallet && isValidClassicAddress(wallet.classicAddress)) {\n    return wallet\n  }\n  return Wallet.generate()\n}\n\n/**\n * Get the starting balance of the wallet.\n *\n * @param client - The client object.\n * @param classicAddress - The classic address of the wallet.\n * @returns The starting balance.\n */\nexport async function getStartingBalance(\n  client: Client,\n  classicAddress: string,\n): Promise<number> {\n  let startingBalance = 0\n  try {\n    startingBalance = Number(await client.getXrpBalance(classicAddress))\n  } catch {\n    // startingBalance remains '0'\n  }\n  return startingBalance\n}\n\nexport interface FundWalletOptions {\n  faucetHost?: string\n  faucetPath?: string\n  amount?: string\n  usageContext?: string\n}\n\n/**\n *\n * Helper function to request funding from a faucet. Should not be called directly from outside the xrpl.js library.\n *\n * @param options - See below\n * @param options.faucetHost - A custom host for a faucet server. On devnet,\n * testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n * attempt to determine the correct server automatically. In other environments,\n * or if you would like to customize the faucet host in devnet or testnet,\n * you should provide the host using this option.\n * @param options.faucetPath - A custom path for a faucet server. On devnet,\n * testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n * attempt to determine the correct path automatically. In other environments,\n * or if you would like to customize the faucet path in devnet or testnet,\n * you should provide the path using this option.\n * Ex: client.fundWallet(null,{'faucet.altnet.rippletest.net', '/accounts'})\n * specifies a request to 'faucet.altnet.rippletest.net/accounts' to fund a new wallet.\n * @param options.amount - A custom amount to fund, if undefined or null, the default amount will be 1000.\n * @param client - A connection to the XRPL to send requests and transactions.\n * @param startingBalance - The amount of XRP in the given walletToFund on ledger already.\n * @param walletToFund - An existing XRPL Wallet to fund.\n * @param postBody - The content to send the faucet to indicate which address to fund, how much to fund it, and\n * where the request is coming from.\n * @returns A promise that resolves to a funded wallet and the balance within it.\n */\n// eslint-disable-next-line max-params -- Helper function created for organizational purposes\nexport async function requestFunding(\n  options: FundingOptions,\n  client: Client,\n  startingBalance: number,\n  walletToFund: Wallet,\n  postBody: FaucetRequestBody,\n): Promise<{\n  wallet: Wallet\n  balance: number\n}> {\n  const hostname = options.faucetHost ?? getFaucetHost(client)\n  if (!hostname) {\n    throw new XRPLFaucetError('No faucet hostname could be derived')\n  }\n  const pathname = options.faucetPath ?? getFaucetPath(hostname)\n  const response = await fetch(`https://${hostname}${pathname}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(postBody),\n  })\n\n  if (\n    response.ok &&\n    response.headers.get('Content-Type')?.startsWith('application/json')\n  ) {\n    const body: unknown = await response.json()\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- It's a FaucetWallet\n    const classicAddress = (body as FaucetWallet).account.classicAddress\n    return processSuccessfulResponse(\n      client,\n      classicAddress,\n      walletToFund,\n      startingBalance,\n    )\n  }\n  return processError(response)\n}\n\n// eslint-disable-next-line max-params -- Only used as a helper function, lines inc due to added balance.\nasync function processSuccessfulResponse(\n  client: Client,\n  classicAddress: string | undefined,\n  walletToFund: Wallet,\n  startingBalance: number,\n): Promise<{\n  wallet: Wallet\n  balance: number\n}> {\n  if (!classicAddress) {\n    return Promise.reject(\n      new XRPLFaucetError(`The faucet account is undefined`),\n    )\n  }\n  // Check at regular interval if the address is enabled on the XRPL and funded\n  const updatedBalance = await getUpdatedBalance(\n    client,\n    classicAddress,\n    startingBalance,\n  )\n\n  if (updatedBalance > startingBalance) {\n    return {\n      wallet: walletToFund,\n      balance: updatedBalance,\n    }\n  }\n  throw new XRPLFaucetError(\n    `Unable to fund address with faucet after waiting ${\n      INTERVAL_SECONDS * MAX_ATTEMPTS\n    } seconds`,\n  )\n}\n\ninterface ErrorData {\n  body?: unknown\n  contentType?: string\n  statusCode: number\n}\n\nasync function processError(response: Response): Promise<never> {\n  const errorData: ErrorData = {\n    contentType: response.headers.get('Content-Type') ?? undefined,\n    statusCode: response.status,\n  }\n  const clone = response.clone()\n  try {\n    const body: unknown = await response.json()\n    errorData.body = body\n  } catch {\n    errorData.body = await clone.text()\n  }\n  return Promise.reject(\n    new XRPLFaucetError(`Request failed: ${JSON.stringify(errorData)}`),\n  )\n}\n\n/**\n * Check at regular interval if the address is enabled on the XRPL and funded.\n *\n * @param client - Client.\n * @param address - The account address to check.\n * @param originalBalance - The initial balance before the funding.\n * @returns A Promise boolean.\n */\nasync function getUpdatedBalance(\n  client: Client,\n  address: string,\n  originalBalance: number,\n): Promise<number> {\n  return new Promise((resolve, reject) => {\n    let attempts = MAX_ATTEMPTS\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises -- Not actually misused here, different resolve\n    const interval = setInterval(async () => {\n      if (attempts < 0) {\n        clearInterval(interval)\n        resolve(originalBalance)\n      } else {\n        attempts -= 1\n      }\n\n      try {\n        let newBalance\n        try {\n          newBalance = Number(await client.getXrpBalance(address))\n        } catch {\n          /* newBalance remains undefined */\n        }\n\n        if (newBalance > originalBalance) {\n          clearInterval(interval)\n          resolve(newBalance)\n        }\n      } catch (err) {\n        clearInterval(interval)\n        if (err instanceof Error) {\n          reject(\n            new XRPLFaucetError(\n              `Unable to check if the address ${address} balance has increased. Error: ${err.message}`,\n            ),\n          )\n        }\n        reject(err)\n      }\n    }, INTERVAL_SECONDS * 1000)\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}