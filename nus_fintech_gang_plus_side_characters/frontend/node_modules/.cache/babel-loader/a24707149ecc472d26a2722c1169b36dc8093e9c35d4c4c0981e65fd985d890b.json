{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst errors_1 = require(\"../errors\");\nclass RequestManager {\n  constructor() {\n    this.nextId = 0;\n    this.promisesAwaitingResponse = new Map();\n  }\n  addPromise(newId, timer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        this.promisesAwaitingResponse.set(newId, {\n          resolve,\n          reject,\n          timer\n        });\n      });\n    });\n  }\n  resolve(id, response) {\n    const promise = this.promisesAwaitingResponse.get(id);\n    if (promise == null) {\n      throw new errors_1.XrplError(`No existing promise with id ${id}`, {\n        type: 'resolve',\n        response\n      });\n    }\n    clearTimeout(promise.timer);\n    promise.resolve(response);\n    this.deletePromise(id);\n  }\n  reject(id, error) {\n    const promise = this.promisesAwaitingResponse.get(id);\n    if (promise == null) {\n      throw new errors_1.XrplError(`No existing promise with id ${id}`, {\n        type: 'reject',\n        error\n      });\n    }\n    clearTimeout(promise.timer);\n    promise.reject(error);\n    this.deletePromise(id);\n  }\n  rejectAll(error) {\n    this.promisesAwaitingResponse.forEach((_promise, id, _map) => {\n      this.reject(id, error);\n      this.deletePromise(id);\n    });\n  }\n  createRequest(request, timeout) {\n    let newId;\n    if (request.id == null) {\n      newId = this.nextId;\n      this.nextId += 1;\n    } else {\n      newId = request.id;\n    }\n    const newRequest = JSON.stringify(Object.assign(Object.assign({}, request), {\n      id: newId\n    }));\n    const timer = setTimeout(() => {\n      this.reject(newId, new errors_1.TimeoutError(`Timeout for request: ${JSON.stringify(request)} with id ${newId}`, request));\n    }, timeout);\n    if (timer.unref) {\n      ;\n      timer.unref();\n    }\n    if (this.promisesAwaitingResponse.has(newId)) {\n      clearTimeout(timer);\n      throw new errors_1.XrplError(`Response with id '${newId}' is already pending`, request);\n    }\n    const newPromise = new Promise((resolve, reject) => {\n      this.promisesAwaitingResponse.set(newId, {\n        resolve,\n        reject,\n        timer\n      });\n    });\n    return [newId, newRequest, newPromise];\n  }\n  handleResponse(response) {\n    var _a, _b, _c;\n    if (response.id == null || !(typeof response.id === 'string' || typeof response.id === 'number')) {\n      throw new errors_1.ResponseFormatError('valid id not found in response', response);\n    }\n    if (!this.promisesAwaitingResponse.has(response.id)) {\n      return;\n    }\n    if (response.status == null) {\n      const error = new errors_1.ResponseFormatError('Response has no status');\n      this.reject(response.id, error);\n    }\n    if (response.status === 'error') {\n      const errorResponse = response;\n      const error = new errors_1.RippledError((_b = (_a = errorResponse.error_message) !== null && _a !== void 0 ? _a : errorResponse.error_exception) !== null && _b !== void 0 ? _b : errorResponse.error, errorResponse);\n      this.reject(response.id, error);\n      return;\n    }\n    if (response.status !== 'success') {\n      const error = new errors_1.ResponseFormatError(`unrecognized response.status: ${(_c = response.status) !== null && _c !== void 0 ? _c : ''}`, response);\n      this.reject(response.id, error);\n      return;\n    }\n    delete response.status;\n    this.resolve(response.id, response);\n  }\n  deletePromise(id) {\n    this.promisesAwaitingResponse.delete(id);\n  }\n}\nexports.default = RequestManager;","map":{"version":3,"names":["errors_1","require","RequestManager","constructor","nextId","promisesAwaitingResponse","Map","addPromise","newId","timer","Promise","resolve","reject","set","id","response","promise","get","XrplError","type","clearTimeout","deletePromise","error","rejectAll","forEach","_promise","_map","createRequest","request","timeout","newRequest","JSON","stringify","Object","assign","setTimeout","TimeoutError","unref","has","newPromise","handleResponse","ResponseFormatError","status","errorResponse","RippledError","_b","_a","error_message","error_exception","_c","delete","exports","default"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/client/RequestManager.ts"],"sourcesContent":["import {\n  ResponseFormatError,\n  RippledError,\n  TimeoutError,\n  XrplError,\n} from '../errors'\nimport type { APIVersion } from '../models'\nimport { Response, RequestResponseMap } from '../models/methods'\nimport { BaseRequest, ErrorResponse } from '../models/methods/baseMethod'\n\ninterface PromiseEntry<T> {\n  resolve: (value: T | PromiseLike<T>) => void\n  reject: (value: Error) => void\n  timer: ReturnType<typeof setTimeout>\n}\n\n/**\n * Manage all the requests made to the websocket, and their async responses\n * that come in from the WebSocket. Responses come in over the WS connection\n * after-the-fact, so this manager will tie that response to resolve the\n * original request.\n */\nexport default class RequestManager {\n  private nextId = 0\n  private readonly promisesAwaitingResponse = new Map<\n    string | number,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Necessary and typed wrapper in addPromise method\n    PromiseEntry<any>\n  >()\n\n  /**\n   * Adds a promise to the collection of promises awaiting response. Handles typing with generics.\n   *\n   * @template T The generic type parameter representing the resolved value type.\n   * @param newId - The identifier for the new promise.\n   * @param timer - The timer associated with the promise.\n   * @returns A promise that resolves to the specified generic type.\n   */\n  public async addPromise<\n    R extends BaseRequest,\n    T = RequestResponseMap<R, APIVersion>,\n  >(newId: string | number, timer: ReturnType<typeof setTimeout>): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      this.promisesAwaitingResponse.set(newId, {\n        resolve,\n        reject,\n        timer,\n      })\n    })\n  }\n\n  /**\n   * Successfully resolves a request.\n   *\n   * @param id - ID of the request.\n   * @param response - Response to return.\n   * @throws Error if no existing promise with the given ID.\n   */\n  public resolve(\n    id: string | number,\n    response: Partial<Response<APIVersion>>,\n  ): void {\n    const promise = this.promisesAwaitingResponse.get(id)\n    if (promise == null) {\n      throw new XrplError(`No existing promise with id ${id}`, {\n        type: 'resolve',\n        response,\n      })\n    }\n    clearTimeout(promise.timer)\n    promise.resolve(response)\n    this.deletePromise(id)\n  }\n\n  /**\n   * Rejects a request.\n   *\n   * @param id - ID of the request.\n   * @param error - Error to throw with the reject.\n   * @throws Error if no existing promise with the given ID.\n   */\n  public reject(id: string | number, error: Error): void {\n    const promise = this.promisesAwaitingResponse.get(id)\n    if (promise == null) {\n      throw new XrplError(`No existing promise with id ${id}`, {\n        type: 'reject',\n        error,\n      })\n    }\n    clearTimeout(promise.timer)\n    // TODO: figure out how to have a better stack trace for an error\n    promise.reject(error)\n    this.deletePromise(id)\n  }\n\n  /**\n   * Reject all pending requests.\n   *\n   * @param error - Error to throw with the reject.\n   */\n  public rejectAll(error: Error): void {\n    this.promisesAwaitingResponse.forEach((_promise, id, _map) => {\n      this.reject(id, error)\n      this.deletePromise(id)\n    })\n  }\n\n  /**\n   * Creates a new WebSocket request. This sets up a timeout timer to catch\n   * hung responses, and a promise that will resolve with the response once\n   * the response is seen & handled.\n   *\n   * @param request - Request to create.\n   * @param timeout - Timeout length to catch hung responses.\n   * @returns Request ID, new request form, and the promise for resolving the request.\n   * @throws XrplError if request with the same ID is already pending.\n   */\n  public createRequest<\n    R extends BaseRequest,\n    T = RequestResponseMap<R, APIVersion>,\n  >(request: R, timeout: number): [string | number, string, Promise<T>] {\n    let newId: string | number\n    if (request.id == null) {\n      newId = this.nextId\n      this.nextId += 1\n    } else {\n      newId = request.id\n    }\n    const newRequest = JSON.stringify({ ...request, id: newId })\n    // Typing required for Jest running in browser\n    const timer: ReturnType<typeof setTimeout> = setTimeout(() => {\n      this.reject(\n        newId,\n        new TimeoutError(\n          `Timeout for request: ${JSON.stringify(request)} with id ${newId}`,\n          request,\n        ),\n      )\n    }, timeout)\n    /*\n     * Node.js won't exit if a timer is still running, so we tell Node to ignore.\n     * (Node will still wait for the request to complete).\n     */\n    // The following type assertions are required to get this code to pass in browser environments\n    // where setTimeout has a different type\n    // eslint-disable-next-line max-len -- Necessary to disable both rules.\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access -- Reason above.\n    if ((timer as unknown as any).unref) {\n      // eslint-disable-next-line max-len -- Necessary to disable both rules.\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call -- Reason above.\n      ;(timer as unknown as any).unref()\n    }\n    if (this.promisesAwaitingResponse.has(newId)) {\n      clearTimeout(timer)\n      throw new XrplError(\n        `Response with id '${newId}' is already pending`,\n        request,\n      )\n    }\n    const newPromise = new Promise<T>((resolve, reject) => {\n      this.promisesAwaitingResponse.set(newId, {\n        resolve,\n        reject,\n        timer,\n      })\n    })\n\n    return [newId, newRequest, newPromise]\n  }\n\n  /**\n   * Handle a \"response\". Responses match to the earlier request handlers,\n   * and resolve/reject based on the data received.\n   *\n   * @param response - The response to handle.\n   * @throws ResponseFormatError if the response format is invalid, RippledError if rippled returns an error.\n   */\n  // eslint-disable-next-line complexity -- handling a response is complex\n  public handleResponse(\n    response: Partial<Response<APIVersion> | ErrorResponse>,\n  ): void {\n    if (\n      response.id == null ||\n      !(typeof response.id === 'string' || typeof response.id === 'number')\n    ) {\n      throw new ResponseFormatError('valid id not found in response', response)\n    }\n    if (!this.promisesAwaitingResponse.has(response.id)) {\n      return\n    }\n    if (response.status == null) {\n      const error = new ResponseFormatError('Response has no status')\n      this.reject(response.id, error)\n    }\n    if (response.status === 'error') {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- We know this must be true\n      const errorResponse = response as Partial<ErrorResponse>\n      const error = new RippledError(\n        errorResponse.error_message ??\n          errorResponse.error_exception ??\n          errorResponse.error,\n        errorResponse,\n      )\n      this.reject(response.id, error)\n      return\n    }\n    if (response.status !== 'success') {\n      const error = new ResponseFormatError(\n        `unrecognized response.status: ${response.status ?? ''}`,\n        response,\n      )\n      this.reject(response.id, error)\n      return\n    }\n    // status no longer needed because error is thrown if status is not \"success\"\n    delete response.status\n    this.resolve(response.id, response)\n  }\n\n  /**\n   * Delete a promise after it has been returned.\n   *\n   * @param id - ID of the request.\n   */\n  private deletePromise(id: string | number): void {\n    this.promisesAwaitingResponse.delete(id)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}