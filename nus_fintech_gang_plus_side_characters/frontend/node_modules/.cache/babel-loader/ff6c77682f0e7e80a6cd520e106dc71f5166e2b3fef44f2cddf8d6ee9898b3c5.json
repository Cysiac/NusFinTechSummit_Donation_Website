{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UInt64 = void 0;\nconst uint_1 = require(\"./uint\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst utils_2 = require(\"../utils\");\nconst enums_1 = require(\"../enums\");\nconst HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;\nconst BASE10_REGEX = /^[0-9]{1,20}$/;\nconst mask = BigInt(0x00000000ffffffff);\nconst BASE10_AMOUNT_FIELDS = new Set(['MaximumAmount', 'OutstandingAmount', 'MPTAmount', 'LockedAmount']);\nfunction isBase10(fieldName) {\n  return BASE10_AMOUNT_FIELDS.has(fieldName);\n}\n/**\n * Derived UInt class for serializing/deserializing 64 bit UInt\n */\nclass UInt64 extends uint_1.UInt {\n  constructor(bytes) {\n    super(bytes !== null && bytes !== void 0 ? bytes : UInt64.defaultUInt64.bytes);\n  }\n  static fromParser(parser) {\n    return new UInt64(parser.read(UInt64.width));\n  }\n  /**\n   * Construct a UInt64 object\n   *\n   * @param val A UInt64, hex-string, bigInt, or number\n   * @returns A UInt64 object\n   */\n  // eslint-disable-next-line complexity\n  static from(val, fieldName = '') {\n    if (val instanceof UInt64) {\n      return val;\n    }\n    let buf = new Uint8Array(UInt64.width);\n    if (typeof val === 'number') {\n      if (val < 0) {\n        throw new Error('value must be an unsigned integer');\n      }\n      const number = BigInt(val);\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)];\n      (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);\n      (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);\n      return new UInt64((0, utils_1.concat)(intBuf));\n    }\n    if (typeof val === 'string') {\n      if (isBase10(fieldName)) {\n        if (!BASE10_REGEX.test(val)) {\n          throw new Error(`${fieldName} ${val} is not a valid base 10 string`);\n        }\n        val = BigInt(val).toString(16);\n      }\n      if (typeof val === 'string' && !HEX_REGEX.test(val)) {\n        throw new Error(`${val} is not a valid hex-string`);\n      }\n      const strBuf = val.padStart(16, '0');\n      buf = (0, utils_1.hexToBytes)(strBuf);\n      return new UInt64(buf);\n    }\n    if (typeof val === 'bigint') {\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)];\n      (0, utils_2.writeUInt32BE)(intBuf[0], Number(Number(val >> BigInt(32))), 0);\n      (0, utils_2.writeUInt32BE)(intBuf[1], Number(val & BigInt(mask)), 0);\n      return new UInt64((0, utils_1.concat)(intBuf));\n    }\n    throw new Error('Cannot construct UInt64 from given value');\n  }\n  /**\n   * The JSON representation of a UInt64 object\n   *\n   * @returns a hex-string\n   */\n  toJSON(_definitions = enums_1.DEFAULT_DEFINITIONS, fieldName = '') {\n    const hexString = (0, utils_1.bytesToHex)(this.bytes);\n    if (isBase10(fieldName)) {\n      return BigInt('0x' + hexString).toString(10);\n    }\n    return hexString;\n  }\n  /**\n   * Get the value of the UInt64\n   *\n   * @returns the number represented buy this.bytes\n   */\n  valueOf() {\n    const msb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(0, 4), 0));\n    const lsb = BigInt((0, utils_2.readUInt32BE)(this.bytes.slice(4), 0));\n    return msb << BigInt(32) | lsb;\n  }\n  /**\n   * Get the bytes representation of the UInt64 object\n   *\n   * @returns 8 bytes representing the UInt64\n   */\n  toBytes() {\n    return this.bytes;\n  }\n}\nexports.UInt64 = UInt64;\nUInt64.width = 64 / 8; // 8\nUInt64.defaultUInt64 = new UInt64(new Uint8Array(UInt64.width));","map":{"version":3,"names":["uint_1","require","utils_1","utils_2","enums_1","HEX_REGEX","BASE10_REGEX","mask","BigInt","BASE10_AMOUNT_FIELDS","Set","isBase10","fieldName","has","UInt64","UInt","constructor","bytes","defaultUInt64","fromParser","parser","read","width","from","val","buf","Uint8Array","Error","number","intBuf","writeUInt32BE","Number","concat","test","toString","strBuf","padStart","hexToBytes","toJSON","_definitions","DEFAULT_DEFINITIONS","hexString","bytesToHex","valueOf","msb","readUInt32BE","slice","lsb","toBytes","exports"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/ripple-binary-codec/src/types/uint-64.ts"],"sourcesContent":["import { UInt } from './uint'\nimport { BinaryParser } from '../serdes/binary-parser'\nimport { bytesToHex, concat, hexToBytes } from '@xrplf/isomorphic/utils'\nimport { readUInt32BE, writeUInt32BE } from '../utils'\nimport { DEFAULT_DEFINITIONS, XrplDefinitionsBase } from '../enums'\n\nconst HEX_REGEX = /^[a-fA-F0-9]{1,16}$/\nconst BASE10_REGEX = /^[0-9]{1,20}$/\nconst mask = BigInt(0x00000000ffffffff)\n\nconst BASE10_AMOUNT_FIELDS = new Set([\n  'MaximumAmount',\n  'OutstandingAmount',\n  'MPTAmount',\n  'LockedAmount',\n])\n\nfunction isBase10(fieldName: string): boolean {\n  return BASE10_AMOUNT_FIELDS.has(fieldName)\n}\n\n/**\n * Derived UInt class for serializing/deserializing 64 bit UInt\n */\nclass UInt64 extends UInt {\n  protected static readonly width: number = 64 / 8 // 8\n  static readonly defaultUInt64: UInt64 = new UInt64(\n    new Uint8Array(UInt64.width),\n  )\n\n  constructor(bytes: Uint8Array) {\n    super(bytes ?? UInt64.defaultUInt64.bytes)\n  }\n\n  static fromParser(parser: BinaryParser): UInt {\n    return new UInt64(parser.read(UInt64.width))\n  }\n\n  /**\n   * Construct a UInt64 object\n   *\n   * @param val A UInt64, hex-string, bigInt, or number\n   * @returns A UInt64 object\n   */\n  // eslint-disable-next-line complexity\n  static from<T extends UInt64 | string | bigint | number>(\n    val: T,\n    fieldName = '',\n  ): UInt64 {\n    if (val instanceof UInt64) {\n      return val\n    }\n\n    let buf = new Uint8Array(UInt64.width)\n\n    if (typeof val === 'number') {\n      if (val < 0) {\n        throw new Error('value must be an unsigned integer')\n      }\n\n      const number = BigInt(val)\n\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)]\n      writeUInt32BE(intBuf[0], Number(number >> BigInt(32)), 0)\n      writeUInt32BE(intBuf[1], Number(number & BigInt(mask)), 0)\n\n      return new UInt64(concat(intBuf))\n    }\n\n    if (typeof val === 'string') {\n      if (isBase10(fieldName)) {\n        if (!BASE10_REGEX.test(val)) {\n          throw new Error(`${fieldName} ${val} is not a valid base 10 string`)\n        }\n        val = BigInt(val).toString(16) as T\n      }\n\n      if (typeof val === 'string' && !HEX_REGEX.test(val)) {\n        throw new Error(`${val} is not a valid hex-string`)\n      }\n\n      const strBuf = (val as string).padStart(16, '0')\n      buf = hexToBytes(strBuf)\n      return new UInt64(buf)\n    }\n\n    if (typeof val === 'bigint') {\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)]\n      writeUInt32BE(intBuf[0], Number(Number(val >> BigInt(32))), 0)\n      writeUInt32BE(intBuf[1], Number(val & BigInt(mask)), 0)\n\n      return new UInt64(concat(intBuf))\n    }\n\n    throw new Error('Cannot construct UInt64 from given value')\n  }\n\n  /**\n   * The JSON representation of a UInt64 object\n   *\n   * @returns a hex-string\n   */\n  toJSON(\n    _definitions: XrplDefinitionsBase = DEFAULT_DEFINITIONS,\n    fieldName = '',\n  ): string {\n    const hexString = bytesToHex(this.bytes)\n    if (isBase10(fieldName)) {\n      return BigInt('0x' + hexString).toString(10)\n    }\n\n    return hexString\n  }\n\n  /**\n   * Get the value of the UInt64\n   *\n   * @returns the number represented buy this.bytes\n   */\n  valueOf(): bigint {\n    const msb = BigInt(readUInt32BE(this.bytes.slice(0, 4), 0))\n    const lsb = BigInt(readUInt32BE(this.bytes.slice(4), 0))\n    return (msb << BigInt(32)) | lsb\n  }\n\n  /**\n   * Get the bytes representation of the UInt64 object\n   *\n   * @returns 8 bytes representing the UInt64\n   */\n  toBytes(): Uint8Array {\n    return this.bytes\n  }\n}\n\nexport { UInt64 }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}