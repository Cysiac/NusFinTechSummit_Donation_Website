{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sortAndLimitOffers = exports.separateBuySellOrders = exports.combineOrders = exports.extractOffers = exports.reverseRequest = exports.requestAllOffers = exports.createBookOffersRequest = exports.validateOrderbookOptions = void 0;\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst errors_1 = require(\"../errors\");\nconst Offer_1 = require(\"../models/ledger/Offer\");\nconst DEFAULT_LIMIT = 20;\nfunction sortOffers(offers) {\n  return offers.sort((offerA, offerB) => {\n    var _a, _b;\n    const qualityA = (_a = offerA.quality) !== null && _a !== void 0 ? _a : 0;\n    const qualityB = (_b = offerB.quality) !== null && _b !== void 0 ? _b : 0;\n    return new bignumber_js_1.default(qualityA).comparedTo(qualityB);\n  });\n}\nconst getOrderbookOptionsSet = new Set(['limit', 'ledger_index', 'ledger_hash', 'taker']);\nfunction validateOrderbookOptions(options) {\n  for (const key of Object.keys(options)) {\n    if (!getOrderbookOptionsSet.has(key)) {\n      throw new errors_1.ValidationError(`Unexpected option: ${key}`, options);\n    }\n  }\n  if (options.limit && typeof options.limit !== 'number') {\n    throw new errors_1.ValidationError('limit must be a number', options.limit);\n  }\n  if (options.ledger_index && !(typeof options.ledger_index === 'number' || typeof options.ledger_index === 'string' && ['validated', 'closed', 'current'].includes(options.ledger_index))) {\n    throw new errors_1.ValidationError('ledger_index must be a number or a string of \"validated\", \"closed\", or \"current\"', options.ledger_index);\n  }\n  if (options.ledger_hash !== undefined && options.ledger_hash !== null && typeof options.ledger_hash !== 'string') {\n    throw new errors_1.ValidationError('ledger_hash must be a string', options.ledger_hash);\n  }\n  if (options.taker !== undefined && typeof options.taker !== 'string') {\n    throw new errors_1.ValidationError('taker must be a string', options.taker);\n  }\n}\nexports.validateOrderbookOptions = validateOrderbookOptions;\nfunction createBookOffersRequest(currency1, currency2, options) {\n  var _a, _b, _c;\n  const request = {\n    command: 'book_offers',\n    taker_pays: currency1,\n    taker_gets: currency2,\n    ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',\n    ledger_hash: options.ledger_hash === null ? undefined : options.ledger_hash,\n    limit: (_b = options.limit) !== null && _b !== void 0 ? _b : DEFAULT_LIMIT,\n    taker: (_c = options.taker) !== null && _c !== void 0 ? _c : undefined\n  };\n  return request;\n}\nexports.createBookOffersRequest = createBookOffersRequest;\nfunction requestAllOffers(client, request) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const results = yield client.requestAll(request);\n    return results.map(result => result.result.offers);\n  });\n}\nexports.requestAllOffers = requestAllOffers;\nfunction reverseRequest(request) {\n  return Object.assign(Object.assign({}, request), {\n    taker_pays: request.taker_gets,\n    taker_gets: request.taker_pays\n  });\n}\nexports.reverseRequest = reverseRequest;\nfunction extractOffers(offerResults) {\n  return offerResults.flatMap(offerResult => offerResult);\n}\nexports.extractOffers = extractOffers;\nfunction combineOrders(directOffers, reverseOffers) {\n  return [...directOffers, ...reverseOffers];\n}\nexports.combineOrders = combineOrders;\nfunction separateBuySellOrders(orders) {\n  const buy = [];\n  const sell = [];\n  orders.forEach(order => {\n    if ((order.Flags & Offer_1.OfferFlags.lsfSell) === 0) {\n      buy.push(order);\n    } else {\n      sell.push(order);\n    }\n  });\n  return {\n    buy,\n    sell\n  };\n}\nexports.separateBuySellOrders = separateBuySellOrders;\nfunction sortAndLimitOffers(offers, limit) {\n  const sortedOffers = sortOffers(offers);\n  return sortedOffers.slice(0, limit);\n}\nexports.sortAndLimitOffers = sortAndLimitOffers;","map":{"version":3,"names":["bignumber_js_1","__importDefault","require","errors_1","Offer_1","DEFAULT_LIMIT","sortOffers","offers","sort","offerA","offerB","qualityA","_a","quality","qualityB","_b","default","comparedTo","getOrderbookOptionsSet","Set","validateOrderbookOptions","options","key","Object","keys","has","ValidationError","limit","ledger_index","includes","ledger_hash","undefined","taker","exports","createBookOffersRequest","currency1","currency2","request","command","taker_pays","taker_gets","_c","requestAllOffers","client","results","requestAll","map","result","reverseRequest","assign","extractOffers","offerResults","flatMap","offerResult","combineOrders","directOffers","reverseOffers","separateBuySellOrders","orders","buy","sell","forEach","order","Flags","OfferFlags","lsfSell","push","sortAndLimitOffers","sortedOffers","slice"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/sugar/getOrderbook.ts"],"sourcesContent":["import BigNumber from 'bignumber.js'\n\nimport type { Client } from '../client'\nimport { ValidationError } from '../errors'\nimport { LedgerIndex } from '../models/common'\nimport { OfferFlags } from '../models/ledger/Offer'\nimport {\n  BookOffer,\n  BookOfferCurrency,\n  BookOffersRequest,\n} from '../models/methods/bookOffers'\n\nconst DEFAULT_LIMIT = 20\n\nfunction sortOffers(offers: BookOffer[]): BookOffer[] {\n  return offers.sort((offerA, offerB) => {\n    const qualityA = offerA.quality ?? 0\n    const qualityB = offerB.quality ?? 0\n\n    return new BigNumber(qualityA).comparedTo(qualityB)\n  })\n}\n\nconst getOrderbookOptionsSet = new Set([\n  'limit',\n  'ledger_index',\n  'ledger_hash',\n  'taker',\n])\n\n/**\n * Represents the options for retrieving the order book.\n */\nexport interface GetOrderBookOptions {\n  /**\n   * The limit on the number of offers to return.\n   */\n  limit?: number\n  /**\n   * The ledger index of the ledger to use.\n   */\n  ledger_index?: LedgerIndex\n  /**\n   * The ledger hash of the ledger to use.\n   */\n  ledger_hash?: string | null\n  /**\n   * The account that takes the offers.\n   */\n  taker?: string | null\n}\n\n/**\n * Validates the options for retrieving the order book.\n *\n * @param options - The options to validate.\n * @throws {ValidationError} If any validation errors occur.\n */\n// eslint-disable-next-line complexity -- Necessary for validation.\nexport function validateOrderbookOptions(options: GetOrderBookOptions): void {\n  for (const key of Object.keys(options)) {\n    if (!getOrderbookOptionsSet.has(key)) {\n      throw new ValidationError(`Unexpected option: ${key}`, options)\n    }\n  }\n\n  if (options.limit && typeof options.limit !== 'number') {\n    throw new ValidationError('limit must be a number', options.limit)\n  }\n\n  if (\n    options.ledger_index &&\n    !(\n      typeof options.ledger_index === 'number' ||\n      (typeof options.ledger_index === 'string' &&\n        ['validated', 'closed', 'current'].includes(options.ledger_index))\n    )\n  ) {\n    throw new ValidationError(\n      'ledger_index must be a number or a string of \"validated\", \"closed\", or \"current\"',\n      options.ledger_index,\n    )\n  }\n\n  if (\n    options.ledger_hash !== undefined &&\n    options.ledger_hash !== null &&\n    typeof options.ledger_hash !== 'string'\n  ) {\n    throw new ValidationError(\n      'ledger_hash must be a string',\n      options.ledger_hash,\n    )\n  }\n\n  if (options.taker !== undefined && typeof options.taker !== 'string') {\n    throw new ValidationError('taker must be a string', options.taker)\n  }\n}\n\n/**\n * Creates a request object for retrieving book offers.\n *\n * @param currency1 - The first currency in the pair.\n * @param currency2 - The second currency in the pair.\n * @param options - Additional options for the request.\n * @param [options.limit] - The maximum number of offers to retrieve.\n * @param [options.ledger_index] - The ledger index to use for retrieval.\n * @param [options.ledger_hash] - The ledger hash to use for retrieval.\n * @param [options.taker] - The taker address for retrieval.\n * @returns The created request object.\n */\nexport function createBookOffersRequest(\n  currency1: BookOfferCurrency,\n  currency2: BookOfferCurrency,\n  options: {\n    limit?: number\n    ledger_index?: LedgerIndex\n    ledger_hash?: string | null\n    taker?: string | null\n  },\n): BookOffersRequest {\n  const request: BookOffersRequest = {\n    command: 'book_offers',\n    taker_pays: currency1,\n    taker_gets: currency2,\n    ledger_index: options.ledger_index ?? 'validated',\n    ledger_hash: options.ledger_hash === null ? undefined : options.ledger_hash,\n    limit: options.limit ?? DEFAULT_LIMIT,\n    taker: options.taker ?? undefined,\n  }\n\n  return request\n}\n\ntype BookOfferResult = BookOffer[]\n\n/**\n * Retrieves all book offer results using the given request.\n *\n * @param client - The Ripple client.\n * @param request - The request object.\n * @returns The array of book offer results.\n */\nexport async function requestAllOffers(\n  client: Client,\n  request: BookOffersRequest,\n): Promise<BookOfferResult[]> {\n  const results = await client.requestAll(request)\n  return results.map((result) => result.result.offers)\n}\n\n/**\n * Creates a reverse request object by swapping the taker pays and taker gets amounts.\n *\n * @param request - The original request object.\n * @returns The reverse request object.\n */\nexport function reverseRequest(request: BookOffersRequest): BookOffersRequest {\n  return {\n    ...request,\n    taker_pays: request.taker_gets,\n    taker_gets: request.taker_pays,\n  }\n}\n\n/**\n * Extracts the offers from the book offer results.\n *\n * @param offerResults - The array of book offer results.\n * @returns The extracted offers.\n */\nexport function extractOffers(offerResults: BookOfferResult[]): BookOffer[] {\n  return offerResults.flatMap((offerResult) => offerResult)\n}\n\n/**\n * Combines the direct and reverse offers into a single array.\n *\n * @param directOffers - The direct offers.\n * @param reverseOffers - The reverse offers.\n * @returns The combined array of offers.\n */\nexport function combineOrders(\n  directOffers: BookOffer[],\n  reverseOffers: BookOffer[],\n): BookOffer[] {\n  return [...directOffers, ...reverseOffers]\n}\n\n/**\n * Separates the buy and sell orders from the given array of orders.\n *\n * @param orders - The array of orders.\n * @returns The separated buy and sell orders.\n */\nexport function separateBuySellOrders(orders: BookOffer[]): {\n  buy: BookOffer[]\n  sell: BookOffer[]\n} {\n  const buy: BookOffer[] = []\n  const sell: BookOffer[] = []\n\n  orders.forEach((order) => {\n    // eslint-disable-next-line no-bitwise -- necessary for flags check\n    if ((order.Flags & OfferFlags.lsfSell) === 0) {\n      buy.push(order)\n    } else {\n      sell.push(order)\n    }\n  })\n\n  return { buy, sell }\n}\n\n/**\n * Sorts and limits the given array of offers.\n *\n * @param offers - The array of offers to sort and limit.\n * @param [limit] - The maximum number of offers to include.\n * @returns The sorted and limited array of offers.\n */\nexport function sortAndLimitOffers(\n  offers: BookOffer[],\n  limit?: number,\n): BookOffer[] {\n  const sortedOffers = sortOffers(offers)\n  return sortedOffers.slice(0, limit)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}