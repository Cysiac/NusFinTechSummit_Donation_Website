{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Blob = void 0;\nconst serialized_type_1 = require(\"./serialized-type\");\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\n/**\n * Variable length encoded type\n */\nclass Blob extends serialized_type_1.SerializedType {\n  constructor(bytes) {\n    super(bytes);\n  }\n  /**\n   * Defines how to read a Blob from a BinaryParser\n   *\n   * @param parser The binary parser to read the Blob from\n   * @param hint The length of the blob, computed by readVariableLengthLength() and passed in\n   * @returns A Blob object\n   */\n  static fromParser(parser, hint) {\n    return new Blob(parser.read(hint));\n  }\n  /**\n   * Create a Blob object from a hex-string\n   *\n   * @param value existing Blob object or a hex-string\n   * @returns A Blob object\n   */\n  static from(value) {\n    if (value instanceof Blob) {\n      return value;\n    }\n    if (typeof value === 'string') {\n      if (!/^[A-F0-9]*$/iu.test(value)) {\n        throw new Error('Cannot construct Blob from a non-hex string');\n      }\n      return new Blob((0, utils_1.hexToBytes)(value));\n    }\n    throw new Error('Cannot construct Blob from value given');\n  }\n}\nexports.Blob = Blob;","map":{"version":3,"names":["serialized_type_1","require","utils_1","Blob","SerializedType","constructor","bytes","fromParser","parser","hint","read","from","value","test","Error","hexToBytes","exports"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/ripple-binary-codec/src/types/blob.ts"],"sourcesContent":["import { SerializedType } from './serialized-type'\nimport { BinaryParser } from '../serdes/binary-parser'\nimport { hexToBytes } from '@xrplf/isomorphic/utils'\n\n/**\n * Variable length encoded type\n */\nclass Blob extends SerializedType {\n  constructor(bytes: Uint8Array) {\n    super(bytes)\n  }\n\n  /**\n   * Defines how to read a Blob from a BinaryParser\n   *\n   * @param parser The binary parser to read the Blob from\n   * @param hint The length of the blob, computed by readVariableLengthLength() and passed in\n   * @returns A Blob object\n   */\n  static fromParser(parser: BinaryParser, hint: number): Blob {\n    return new Blob(parser.read(hint))\n  }\n\n  /**\n   * Create a Blob object from a hex-string\n   *\n   * @param value existing Blob object or a hex-string\n   * @returns A Blob object\n   */\n  static from<T extends Blob | string>(value: T): Blob {\n    if (value instanceof Blob) {\n      return value\n    }\n\n    if (typeof value === 'string') {\n      if (!/^[A-F0-9]*$/iu.test(value)) {\n        throw new Error('Cannot construct Blob from a non-hex string')\n      }\n      return new Blob(hexToBytes(value))\n    }\n\n    throw new Error('Cannot construct Blob from value given')\n  }\n}\n\nexport { Blob }\n"],"mappings":";;;;;;AAAA,MAAAA,iBAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AAEA;;;AAGA,MAAME,IAAK,SAAQH,iBAAA,CAAAI,cAAc;EAC/BC,YAAYC,KAAiB;IAC3B,KAAK,CAACA,KAAK,CAAC;EACd;EAEA;;;;;;;EAOA,OAAOC,UAAUA,CAACC,MAAoB,EAAEC,IAAY;IAClD,OAAO,IAAIN,IAAI,CAACK,MAAM,CAACE,IAAI,CAACD,IAAI,CAAC,CAAC;EACpC;EAEA;;;;;;EAMA,OAAOE,IAAIA,CAA0BC,KAAQ;IAC3C,IAAIA,KAAK,YAAYT,IAAI,EAAE;MACzB,OAAOS,KAAK;;IAGd,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,IAAI,CAAC,eAAe,CAACC,IAAI,CAACD,KAAK,CAAC,EAAE;QAChC,MAAM,IAAIE,KAAK,CAAC,6CAA6C,CAAC;;MAEhE,OAAO,IAAIX,IAAI,CAAC,IAAAD,OAAA,CAAAa,UAAU,EAACH,KAAK,CAAC,CAAC;;IAGpC,MAAM,IAAIE,KAAK,CAAC,wCAAwC,CAAC;EAC3D;;AAGOE,OAAA,CAAAb,IAAA,GAAAA,IAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}