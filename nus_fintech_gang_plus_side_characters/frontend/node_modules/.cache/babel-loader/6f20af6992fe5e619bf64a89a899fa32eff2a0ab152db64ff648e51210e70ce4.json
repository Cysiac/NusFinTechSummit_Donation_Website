{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = /* @__PURE__ */BigInt(2),\n  _3n = /* @__PURE__ */BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */BigInt(4),\n  _5n = /* @__PURE__ */BigInt(5),\n  _7n = /* @__PURE__ */BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */BigInt(8),\n  _9n = /* @__PURE__ */BigInt(9),\n  _16n = /* @__PURE__ */BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n  return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\nfunction sqrt5mod8(Fp, n) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n  const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n  const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n  const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n  return (Fp, n) => {\n    let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n    let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n    const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n    const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n    const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n    const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n    tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n    const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < _3n) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow(Fp, n) {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n      // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n  // P ≡ 3 (mod 4) => √n = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P ≡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n  if (P % _16n === _9n) return sqrt9mod16(P);\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN'];\nfunction validateField(field) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'number',\n    BITS: 'number'\n  };\n  const opts = FIELD_FIELDS.reduce((map, val) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  (0, utils_ts_1._validateObject)(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(Fp, num, power) {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nfunction FpInvertBatch(Fp, nums, passZero = false) {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nfunction FpLegendre(Fp, n) {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) (0, utils_ts_1.anumber)(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return {\n    nBitLength: _nBitLength,\n    nByteLength\n  };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLenOrOpts,\n// TODO: use opts only in v2?\nisLE = false, opts = {}) {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  let _nbitLength = undefined;\n  let _sqrt = undefined;\n  let modFromBytes = false;\n  let allowedLengths = undefined;\n  if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n    if (opts.sqrt || isLE) throw new Error('cannot specify opts in two arguments');\n    const _opts = bitLenOrOpts;\n    if (_opts.BITS) _nbitLength = _opts.BITS;\n    if (_opts.sqrt) _sqrt = _opts.sqrt;\n    if (typeof _opts.isLE === 'boolean') isLE = _opts.isLE;\n    if (typeof _opts.modFromBytes === 'boolean') modFromBytes = _opts.modFromBytes;\n    allowedLengths = _opts.allowedLengths;\n  } else {\n    if (typeof bitLenOrOpts === 'number') _nbitLength = bitLenOrOpts;\n    if (opts.sqrt) _sqrt = opts.sqrt;\n  }\n  const {\n    nBitLength: BITS,\n    nByteLength: BYTES\n  } = nLength(ORDER, _nbitLength);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP; // cached sqrtP\n  const f = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: (0, utils_ts_1.bitMask)(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    allowedLengths: allowedLengths,\n    create: num => mod(num, ORDER),\n    isValid: num => {\n      if (typeof num !== 'bigint') throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: num => num === _0n,\n    // is valid and invertible\n    isValidNot0: num => !f.is0(num) && f.isValid(num),\n    isOdd: num => (num & _1n) === _1n,\n    neg: num => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n    sqr: num => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n    // Same as above, but doesn't normalize\n    sqrN: num => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n    inv: num => invert(num, ORDER),\n    sqrt: _sqrt || (n => {\n      if (!sqrtP) sqrtP = FpSqrt(ORDER);\n      return sqrtP(f, n);\n    }),\n    toBytes: num => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),\n    fromBytes: (bytes, skipValidation = true) => {\n      if (allowedLengths) {\n        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n          throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n        }\n        const padded = new Uint8Array(BYTES);\n        // isLE add 0 to right, !isLE to the left.\n        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n        bytes = padded;\n      }\n      if (bytes.length !== BYTES) throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);\n      if (modFromBytes) scalar = mod(scalar, ORDER);\n      if (!skipValidation) if (!f.isValid(scalar)) throw new Error('invalid field element: outside of range 0..ORDER');\n      // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n      // protocol may allow non-reduced scalar that reduced later or changed some other way.\n      return scalar;\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: lst => FpInvertBatch(f, lst),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (a, b, c) => c ? b : a\n  });\n  return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nfunction FpSqrtOdd(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n  hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n  const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024) throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);\n}","map":{"version":3,"names":["exports","mod","pow","pow2","invert","tonelliShanks","FpSqrt","validateField","FpPow","FpInvertBatch","FpDiv","FpLegendre","FpIsSquare","nLength","Field","FpSqrtOdd","FpSqrtEven","hashToPrivateScalar","getFieldBytesLength","getMinHashLength","mapHashToField","utils_ts_1","require","_0n","BigInt","_1n","_2n","_3n","_4n","_5n","_7n","_8n","_9n","_16n","a","b","result","num","power","modulo","x","res","number","Error","y","u","v","q","r","m","n","gcd","assertIsSquare","Fp","root","eql","sqr","sqrt3mod4","p1div4","ORDER","sqrt5mod8","p5div8","n2","mul","nv","i","sub","ONE","sqrt9mod16","P","Fp_","tn","c1","neg","c2","c3","c4","tv1","tv2","tv3","tv4","e1","e2","cmov","e3","Q","S","Z","_Fp","cc","Q1div2","tonelliSlow","is0","M","c","t","R","ZERO","t_tmp","exponent","isNegativeLE","FIELD_FIELDS","field","initial","MASK","BYTES","BITS","opts","reduce","map","val","_validateObject","p","d","nums","passZero","inverted","Array","length","fill","undefined","multipliedAcc","acc","invertedAcc","inv","reduceRight","lhs","rhs","p1mod2","powered","yes","zero","no","l","nBitLength","anumber","_nBitLength","toString","nByteLength","Math","ceil","bitLenOrOpts","isLE","_nbitLength","_sqrt","modFromBytes","allowedLengths","sqrt","_opts","sqrtP","f","Object","freeze","bitMask","create","isValid","isValidNot0","isOdd","add","div","sqrN","addN","subN","mulN","toBytes","numberToBytesLE","numberToBytesBE","fromBytes","bytes","skipValidation","includes","padded","Uint8Array","set","scalar","bytesToNumberLE","bytesToNumberBE","invertBatch","lst","elm","hash","groupOrder","ensureBytes","hashLen","minLen","fieldOrder","bitLength","key","len","fieldLen","reduced"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/@noble/curves/src/abstract/modular.ts"],"sourcesContent":["/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  anumber,\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n} from '../utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction assertIsSquare<T>(Fp: IField<T>, root: T, n: T): void {\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));//  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n  const c2 = tn(Fp_, c1);              //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n  const c3 = tn(Fp_, Fp_.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n  const c4 = (P + _7n) / _16n;         //  4. c4 = (q + 7) / 16        # Integer arithmetic\n  return <T>(Fp: IField<T>, n: T) => {\n    let tv1 = Fp.pow(n, c4);           //  1. tv1 = x^c4\n    let tv2 = Fp.mul(tv1, c1);         //  2. tv2 = c1 * tv1\n    const tv3 = Fp.mul(tv1, c2);       //  3. tv3 = c2 * tv1\n    const tv4 = Fp.mul(tv1, c3);       //  4. tv4 = c3 * tv1\n    const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n    const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n    tv1 = Fp.cmov(tv1, tv2, e1);       //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    tv2 = Fp.cmov(tv4, tv3, e2);       //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n    const root = Fp.cmov(tv1, tv2, e3);// 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < _3n) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P ≡ 3 (mod 4) => √n = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P ≡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n  if (P % _16n === _9n) return sqrt9mod16(P);\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  isValidNot0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  allowedLengths?: number[];\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array, skipValidation?: boolean): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'number',\n    BITS: 'number',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  _validateObject(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\nexport type NLength = { nByteLength: number; nBitLength: number };\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number): NLength {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\ntype SqrtFn = (n: bigint) => bigint;\ntype FieldOpts = Partial<{\n  sqrt: SqrtFn;\n  isLE: boolean;\n  BITS: number;\n  modFromBytes: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  allowedLengths?: readonly number[]; // for P521 (adds padding for smaller sizes)\n}>;\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLenOrOpts?: number | FieldOpts, // TODO: use opts only in v2?\n  isLE = false,\n  opts: { sqrt?: SqrtFn } = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  let _nbitLength: number | undefined = undefined;\n  let _sqrt: SqrtFn | undefined = undefined;\n  let modFromBytes: boolean = false;\n  let allowedLengths: undefined | readonly number[] = undefined;\n  if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n    if (opts.sqrt || isLE) throw new Error('cannot specify opts in two arguments');\n    const _opts = bitLenOrOpts;\n    if (_opts.BITS) _nbitLength = _opts.BITS;\n    if (_opts.sqrt) _sqrt = _opts.sqrt;\n    if (typeof _opts.isLE === 'boolean') isLE = _opts.isLE;\n    if (typeof _opts.modFromBytes === 'boolean') modFromBytes = _opts.modFromBytes;\n    allowedLengths = _opts.allowedLengths;\n  } else {\n    if (typeof bitLenOrOpts === 'number') _nbitLength = bitLenOrOpts;\n    if (opts.sqrt) _sqrt = opts.sqrt;\n  }\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    allowedLengths: allowedLengths,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    // is valid and invertible\n    isValidNot0: (num: bigint) => !f.is0(num) && f.isValid(num),\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      _sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes, skipValidation = true) => {\n      if (allowedLengths) {\n        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n          throw new Error(\n            'Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length\n          );\n        }\n        const padded = new Uint8Array(BYTES);\n        // isLE add 0 to right, !isLE to the left.\n        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n        bytes = padded;\n      }\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n      if (modFromBytes) scalar = mod(scalar, ORDER);\n      if (!skipValidation)\n        if (!f.isValid(scalar)) throw new Error('invalid field element: outside of range 0..ORDER');\n      // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n      // protocol may allow non-reduced scalar that reduced later or changed some other way.\n      return scalar;\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (a, b, c) => (c ? b : a),\n  } as FpField);\n  return Object.freeze(f);\n}\n\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}