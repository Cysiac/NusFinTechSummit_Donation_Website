{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._DST_scalar = void 0;\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst utils_ts_1 = require(\"../utils.js\");\nconst modular_ts_1 = require(\"./modular.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_ts_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << 8 * length) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({\n    length\n  }).fill(0);\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\nfunction anum(item) {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\nfunction normDST(DST) {\n  if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== 'string') throw new Error('DST must be Uint8Array or string');\n  return typeof DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n  (0, utils_ts_1.abytes)(msg);\n  anum(lenInBytes);\n  DST = normDST(DST);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n  const {\n    outputLen: b_in_bytes,\n    blockLen: r_in_bytes\n  } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array(ell);\n  const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H((0, utils_ts_1.concatBytes)(...args));\n  }\n  const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n  (0, utils_ts_1.abytes)(msg);\n  anum(lenInBytes);\n  DST = normDST(DST);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil(2 * k / 8);\n    DST = H.create({\n      dkLen\n    }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');\n  return H.create({\n    dkLen: lenInBytes\n  }).update(msg).update(i2osp(lenInBytes, 2))\n  // 2. DST_prime = DST || I2OSP(len(DST), 1)\n  .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n  (0, utils_ts_1._validateObject)(options, {\n    p: 'bigint',\n    m: 'number',\n    k: 'number',\n    hash: 'function'\n  });\n  const {\n    p,\n    k,\n    m,\n    hash,\n    expand,\n    DST\n  } = options;\n  if (!(0, utils_ts_1.isHash)(options.hash)) throw new Error('expected valid hash');\n  (0, utils_ts_1.abytes)(msg);\n  anum(count);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\nfunction isogenyMap(field, map) {\n  // Make same order as in spec\n  const coeff = map.map(i => Array.from(i).reverse());\n  return (x, y) => {\n    const [xn, xd, yn, yd] = coeff.map(val => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n    // 6.6.3\n    // Exceptional cases of iso_map are inputs that cause the denominator of\n    // either rational function to evaluate to zero; such cases MUST return\n    // the identity point on E.\n    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);\n    x = field.mul(xn, xd_inv); // xNum / xDen\n    y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n    return {\n      x,\n      y\n    };\n  };\n}\nexports._DST_scalar = (0, utils_ts_1.utf8ToBytes)('HashToScalar-');\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */\nfunction createHasher(Point, mapToCurve, defaults) {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  function map(num) {\n    return Point.fromAffine(mapToCurve(num));\n  }\n  function clear(initial) {\n    const P = initial.clearCofactor();\n    if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n    P.assertValidity();\n    return P;\n  }\n  return {\n    defaults,\n    hashToCurve(msg, options) {\n      const opts = Object.assign({}, defaults, options);\n      const u = hash_to_field(msg, 2, opts);\n      const u0 = map(u[0]);\n      const u1 = map(u[1]);\n      return clear(u0.add(u1));\n    },\n    encodeToCurve(msg, options) {\n      const optsDst = defaults.encodeDST ? {\n        DST: defaults.encodeDST\n      } : {};\n      const opts = Object.assign({}, defaults, optsDst, options);\n      const u = hash_to_field(msg, 1, opts);\n      const u0 = map(u[0]);\n      return clear(u0);\n    },\n    /** See {@link H2CHasher} */\n    mapToCurve(scalars) {\n      if (!Array.isArray(scalars)) throw new Error('expected array of bigints');\n      for (const i of scalars) if (typeof i !== 'bigint') throw new Error('expected array of bigints');\n      return clear(map(scalars));\n    },\n    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n    hashToScalar(msg, options) {\n      // @ts-ignore\n      const N = Point.Fn.ORDER;\n      const opts = Object.assign({}, defaults, {\n        p: N,\n        m: 1,\n        DST: exports._DST_scalar\n      }, options);\n      return hash_to_field(msg, 1, opts)[0][0];\n    }\n  };\n}","map":{"version":3,"names":["exports","expand_message_xmd","expand_message_xof","hash_to_field","isogenyMap","createHasher","utils_ts_1","require","modular_ts_1","os2ip","bytesToNumberBE","i2osp","value","length","anum","Error","res","Array","from","fill","i","Uint8Array","strxor","a","b","arr","item","Number","isSafeInteger","normDST","DST","isBytes","utf8ToBytes","msg","lenInBytes","H","abytes","concatBytes","outputLen","b_in_bytes","blockLen","r_in_bytes","ell","Math","ceil","DST_prime","Z_pad","l_i_b_str","b_0","args","pseudo_random_bytes","slice","k","dkLen","create","update","digest","count","options","_validateObject","p","m","hash","expand","isHash","log2p","toString","L","len_in_bytes","prb","u","e","j","elm_offset","tv","subarray","mod","field","map","coeff","reverse","x","y","xn","xd","yn","yd","val","reduce","acc","add","mul","xd_inv","yd_inv","FpInvertBatch","_DST_scalar","Point","mapToCurve","defaults","num","fromAffine","clear","initial","P","clearCofactor","equals","ZERO","assertValidity","hashToCurve","opts","Object","assign","u0","u1","encodeToCurve","optsDst","encodeDST","scalars","isArray","hashToScalar","N","Fn","ORDER"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/@noble/curves/src/abstract/hash-to-curve.ts"],"sourcesContent":["/**\n * hash-to-curve from RFC 9380.\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * https://www.rfc-editor.org/rfc/rfc9380\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { CHash } from '../utils.ts';\nimport {\n  _validateObject,\n  abytes,\n  bytesToNumberBE,\n  concatBytes,\n  isBytes,\n  isHash,\n  utf8ToBytes,\n} from '../utils.ts';\nimport type { AffinePoint, Group, GroupConstructor } from './curve.ts';\nimport { FpInvertBatch, mod, type IField } from './modular.ts';\n\nexport type UnicodeOrBytes = string | Uint8Array;\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\nexport type H2COpts = {\n  DST: UnicodeOrBytes;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n  p: bigint;\n  m: number;\n  k: number;\n};\nexport type H2CHashOpts = {\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n// todo: remove\nexport type Opts = H2COpts;\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << (8 * length)) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction anum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\nfunction normDST(DST: UnicodeOrBytes): Uint8Array {\n  if (!isBytes(DST) && typeof DST !== 'string') throw new Error('DST must be Uint8Array or string');\n  return typeof DST === 'string' ? utf8ToBytes(DST) : DST;\n}\n\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: UnicodeOrBytes,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  anum(lenInBytes);\n  DST = normDST(DST);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: UnicodeOrBytes,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  anum(lenInBytes);\n  DST = normDST(DST);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: H2COpts): bigint[][] {\n  _validateObject(options, {\n    p: 'bigint',\n    m: 'number',\n    k: 'number',\n    hash: 'function',\n  });\n  const { p, k, m, hash, expand, DST } = options;\n  if (!isHash(options.hash)) throw new Error('expected valid hash');\n  abytes(msg);\n  anum(count);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport type XY<T> = (x: T, y: T) => { x: T; y: T };\nexport type XYRatio<T> = [T[], T[], T[], T[]]; // xn/xd, yn/yd\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: XYRatio<T>): XY<T> {\n  // Make same order as in spec\n  const coeff = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xn, xd, yn, yd] = coeff.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    // 6.6.3\n    // Exceptional cases of iso_map are inputs that cause the denominator of\n    // either rational function to evaluate to zero; such cases MUST return\n    // the identity point on E.\n    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);\n    x = field.mul(xn, xd_inv); // xNum / xDen\n    y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\n/** Point interface, which curves must implement to work correctly with the module. */\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\nexport type H2CMethod<T> = (msg: Uint8Array, options?: htfBasicOpts) => H2CPoint<T>;\n// TODO: remove\nexport type HTFMethod<T> = H2CMethod<T>;\nexport type MapMethod<T> = (scalars: bigint[]) => H2CPoint<T>;\nexport type H2CHasherBase<T> = {\n  hashToCurve: H2CMethod<T>;\n  hashToScalar: (msg: Uint8Array, options: htfBasicOpts) => bigint;\n};\n/**\n * RFC 9380 methods, with cofactor clearing. See https://www.rfc-editor.org/rfc/rfc9380#section-3.\n *\n * * hashToCurve: `map(hash(input))`, encodes RANDOM bytes to curve (WITH hashing)\n * * encodeToCurve: `map(hash(input))`, encodes NON-UNIFORM bytes to curve (WITH hashing)\n * * mapToCurve: `map(scalars)`, encodes NON-UNIFORM scalars to curve (NO hashing)\n */\nexport type H2CHasher<T> = H2CHasherBase<T> & {\n  encodeToCurve: H2CMethod<T>;\n  mapToCurve: MapMethod<T>;\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes };\n};\n// TODO: remove\nexport type Hasher<T> = H2CHasher<T>;\n\nexport const _DST_scalar: Uint8Array = utf8ToBytes('HashToScalar-');\n\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes }\n): H2CHasher<T> {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  function map(num: bigint[]) {\n    return Point.fromAffine(mapToCurve(num));\n  }\n  function clear(initial: H2CPoint<T>) {\n    const P = initial.clearCofactor();\n    if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n    P.assertValidity();\n    return P;\n  }\n\n  return {\n    defaults,\n\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const opts = Object.assign({}, defaults, options);\n      const u = hash_to_field(msg, 2, opts);\n      const u0 = map(u[0]);\n      const u1 = map(u[1]);\n      return clear(u0.add(u1));\n    },\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};\n      const opts = Object.assign({}, defaults, optsDst, options);\n      const u = hash_to_field(msg, 1, opts);\n      const u0 = map(u[0]);\n      return clear(u0);\n    },\n    /** See {@link H2CHasher} */\n    mapToCurve(scalars: bigint[]): H2CPoint<T> {\n      if (!Array.isArray(scalars)) throw new Error('expected array of bigints');\n      for (const i of scalars)\n        if (typeof i !== 'bigint') throw new Error('expected array of bigints');\n      return clear(map(scalars));\n    },\n\n    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n    hashToScalar(msg: Uint8Array, options?: htfBasicOpts): bigint {\n      // @ts-ignore\n      const N = Point.Fn.ORDER;\n      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options);\n      return hash_to_field(msg, 1, opts)[0][0];\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}