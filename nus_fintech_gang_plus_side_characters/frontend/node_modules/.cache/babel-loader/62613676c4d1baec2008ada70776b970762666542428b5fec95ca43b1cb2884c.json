{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.autofillBatchTxn = exports.handleDeliverMax = exports.checkAccountDeleteBlockers = exports.setLatestValidatedLedgerSequence = exports.getTransactionFee = exports.setNextValidSequenceNumber = exports.setValidAddresses = exports.txNeedsNetworkID = void 0;\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"../utils\");\nconst getFeeXrp_1 = __importDefault(require(\"./getFeeXrp\"));\nconst LEDGER_OFFSET = 20;\nconst RESTRICTED_NETWORKS = 1024;\nconst REQUIRED_NETWORKID_VERSION = '1.11.0';\nfunction isNotLaterRippledVersion(source, target) {\n  if (source === target) {\n    return true;\n  }\n  const sourceDecomp = source.split('.');\n  const targetDecomp = target.split('.');\n  const sourceMajor = parseInt(sourceDecomp[0], 10);\n  const sourceMinor = parseInt(sourceDecomp[1], 10);\n  const targetMajor = parseInt(targetDecomp[0], 10);\n  const targetMinor = parseInt(targetDecomp[1], 10);\n  if (sourceMajor !== targetMajor) {\n    return sourceMajor < targetMajor;\n  }\n  if (sourceMinor !== targetMinor) {\n    return sourceMinor < targetMinor;\n  }\n  const sourcePatch = sourceDecomp[2].split('-');\n  const targetPatch = targetDecomp[2].split('-');\n  const sourcePatchVersion = parseInt(sourcePatch[0], 10);\n  const targetPatchVersion = parseInt(targetPatch[0], 10);\n  if (sourcePatchVersion !== targetPatchVersion) {\n    return sourcePatchVersion < targetPatchVersion;\n  }\n  if (sourcePatch.length !== targetPatch.length) {\n    return sourcePatch.length > targetPatch.length;\n  }\n  if (sourcePatch.length === 2) {\n    if (!sourcePatch[1][0].startsWith(targetPatch[1][0])) {\n      return sourcePatch[1] < targetPatch[1];\n    }\n    if (sourcePatch[1].startsWith('b')) {\n      return parseInt(sourcePatch[1].slice(1), 10) < parseInt(targetPatch[1].slice(1), 10);\n    }\n    return parseInt(sourcePatch[1].slice(2), 10) < parseInt(targetPatch[1].slice(2), 10);\n  }\n  return false;\n}\nfunction txNeedsNetworkID(client) {\n  if (client.networkID !== undefined && client.networkID > RESTRICTED_NETWORKS) {\n    if (client.buildVersion && isNotLaterRippledVersion(REQUIRED_NETWORKID_VERSION, client.buildVersion)) {\n      return true;\n    }\n  }\n  return false;\n}\nexports.txNeedsNetworkID = txNeedsNetworkID;\nfunction setValidAddresses(tx) {\n  validateAccountAddress(tx, 'Account', 'SourceTag');\n  if (tx['Destination'] != null) {\n    validateAccountAddress(tx, 'Destination', 'DestinationTag');\n  }\n  convertToClassicAddress(tx, 'Authorize');\n  convertToClassicAddress(tx, 'Unauthorize');\n  convertToClassicAddress(tx, 'Owner');\n  convertToClassicAddress(tx, 'RegularKey');\n}\nexports.setValidAddresses = setValidAddresses;\nfunction validateAccountAddress(tx, accountField, tagField) {\n  const {\n    classicAccount,\n    tag\n  } = getClassicAccountAndTag(tx[accountField]);\n  tx[accountField] = classicAccount;\n  if (tag != null && tag !== false) {\n    if (tx[tagField] && tx[tagField] !== tag) {\n      throw new errors_1.ValidationError(`The ${tagField}, if present, must match the tag of the ${accountField} X-address`);\n    }\n    tx[tagField] = tag;\n  }\n}\nfunction getClassicAccountAndTag(account, expectedTag) {\n  if ((0, ripple_address_codec_1.isValidXAddress)(account)) {\n    const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(account);\n    if (expectedTag != null && classic.tag !== expectedTag) {\n      throw new errors_1.ValidationError('address includes a tag that does not match the tag specified in the transaction');\n    }\n    return {\n      classicAccount: classic.classicAddress,\n      tag: classic.tag\n    };\n  }\n  return {\n    classicAccount: account,\n    tag: expectedTag\n  };\n}\nfunction convertToClassicAddress(tx, fieldName) {\n  const account = tx[fieldName];\n  if (typeof account === 'string') {\n    const {\n      classicAccount\n    } = getClassicAccountAndTag(account);\n    tx[fieldName] = classicAccount;\n  }\n}\nfunction getNextValidSequenceNumber(client, account) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const request = {\n      command: 'account_info',\n      account,\n      ledger_index: 'current'\n    };\n    const data = yield client.request(request);\n    return data.result.account_data.Sequence;\n  });\n}\nfunction setNextValidSequenceNumber(client, tx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    tx.Sequence = yield getNextValidSequenceNumber(client, tx.Account);\n  });\n}\nexports.setNextValidSequenceNumber = setNextValidSequenceNumber;\nfunction fetchOwnerReserveFee(client) {\n  var _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    const response = yield client.request({\n      command: 'server_state'\n    });\n    const fee = (_a = response.result.state.validated_ledger) === null || _a === void 0 ? void 0 : _a.reserve_inc;\n    if (fee == null) {\n      return Promise.reject(new Error('Could not fetch Owner Reserve.'));\n    }\n    return new bignumber_js_1.default(fee);\n  });\n}\nfunction fetchCounterPartySignersCount(client, tx) {\n  var _a, _b;\n  return __awaiter(this, void 0, void 0, function* () {\n    let counterParty = tx.Counterparty;\n    if (counterParty == null) {\n      if (tx.LoanBrokerID == null) {\n        throw new errors_1.ValidationError('LoanBrokerID is required for LoanSet transaction');\n      }\n      const resp = (yield client.request({\n        command: 'ledger_entry',\n        index: tx.LoanBrokerID,\n        ledger_index: 'validated'\n      })).result.node;\n      counterParty = resp.Owner;\n    }\n    const signerListRequest = {\n      command: 'account_info',\n      account: counterParty,\n      ledger_index: 'validated',\n      signer_lists: true\n    };\n    const signerListResponse = yield client.request(signerListRequest);\n    const signerList = (_a = signerListResponse.result.signer_lists) === null || _a === void 0 ? void 0 : _a[0];\n    return (_b = signerList === null || signerList === void 0 ? void 0 : signerList.SignerEntries.length) !== null && _b !== void 0 ? _b : 1;\n  });\n}\nfunction calculateFeePerTransactionType(client, tx, signersCount = 0) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const netFeeXRP = yield (0, getFeeXrp_1.default)(client);\n    const netFeeDrops = (0, utils_1.xrpToDrops)(netFeeXRP);\n    let baseFee = new bignumber_js_1.default(netFeeDrops);\n    const isSpecialTxCost = ['AccountDelete', 'AMMCreate', 'VaultCreate'].includes(tx.TransactionType);\n    if (tx.TransactionType === 'EscrowFinish' && tx.Fulfillment != null) {\n      const fulfillmentBytesSize = Math.ceil(tx.Fulfillment.length / 2);\n      baseFee = new bignumber_js_1.default(scaleValue(netFeeDrops, 33 + fulfillmentBytesSize / 16));\n    } else if (isSpecialTxCost) {\n      baseFee = yield fetchOwnerReserveFee(client);\n    } else if (tx.TransactionType === 'Batch') {\n      const rawTxFees = yield tx.RawTransactions.reduce((acc, rawTxn) => __awaiter(this, void 0, void 0, function* () {\n        const resolvedAcc = yield acc;\n        const fee = yield calculateFeePerTransactionType(client, rawTxn.RawTransaction);\n        return bignumber_js_1.default.sum(resolvedAcc, fee);\n      }), Promise.resolve(new bignumber_js_1.default(0)));\n      baseFee = bignumber_js_1.default.sum(baseFee.times(2), rawTxFees);\n    }\n    if (signersCount > 0) {\n      baseFee = bignumber_js_1.default.sum(baseFee, scaleValue(netFeeDrops, signersCount));\n    }\n    if (tx.TransactionType === 'LoanSet') {\n      const counterPartySignersCount = yield fetchCounterPartySignersCount(client, tx);\n      baseFee = bignumber_js_1.default.sum(baseFee, scaleValue(netFeeDrops, counterPartySignersCount));\n      console.warn(`For LoanSet transaction the auto calculated Fee accounts for total number of signers the counterparty has to avoid transaction failure.`);\n    }\n    const maxFeeDrops = (0, utils_1.xrpToDrops)(client.maxFeeXRP);\n    const totalFee = isSpecialTxCost ? baseFee : bignumber_js_1.default.min(baseFee, maxFeeDrops);\n    return totalFee.dp(0, bignumber_js_1.default.ROUND_CEIL);\n  });\n}\nfunction getTransactionFee(client, tx, signersCount = 0) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const fee = yield calculateFeePerTransactionType(client, tx, signersCount);\n    tx.Fee = fee.toString(10);\n  });\n}\nexports.getTransactionFee = getTransactionFee;\nfunction scaleValue(value, multiplier) {\n  return new bignumber_js_1.default(value).times(multiplier).toString();\n}\nfunction setLatestValidatedLedgerSequence(client, tx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const ledgerSequence = yield client.getLedgerIndex();\n    tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET;\n  });\n}\nexports.setLatestValidatedLedgerSequence = setLatestValidatedLedgerSequence;\nfunction checkAccountDeleteBlockers(client, tx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const request = {\n      command: 'account_objects',\n      account: tx.Account,\n      ledger_index: 'validated',\n      deletion_blockers_only: true\n    };\n    const response = yield client.request(request);\n    return new Promise((resolve, reject) => {\n      if (response.result.account_objects.length > 0) {\n        reject(new errors_1.XrplError(`Account ${tx.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`, response.result.account_objects));\n      }\n      resolve();\n    });\n  });\n}\nexports.checkAccountDeleteBlockers = checkAccountDeleteBlockers;\nfunction handleDeliverMax(tx) {\n  var _a;\n  if (tx.DeliverMax != null) {\n    (_a = tx.Amount) !== null && _a !== void 0 ? _a : tx.Amount = tx.DeliverMax;\n    if (tx.Amount != null && tx.Amount !== tx.DeliverMax) {\n      throw new errors_1.ValidationError('PaymentTransaction: Amount and DeliverMax fields must be identical when both are provided');\n    }\n    delete tx.DeliverMax;\n  }\n}\nexports.handleDeliverMax = handleDeliverMax;\nfunction autofillBatchTxn(client, tx) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const accountSequences = {};\n    for (const rawTxn of tx.RawTransactions) {\n      const txn = rawTxn.RawTransaction;\n      if (txn.Sequence == null && txn.TicketSequence == null) {\n        if (txn.Account in accountSequences) {\n          txn.Sequence = accountSequences[txn.Account];\n          accountSequences[txn.Account] += 1;\n        } else {\n          const nextSequence = yield getNextValidSequenceNumber(client, txn.Account);\n          const sequence = txn.Account === tx.Account ? nextSequence + 1 : nextSequence;\n          accountSequences[txn.Account] = sequence + 1;\n          txn.Sequence = sequence;\n        }\n      }\n      if (txn.Fee == null) {\n        txn.Fee = '0';\n      } else if (txn.Fee !== '0') {\n        throw new errors_1.XrplError('Must have `Fee of \"0\" in inner Batch transaction.');\n      }\n      if (txn.SigningPubKey == null) {\n        txn.SigningPubKey = '';\n      } else if (txn.SigningPubKey !== '') {\n        throw new errors_1.XrplError('Must have `SigningPubKey` of \"\" in inner Batch transaction.');\n      }\n      if (txn.TxnSignature != null) {\n        throw new errors_1.XrplError('Must not have `TxnSignature` in inner Batch transaction.');\n      }\n      if (txn.Signers != null) {\n        throw new errors_1.XrplError('Must not have `Signers` in inner Batch transaction.');\n      }\n      if (txn.NetworkID == null && txNeedsNetworkID(client)) {\n        txn.NetworkID = client.networkID;\n      }\n    }\n  });\n}\nexports.autofillBatchTxn = autofillBatchTxn;","map":{"version":3,"names":["bignumber_js_1","__importDefault","require","ripple_address_codec_1","errors_1","utils_1","getFeeXrp_1","LEDGER_OFFSET","RESTRICTED_NETWORKS","REQUIRED_NETWORKID_VERSION","isNotLaterRippledVersion","source","target","sourceDecomp","split","targetDecomp","sourceMajor","parseInt","sourceMinor","targetMajor","targetMinor","sourcePatch","targetPatch","sourcePatchVersion","targetPatchVersion","length","startsWith","slice","txNeedsNetworkID","client","networkID","undefined","buildVersion","exports","setValidAddresses","tx","validateAccountAddress","convertToClassicAddress","accountField","tagField","classicAccount","tag","getClassicAccountAndTag","ValidationError","account","expectedTag","isValidXAddress","classic","xAddressToClassicAddress","classicAddress","fieldName","getNextValidSequenceNumber","request","command","ledger_index","data","result","account_data","Sequence","setNextValidSequenceNumber","Account","fetchOwnerReserveFee","response","fee","_a","state","validated_ledger","reserve_inc","Promise","reject","Error","default","fetchCounterPartySignersCount","counterParty","Counterparty","LoanBrokerID","resp","index","node","Owner","signerListRequest","signer_lists","signerListResponse","signerList","_b","SignerEntries","calculateFeePerTransactionType","signersCount","netFeeXRP","netFeeDrops","xrpToDrops","baseFee","isSpecialTxCost","includes","TransactionType","Fulfillment","fulfillmentBytesSize","Math","ceil","scaleValue","rawTxFees","RawTransactions","reduce","acc","rawTxn","__awaiter","resolvedAcc","RawTransaction","sum","resolve","times","counterPartySignersCount","console","warn","maxFeeDrops","maxFeeXRP","totalFee","min","dp","ROUND_CEIL","getTransactionFee","Fee","toString","value","multiplier","setLatestValidatedLedgerSequence","ledgerSequence","getLedgerIndex","LastLedgerSequence","checkAccountDeleteBlockers","deletion_blockers_only","account_objects","XrplError","handleDeliverMax","DeliverMax","Amount","autofillBatchTxn","accountSequences","txn","TicketSequence","nextSequence","sequence","SigningPubKey","TxnSignature","Signers","NetworkID"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/sugar/autofill.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/consistent-type-assertions -- required here */\n/* eslint-disable max-lines -- lots of helper functions needed for autofill */\nimport BigNumber from 'bignumber.js'\nimport { xAddressToClassicAddress, isValidXAddress } from 'ripple-address-codec'\n\nimport { type Client } from '..'\nimport { ValidationError, XrplError } from '../errors'\nimport { LoanBroker } from '../models/ledger'\nimport {\n  AccountInfoRequest,\n  AccountObjectsRequest,\n  LedgerEntryRequest,\n} from '../models/methods'\nimport { Batch, Payment, Transaction } from '../models/transactions'\nimport { Account } from '../models/transactions/common'\nimport { xrpToDrops } from '../utils'\n\nimport getFeeXrp from './getFeeXrp'\n\n// Expire unconfirmed transactions after 20 ledger versions, approximately 1 minute, by default\nconst LEDGER_OFFSET = 20\n// Sidechains are expected to have network IDs above this.\n// Networks with ID above this restricted number are expected specify an accurate NetworkID field\n// in every transaction to that chain to prevent replay attacks.\n// Mainnet and testnet are exceptions. More context: https://github.com/XRPLF/rippled/pull/4370\nconst RESTRICTED_NETWORKS = 1024\nconst REQUIRED_NETWORKID_VERSION = '1.11.0'\n\n/**\n * Determines whether the source rippled version is not later than the target rippled version.\n * Example usage: isNotLaterRippledVersion('1.10.0', '1.11.0') returns true.\n *                isNotLaterRippledVersion('1.10.0', '1.10.0-b1') returns false.\n *\n * @param source -- The source rippled version.\n * @param target -- The target rippled version.\n * @returns True if source is earlier than target, false otherwise.\n */\n// eslint-disable-next-line max-lines-per-function, max-statements -- Disable for this helper functions.\nfunction isNotLaterRippledVersion(source: string, target: string): boolean {\n  if (source === target) {\n    return true\n  }\n  const sourceDecomp = source.split('.')\n  const targetDecomp = target.split('.')\n  const sourceMajor = parseInt(sourceDecomp[0], 10)\n  const sourceMinor = parseInt(sourceDecomp[1], 10)\n  const targetMajor = parseInt(targetDecomp[0], 10)\n  const targetMinor = parseInt(targetDecomp[1], 10)\n  // Compare major version\n  if (sourceMajor !== targetMajor) {\n    return sourceMajor < targetMajor\n  }\n  // Compare minor version\n  if (sourceMinor !== targetMinor) {\n    return sourceMinor < targetMinor\n  }\n  const sourcePatch = sourceDecomp[2].split('-')\n  const targetPatch = targetDecomp[2].split('-')\n\n  const sourcePatchVersion = parseInt(sourcePatch[0], 10)\n  const targetPatchVersion = parseInt(targetPatch[0], 10)\n\n  // Compare patch version\n  if (sourcePatchVersion !== targetPatchVersion) {\n    return sourcePatchVersion < targetPatchVersion\n  }\n\n  // Compare release version\n  if (sourcePatch.length !== targetPatch.length) {\n    return sourcePatch.length > targetPatch.length\n  }\n\n  if (sourcePatch.length === 2) {\n    // Compare different release types\n    if (!sourcePatch[1][0].startsWith(targetPatch[1][0])) {\n      return sourcePatch[1] < targetPatch[1]\n    }\n    // Compare beta version\n    if (sourcePatch[1].startsWith('b')) {\n      return (\n        parseInt(sourcePatch[1].slice(1), 10) <\n        parseInt(targetPatch[1].slice(1), 10)\n      )\n    }\n    // Compare rc version\n    return (\n      parseInt(sourcePatch[1].slice(2), 10) <\n      parseInt(targetPatch[1].slice(2), 10)\n    )\n  }\n\n  return false\n}\n\n/**\n * Determine if the transaction required a networkID to be valid.\n * Transaction needs networkID if later than restricted ID and build version is >= 1.11.0\n *\n * @param client -- The connected client.\n * @returns True if required networkID, false otherwise.\n */\nexport function txNeedsNetworkID(client: Client): boolean {\n  if (\n    client.networkID !== undefined &&\n    client.networkID > RESTRICTED_NETWORKS\n  ) {\n    if (\n      client.buildVersion &&\n      isNotLaterRippledVersion(REQUIRED_NETWORKID_VERSION, client.buildVersion)\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\ninterface ClassicAccountAndTag {\n  classicAccount: string\n  tag: number | false | undefined\n}\n\n/**\n * Sets valid addresses for the transaction.\n *\n * @param tx - The transaction object.\n */\nexport function setValidAddresses(tx: Transaction): void {\n  validateAccountAddress(tx, 'Account', 'SourceTag')\n  // eslint-disable-next-line @typescript-eslint/dot-notation -- Destination can exist on Transaction\n  if (tx['Destination'] != null) {\n    validateAccountAddress(tx, 'Destination', 'DestinationTag')\n  }\n\n  // DepositPreauth:\n  convertToClassicAddress(tx, 'Authorize')\n  convertToClassicAddress(tx, 'Unauthorize')\n  // EscrowCancel, EscrowFinish:\n  convertToClassicAddress(tx, 'Owner')\n  // SetRegularKey:\n  convertToClassicAddress(tx, 'RegularKey')\n}\n\n/**\n * Validates the account address in a transaction object.\n *\n * @param tx - The transaction object.\n * @param accountField - The field name for the account address in the transaction object.\n * @param tagField - The field name for the tag in the transaction object.\n * @throws {ValidationError} If the tag field does not match the tag of the account address.\n */\nfunction validateAccountAddress(\n  tx: Transaction,\n  accountField: string,\n  tagField: string,\n): void {\n  // if X-address is given, convert it to classic address\n  const { classicAccount, tag } = getClassicAccountAndTag(\n    tx[accountField] as string,\n  )\n  // eslint-disable-next-line no-param-reassign -- param reassign is safe\n  tx[accountField] = classicAccount\n\n  if (tag != null && tag !== false) {\n    if (tx[tagField] && tx[tagField] !== tag) {\n      throw new ValidationError(\n        `The ${tagField}, if present, must match the tag of the ${accountField} X-address`,\n      )\n    }\n    // eslint-disable-next-line no-param-reassign -- param reassign is safe\n    tx[tagField] = tag\n  }\n}\n\n/**\n * Retrieves the classic account and tag from an account address.\n *\n * @param account - The account address.\n * @param [expectedTag] - The expected tag for the account address.\n * @returns The classic account and tag.\n * @throws {ValidationError} If the address includes a tag that does not match the tag specified in the transaction.\n */\nfunction getClassicAccountAndTag(\n  account: string,\n  expectedTag?: number,\n): ClassicAccountAndTag {\n  if (isValidXAddress(account)) {\n    const classic = xAddressToClassicAddress(account)\n    if (expectedTag != null && classic.tag !== expectedTag) {\n      throw new ValidationError(\n        'address includes a tag that does not match the tag specified in the transaction',\n      )\n    }\n    return {\n      classicAccount: classic.classicAddress,\n      tag: classic.tag,\n    }\n  }\n  return {\n    classicAccount: account,\n    tag: expectedTag,\n  }\n}\n\n/**\n * Converts the specified field of a transaction object to a classic address format.\n *\n * @param tx - The transaction object.\n * @param fieldName - The name of the field to convert.export\n */\nfunction convertToClassicAddress(tx: Transaction, fieldName: string): void {\n  const account = tx[fieldName]\n  if (typeof account === 'string') {\n    const { classicAccount } = getClassicAccountAndTag(account)\n    // eslint-disable-next-line no-param-reassign -- param reassign is safe\n    tx[fieldName] = classicAccount\n  }\n}\n\n// Helper function to get the next valid sequence number for an account.\nasync function getNextValidSequenceNumber(\n  client: Client,\n  account: string,\n): Promise<number> {\n  const request: AccountInfoRequest = {\n    command: 'account_info',\n    account,\n    ledger_index: 'current',\n  }\n  const data = await client.request(request)\n  return data.result.account_data.Sequence\n}\n\n/**\n * Sets the next valid sequence number for a transaction.\n *\n * @param client - The client object used for making requests.\n * @param tx - The transaction object for which the sequence number needs to be set.\n * @returns A Promise that resolves when the sequence number is set.\n * @throws {Error} If there is an error retrieving the account information.\n */\nexport async function setNextValidSequenceNumber(\n  client: Client,\n  tx: Transaction,\n): Promise<void> {\n  // eslint-disable-next-line no-param-reassign, require-atomic-updates -- param reassign is safe with no race condition\n  tx.Sequence = await getNextValidSequenceNumber(client, tx.Account)\n}\n\n/**\n * Fetches the owner reserve fee from the server state using the provided client.\n *\n * @param client - The client object used to make the request.\n * @returns A Promise that resolves to the owner reserve fee as a BigNumber.\n * @throws {Error} Throws an error if the owner reserve fee cannot be fetched.\n */\nasync function fetchOwnerReserveFee(client: Client): Promise<BigNumber> {\n  const response = await client.request({ command: 'server_state' })\n  const fee = response.result.state.validated_ledger?.reserve_inc\n\n  if (fee == null) {\n    return Promise.reject(new Error('Could not fetch Owner Reserve.'))\n  }\n\n  return new BigNumber(fee)\n}\n\n/**\n * Fetches the total number of signers for the counterparty of a LoanSet transaction.\n *\n * @param client - The client object used to make the request.\n * @param tx - The transaction object for which the counterparty signers count needs to be fetched.\n * @returns A Promise that resolves to the number of signers for the counterparty.\n * @throws {ValidationError} Throws an error if LoanBrokerID is not provided in the transaction.\n */\nasync function fetchCounterPartySignersCount(\n  client: Client,\n  tx: Transaction,\n): Promise<number> {\n  let counterParty: Account | undefined = tx.Counterparty as Account | undefined\n  // Loan Borrower initiated the transaction, Loan Broker is the counterparty.\n  if (counterParty == null) {\n    if (tx.LoanBrokerID == null) {\n      throw new ValidationError(\n        'LoanBrokerID is required for LoanSet transaction',\n      )\n    }\n    const resp = (\n      await client.request({\n        command: 'ledger_entry',\n        index: tx.LoanBrokerID,\n        ledger_index: 'validated',\n      } as LedgerEntryRequest)\n    ).result.node as LoanBroker\n\n    counterParty = resp.Owner\n  }\n\n  // Now fetch the signer list for the counterparty.\n  const signerListRequest: AccountInfoRequest = {\n    command: 'account_info',\n    account: counterParty,\n    ledger_index: 'validated',\n    signer_lists: true,\n  }\n\n  const signerListResponse = await client.request(signerListRequest)\n  const signerList = signerListResponse.result.signer_lists?.[0]\n  return signerList?.SignerEntries.length ?? 1\n}\n\n/**\n * Calculates the fee per transaction type.\n *\n * @param client - The client object.\n * @param tx - The transaction object.\n * @param [signersCount=0] - The number of signers (default is 0). Only used for multisigning.\n * @returns A promise that returns the fee.\n */\n// eslint-disable-next-line max-lines-per-function -- necessary to check for many transaction types.\nasync function calculateFeePerTransactionType(\n  client: Client,\n  tx: Transaction,\n  signersCount = 0,\n): Promise<BigNumber> {\n  const netFeeXRP = await getFeeXrp(client)\n  const netFeeDrops = xrpToDrops(netFeeXRP)\n  let baseFee = new BigNumber(netFeeDrops)\n\n  const isSpecialTxCost = [\n    'AccountDelete',\n    'AMMCreate',\n    'VaultCreate',\n  ].includes(tx.TransactionType)\n\n  // EscrowFinish Transaction with Fulfillment\n  if (tx.TransactionType === 'EscrowFinish' && tx.Fulfillment != null) {\n    const fulfillmentBytesSize: number = Math.ceil(tx.Fulfillment.length / 2)\n    // BaseFee × (33 + (Fulfillment size in bytes / 16))\n    baseFee = new BigNumber(\n      // eslint-disable-next-line @typescript-eslint/no-magic-numbers -- expected use of magic numbers\n      scaleValue(netFeeDrops, 33 + fulfillmentBytesSize / 16),\n    )\n  } else if (isSpecialTxCost) {\n    baseFee = await fetchOwnerReserveFee(client)\n  } else if (tx.TransactionType === 'Batch') {\n    const rawTxFees = await tx.RawTransactions.reduce(\n      async (acc, rawTxn) => {\n        const resolvedAcc = await acc\n        const fee = await calculateFeePerTransactionType(\n          client,\n          rawTxn.RawTransaction,\n        )\n        return BigNumber.sum(resolvedAcc, fee)\n      },\n      Promise.resolve(new BigNumber(0)),\n    )\n    baseFee = BigNumber.sum(baseFee.times(2), rawTxFees)\n  }\n\n  /*\n   * Multi-signed Transaction\n   * BaseFee × (1 + Number of Signatures Provided)\n   */\n  if (signersCount > 0) {\n    baseFee = BigNumber.sum(baseFee, scaleValue(netFeeDrops, signersCount))\n  }\n\n  // LoanSet transactions have additional fees based on the number of signers for the counterparty.\n  if (tx.TransactionType === 'LoanSet') {\n    const counterPartySignersCount = await fetchCounterPartySignersCount(\n      client,\n      tx,\n    )\n    baseFee = BigNumber.sum(\n      baseFee,\n      scaleValue(netFeeDrops, counterPartySignersCount),\n    )\n    // eslint-disable-next-line no-console -- necessary to inform users about autofill behavior\n    console.warn(\n      `For LoanSet transaction the auto calculated Fee accounts for total number of signers the counterparty has to avoid transaction failure.`,\n    )\n  }\n\n  const maxFeeDrops = xrpToDrops(client.maxFeeXRP)\n  const totalFee = isSpecialTxCost\n    ? baseFee\n    : BigNumber.min(baseFee, maxFeeDrops)\n\n  // Round up baseFee and return it as a string\n  return totalFee.dp(0, BigNumber.ROUND_CEIL)\n}\n\n/**\n * Calculates the fee per transaction type and sets it in the transaction.\n *\n * @param client - The client object.\n * @param tx - The transaction object.\n * @param [signersCount=0] - The number of signers (default is 0). Only used for multisigning.\n * @returns A promise that resolves with void. Modifies the `tx` parameter to give it the calculated fee.\n */\nexport async function getTransactionFee(\n  client: Client,\n  tx: Transaction,\n  signersCount = 0,\n): Promise<void> {\n  const fee = await calculateFeePerTransactionType(client, tx, signersCount)\n  // eslint-disable-next-line @typescript-eslint/no-magic-numbers, require-atomic-updates, no-param-reassign -- fine here\n  tx.Fee = fee.toString(10)\n}\n\n/**\n * Scales the given value by multiplying it with the provided multiplier.\n *\n * @param value - The value to be scaled.\n * @param multiplier - The multiplier to scale the value.\n * @returns The scaled value as a string.\n */\nfunction scaleValue(value, multiplier): string {\n  return new BigNumber(value).times(multiplier).toString()\n}\n\n/**\n * Sets the latest validated ledger sequence for the transaction.\n *\n * @param client - The client object.\n * @param tx - The transaction object.\n * @returns A promise that resolves with void. Modifies the `tx` parameter setting `LastLedgerSequence`.\n */\nexport async function setLatestValidatedLedgerSequence(\n  client: Client,\n  tx: Transaction,\n): Promise<void> {\n  const ledgerSequence = await client.getLedgerIndex()\n  // eslint-disable-next-line no-param-reassign -- param reassign is safe\n  tx.LastLedgerSequence = ledgerSequence + LEDGER_OFFSET\n}\n\n/**\n * Checks for any blockers that prevent the deletion of an account.\n *\n * @param client - The client object.\n * @param tx - The transaction object.\n * @returns A promise that resolves with void if there are no blockers, or rejects with an XrplError if there are blockers.\n */\nexport async function checkAccountDeleteBlockers(\n  client: Client,\n  tx: Transaction,\n): Promise<void> {\n  const request: AccountObjectsRequest = {\n    command: 'account_objects',\n    account: tx.Account,\n    ledger_index: 'validated',\n    deletion_blockers_only: true,\n  }\n  const response = await client.request(request)\n  return new Promise((resolve, reject) => {\n    if (response.result.account_objects.length > 0) {\n      reject(\n        new XrplError(\n          `Account ${tx.Account} cannot be deleted; there are Escrows, PayChannels, RippleStates, or Checks associated with the account.`,\n          response.result.account_objects,\n        ),\n      )\n    }\n    resolve()\n  })\n}\n\n/**\n * Replaces Amount with DeliverMax if needed.\n *\n * @param tx - The transaction object.\n * @throws ValidationError if Amount and DeliverMax are both provided but do not match.\n */\nexport function handleDeliverMax(tx: Payment): void {\n  if (tx.DeliverMax != null) {\n    // If only DeliverMax is provided, use it to populate the Amount field\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, no-param-reassign -- needed here\n    tx.Amount ??= tx.DeliverMax\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- needed here\n    if (tx.Amount != null && tx.Amount !== tx.DeliverMax) {\n      throw new ValidationError(\n        'PaymentTransaction: Amount and DeliverMax fields must be identical when both are provided',\n      )\n    }\n\n    // eslint-disable-next-line no-param-reassign -- needed here\n    delete tx.DeliverMax\n  }\n}\n\n/**\n * Autofills all the relevant `x` fields.\n *\n * @param client - The client object.\n * @param tx - The transaction object.\n * @returns A promise that resolves with void if there are no blockers, or rejects with an XrplError if there are blockers.\n */\n// eslint-disable-next-line complexity, max-lines-per-function -- needed here, lots to check\nexport async function autofillBatchTxn(\n  client: Client,\n  tx: Batch,\n): Promise<void> {\n  const accountSequences: Record<string, number> = {}\n\n  for (const rawTxn of tx.RawTransactions) {\n    const txn = rawTxn.RawTransaction\n\n    // Sequence processing\n    if (txn.Sequence == null && txn.TicketSequence == null) {\n      if (txn.Account in accountSequences) {\n        txn.Sequence = accountSequences[txn.Account]\n        accountSequences[txn.Account] += 1\n      } else {\n        // eslint-disable-next-line no-await-in-loop -- It has to wait\n        const nextSequence = await getNextValidSequenceNumber(\n          client,\n          txn.Account,\n        )\n        const sequence =\n          txn.Account === tx.Account ? nextSequence + 1 : nextSequence\n        accountSequences[txn.Account] = sequence + 1\n        txn.Sequence = sequence\n      }\n    }\n\n    if (txn.Fee == null) {\n      txn.Fee = '0'\n    } else if (txn.Fee !== '0') {\n      throw new XrplError('Must have `Fee of \"0\" in inner Batch transaction.')\n    }\n\n    if (txn.SigningPubKey == null) {\n      txn.SigningPubKey = ''\n    } else if (txn.SigningPubKey !== '') {\n      throw new XrplError(\n        'Must have `SigningPubKey` of \"\" in inner Batch transaction.',\n      )\n    }\n\n    if (txn.TxnSignature != null) {\n      throw new XrplError(\n        'Must not have `TxnSignature` in inner Batch transaction.',\n      )\n    }\n\n    if (txn.Signers != null) {\n      throw new XrplError('Must not have `Signers` in inner Batch transaction.')\n    }\n\n    if (txn.NetworkID == null && txNeedsNetworkID(client)) {\n      txn.NetworkID = client.networkID\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}