{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;\nexports.abool = abool;\nexports._abool2 = _abool2;\nexports._abytes2 = _abytes2;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.equalBytes = equalBytes;\nexports.copyBytes = copyBytes;\nexports.asciiToBytes = asciiToBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.isHash = isHash;\nexports._validateObject = _validateObject;\nexports.memoized = memoized;\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_js_1 = require(\"@noble/hashes/utils.js\");\nvar utils_js_2 = require(\"@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"abytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.abytes;\n  }\n});\nObject.defineProperty(exports, \"anumber\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.anumber;\n  }\n});\nObject.defineProperty(exports, \"bytesToHex\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.bytesToHex;\n  }\n});\nObject.defineProperty(exports, \"bytesToUtf8\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.bytesToUtf8;\n  }\n});\nObject.defineProperty(exports, \"concatBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.concatBytes;\n  }\n});\nObject.defineProperty(exports, \"hexToBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.hexToBytes;\n  }\n});\nObject.defineProperty(exports, \"isBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.isBytes;\n  }\n});\nObject.defineProperty(exports, \"randomBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.randomBytes;\n  }\n});\nObject.defineProperty(exports, \"utf8ToBytes\", {\n  enumerable: true,\n  get: function () {\n    return utils_js_2.utf8ToBytes;\n  }\n});\nconst _0n = /* @__PURE__ */BigInt(0);\nconst _1n = /* @__PURE__ */BigInt(1);\nfunction abool(title, value) {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n// tmp name until v2\nfunction _abool2(value, title = '') {\n  if (typeof value !== 'boolean') {\n    const prefix = title && `\"${title}\"`;\n    throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n  }\n  return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nfunction _abytes2(value, length, title = '') {\n  const bytes = (0, utils_js_1.isBytes)(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || needsLen && len !== length) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber((0, utils_js_1.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n  (0, utils_js_1.abytes)(bytes);\n  return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n  return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n  return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = (0, utils_js_1.hexToBytes)(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if ((0, utils_js_1.isBytes)(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nfunction copyBytes(bytes) {\n  return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nfunction asciiToBytes(ascii) {\n  return Uint8Array.from(ascii, (c, i) => {\n    const charCode = c.charCodeAt(0);\n    if (c.length !== 1 || charCode > 127) {\n      throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n    }\n    return charCode;\n  });\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = n => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max)) throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = n => (_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  const u8n = len => new Uint8Array(len); // creates Uint8Array\n  const u8of = byte => Uint8Array.of(byte); // another shortcut\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return (0, utils_js_1.concatBytes)(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  stringOrUint8Array: val => typeof val === 'string' || (0, utils_js_1.isBytes)(val),\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n  return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  function checkField(fieldName, expectedType, isOpt) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null) throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n  throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n  const map = new WeakMap();\n  return (arg, ...args) => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}","map":{"version":3,"names":["exports","abool","_abool2","_abytes2","numberToHexUnpadded","hexToNumber","bytesToNumberBE","bytesToNumberLE","numberToBytesBE","numberToBytesLE","numberToVarBytesBE","ensureBytes","equalBytes","copyBytes","asciiToBytes","inRange","aInRange","bitLen","bitGet","bitSet","createHmacDrbg","validateObject","isHash","_validateObject","memoized","utils_js_1","require","utils_js_2","Object","defineProperty","enumerable","get","abytes","anumber","bytesToHex","bytesToUtf8","concatBytes","hexToBytes","isBytes","randomBytes","utf8ToBytes","_0n","BigInt","_1n","title","value","Error","prefix","length","bytes","len","needsLen","undefined","ofLen","got","num","hex","toString","Uint8Array","from","reverse","n","padStart","expectedLength","res","e","a","b","diff","i","ascii","c","charCode","charCodeAt","isPosBig","min","max","pos","bitMask","hashLen","qByteLen","hmacFn","u8n","u8of","byte","of","v","k","reset","fill","h","reseed","seed","gen","out","sl","slice","push","genUntil","pred","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isSafeInteger","Number","array","Array","isArray","field","object","Fp","isValid","hash","outputLen","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","entries","fields","optFields","expectedType","isOpt","current","forEach","notImplemented","fn","map","WeakMap","arg","args","computed","set"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/@noble/curves/src/utils.ts"],"sourcesContent":["/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n  isBytes as isBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  bytesToUtf8,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// tmp name until v2\nexport function _abool2(value: boolean, title: string = ''): boolean {\n  if (typeof value !== 'boolean') {\n    const prefix = title && `\"${title}\"`;\n    throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n  }\n  return value;\n}\n\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nexport function _abytes2(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes_(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes_(bytes);\n  return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes_(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes_(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nexport function asciiToBytes(ascii: string): Uint8Array {\n  return Uint8Array.from(ascii, (c, i) => {\n    const charCode = c.charCodeAt(0);\n    if (c.length !== 1 || charCode > 127) {\n      throw new Error(\n        `string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`\n      );\n    }\n    return charCode;\n  });\n}\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  const u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\n  const u8of = (byte: number) => Uint8Array.of(byte); // another shortcut\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes_(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\nexport function isHash(val: CHash): boolean {\n  return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string>,\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}