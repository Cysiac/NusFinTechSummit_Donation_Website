{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PrimeEdwardsPoint = void 0;\nexports.edwards = edwards;\nexports.eddsa = eddsa;\nexports.twistedEdwards = twistedEdwards;\n/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\nconst curve_ts_1 = require(\"./curve.js\");\nconst modular_ts_1 = require(\"./modular.js\");\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _8n = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\nfunction edwards(params, extraOpts = {}) {\n  const validated = (0, curve_ts_1._createCurveFields)('edwards', params, extraOpts, extraOpts.FpFnLE);\n  const {\n    Fp,\n    Fn\n  } = validated;\n  let CURVE = validated.CURVE;\n  const {\n    h: cofactor\n  } = CURVE;\n  (0, utils_ts_1._validateObject)(extraOpts, {}, {\n    uvRatio: 'function'\n  });\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;\n  const modP = n => Fp.create(n); // Function overrides\n  // sqrt(u/v)\n  const uvRatio = extraOpts.uvRatio || ((u, v) => {\n    try {\n      return {\n        isValid: true,\n        value: Fp.sqrt(Fp.div(u, v))\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        value: _0n\n      };\n    }\n  });\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title, n, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    (0, utils_ts_1.aInRange)('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n  function aextpoint(other) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {\n    const {\n      X,\n      Y,\n      Z\n    } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily\n    const x = modP(X * iz);\n    const y = modP(Y * iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return {\n      x: _0n,\n      y: _1n\n    };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return {\n      x,\n      y\n    };\n  });\n  const assertValidMemo = (0, utils_ts_1.memoized)(p => {\n    const {\n      a,\n      d\n    } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const {\n      X,\n      Y,\n      Z,\n      T\n    } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point {\n    constructor(X, Y, Z, T) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y);\n      this.Z = acoord('z', Z, true);\n      this.T = acoord('t', T);\n      Object.freeze(this);\n    }\n    static CURVE() {\n      return CURVE;\n    }\n    static fromAffine(p) {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const {\n        x,\n        y\n      } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    // Uses algo from RFC8032 5.1.3.\n    static fromBytes(bytes, zip215 = false) {\n      const len = Fp.BYTES;\n      const {\n        a,\n        d\n      } = CURVE;\n      bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, 'point'));\n      (0, utils_ts_1._abool2)(zip215, 'zip215');\n      const normed = (0, utils_ts_1.copyBytes)(bytes); // copy again, we'll manipulate it\n      const lastByte = bytes[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = (0, utils_ts_1.bytesToNumberLE)(normed);\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      (0, utils_ts_1.aInRange)('point.y', y, _0n, max);\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let {\n        isValid,\n        value: x\n      } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('bad point: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('bad point: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({\n        x,\n        y\n      });\n    }\n    static fromHex(bytes, zip215 = false) {\n      return Point.fromBytes((0, utils_ts_1.ensureBytes)('point', bytes), zip215);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    precompute(windowSize = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n    // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    // Compare one point to another.\n    equals(other) {\n      aextpoint(other);\n      const {\n        X: X1,\n        Y: Y1,\n        Z: Z1\n      } = this;\n      const {\n        X: X2,\n        Y: Y2,\n        Z: Z2\n      } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    negate() {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n    }\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double() {\n      const {\n        a\n      } = CURVE;\n      const {\n        X: X1,\n        Y: Y1,\n        Z: Z1\n      } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other) {\n      aextpoint(other);\n      const {\n        a,\n        d\n      } = CURVE;\n      const {\n        X: X1,\n        Y: Y1,\n        Z: Z1,\n        T: T1\n      } = this;\n      const {\n        X: X2,\n        Y: Y2,\n        Z: Z2,\n        T: T2\n      } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    // Constant-time multiplication.\n    multiply(scalar) {\n      // 1 <= scalar < L\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n      const {\n        p,\n        f\n      } = wnaf.cached(this, scalar, p => (0, curve_ts_1.normalizeZ)(Point, p));\n      return (0, curve_ts_1.normalizeZ)(Point, [p, f])[0];\n    }\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar, acc = Point.ZERO) {\n      // 0 <= scalar < L\n      if (!Fn.isValid(scalar)) throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n      if (scalar === _0n) return Point.ZERO;\n      if (this.is0() || scalar === _1n) return this;\n      return wnaf.unsafe(this, scalar, p => (0, curve_ts_1.normalizeZ)(Point, p), acc);\n    }\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder() {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree() {\n      return wnaf.unsafe(this, CURVE.n).is0();\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ) {\n      return toAffineMemo(this, invertedZ);\n    }\n    clearCofactor() {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n    toBytes() {\n      const {\n        x,\n        y\n      } = this.toAffine();\n      // Fp.toBytes() allows non-canonical encoding of y (>= p).\n      const bytes = Fp.toBytes(y);\n      // Each y has 2 valid points: (x, y), (x,-y).\n      // When compressing, it's enough to store y and use the last byte to encode sign of x\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n      return bytes;\n    }\n    toHex() {\n      return (0, utils_ts_1.bytesToHex)(this.toBytes());\n    }\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n    // TODO: remove\n    get ex() {\n      return this.X;\n    }\n    get ey() {\n      return this.Y;\n    }\n    get ez() {\n      return this.Z;\n    }\n    get et() {\n      return this.T;\n    }\n    static normalizeZ(points) {\n      return (0, curve_ts_1.normalizeZ)(Point, points);\n    }\n    static msm(points, scalars) {\n      return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);\n    }\n    _setWindowSize(windowSize) {\n      this.precompute(windowSize);\n    }\n    toRawBytes() {\n      return this.toBytes();\n    }\n  }\n  // base / generator point\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n  // zero / infinity / identity point\n  Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n  // math field\n  Point.Fp = Fp;\n  // scalar field\n  Point.Fn = Fn;\n  const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nclass PrimeEdwardsPoint {\n  constructor(ep) {\n    this.ep = ep;\n  }\n  // Static methods that must be implemented by subclasses\n  static fromBytes(_bytes) {\n    (0, utils_ts_1.notImplemented)();\n  }\n  static fromHex(_hex) {\n    (0, utils_ts_1.notImplemented)();\n  }\n  get x() {\n    return this.toAffine().x;\n  }\n  get y() {\n    return this.toAffine().y;\n  }\n  // Common implementations\n  clearCofactor() {\n    // no-op for prime-order groups\n    return this;\n  }\n  assertValidity() {\n    this.ep.assertValidity();\n  }\n  toAffine(invertedZ) {\n    return this.ep.toAffine(invertedZ);\n  }\n  toHex() {\n    return (0, utils_ts_1.bytesToHex)(this.toBytes());\n  }\n  toString() {\n    return this.toHex();\n  }\n  isTorsionFree() {\n    return true;\n  }\n  isSmallOrder() {\n    return false;\n  }\n  add(other) {\n    this.assertSame(other);\n    return this.init(this.ep.add(other.ep));\n  }\n  subtract(other) {\n    this.assertSame(other);\n    return this.init(this.ep.subtract(other.ep));\n  }\n  multiply(scalar) {\n    return this.init(this.ep.multiply(scalar));\n  }\n  multiplyUnsafe(scalar) {\n    return this.init(this.ep.multiplyUnsafe(scalar));\n  }\n  double() {\n    return this.init(this.ep.double());\n  }\n  negate() {\n    return this.init(this.ep.negate());\n  }\n  precompute(windowSize, isLazy) {\n    return this.init(this.ep.precompute(windowSize, isLazy));\n  }\n  /** @deprecated use `toBytes` */\n  toRawBytes() {\n    return this.toBytes();\n  }\n}\nexports.PrimeEdwardsPoint = PrimeEdwardsPoint;\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nfunction eddsa(Point, cHash, eddsaOpts = {}) {\n  if (typeof cHash !== 'function') throw new Error('\"hash\" function param is required');\n  (0, utils_ts_1._validateObject)(eddsaOpts, {}, {\n    adjustScalarBytes: 'function',\n    randomBytes: 'function',\n    domain: 'function',\n    prehash: 'function',\n    mapToCurve: 'function'\n  });\n  const {\n    prehash\n  } = eddsaOpts;\n  const {\n    BASE,\n    Fp,\n    Fn\n  } = Point;\n  const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || (bytes => bytes);\n  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {\n    (0, utils_ts_1._abool2)(phflag, 'phflag');\n    if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n    return data;\n  }); // NOOP\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash) {\n    return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash)); // Not Fn.fromBytes: it has length limit\n  }\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key) {\n    const len = lengths.secretKey;\n    key = (0, utils_ts_1.ensureBytes)('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = (0, utils_ts_1.ensureBytes)('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return {\n      head,\n      prefix,\n      scalar\n    };\n  }\n  /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n  function getExtendedPublicKey(secretKey) {\n    const {\n      head,\n      prefix,\n      scalar\n    } = getPrivateScalar(secretKey);\n    const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return {\n      head,\n      prefix,\n      scalar,\n      point,\n      pointBytes\n    };\n  }\n  /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n  function getPublicKey(secretKey) {\n    return getExtendedPublicKey(secretKey).pointBytes;\n  }\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n    const msg = (0, utils_ts_1.concatBytes)(...msgs);\n    return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)('context', context), !!prehash)));\n  }\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg, secretKey, options = {}) {\n    msg = (0, utils_ts_1.ensureBytes)('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const {\n      prefix,\n      scalar,\n      pointBytes\n    } = getExtendedPublicKey(secretKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = BASE.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n    if (!Fn.isValid(s)) throw new Error('sign failed: invalid s'); // 0 <= s < L\n    const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));\n    return (0, utils_ts_1._abytes2)(rs, lengths.signature, 'result');\n  }\n  // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n  const verifyOpts = {\n    zip215: true\n  };\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig, msg, publicKey, options = verifyOpts) {\n    const {\n      context,\n      zip215\n    } = options;\n    const len = lengths.signature;\n    sig = (0, utils_ts_1.ensureBytes)('signature', sig, len);\n    msg = (0, utils_ts_1.ensureBytes)('message', msg);\n    publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, lengths.publicKey);\n    if (zip215 !== undefined) (0, utils_ts_1._abool2)(zip215, 'zip215');\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n    const mid = len / 2;\n    const r = sig.subarray(0, mid);\n    const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromBytes(publicKey, zip215);\n      R = Point.fromBytes(r, zip215);\n      SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n  const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n  const lengths = {\n    secretKey: _size,\n    publicKey: _size,\n    signature: 2 * _size,\n    seed: _size\n  };\n  function randomSecretKey(seed = randomBytes(lengths.seed)) {\n    return (0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed');\n  }\n  function keygen(seed) {\n    const secretKey = utils.randomSecretKey(seed);\n    return {\n      secretKey,\n      publicKey: getPublicKey(secretKey)\n    };\n  }\n  function isValidSecretKey(key) {\n    return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;\n  }\n  function isValidPublicKey(key, zip215) {\n    try {\n      return !!Point.fromBytes(key, zip215);\n    } catch (error) {\n      return false;\n    }\n  }\n  const utils = {\n    getExtendedPublicKey,\n    randomSecretKey,\n    isValidSecretKey,\n    isValidPublicKey,\n    /**\n     * Converts ed public key to x public key. Uses formula:\n     * - ed25519:\n     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n     * - ed448:\n     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n     */\n    toMontgomery(publicKey) {\n      const {\n        y\n      } = Point.fromBytes(publicKey);\n      const size = lengths.publicKey;\n      const is25519 = size === 32;\n      if (!is25519 && size !== 57) throw new Error('only defined for 25519 and 448');\n      const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n      return Fp.toBytes(u);\n    },\n    toMontgomerySecret(secretKey) {\n      const size = lengths.secretKey;\n      (0, utils_ts_1._abytes2)(secretKey, size);\n      const hashed = cHash(secretKey.subarray(0, size));\n      return adjustScalarBytes(hashed).subarray(0, size);\n    },\n    /** @deprecated */\n    randomPrivateKey: randomSecretKey,\n    /** @deprecated */\n    precompute(windowSize = 8, point = Point.BASE) {\n      return point.precompute(windowSize, false);\n    }\n  };\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point,\n    lengths\n  });\n}\nfunction _eddsa_legacy_opts_to_new(c) {\n  const CURVE = {\n    a: c.a,\n    d: c.d,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy\n  };\n  const Fp = c.Fp;\n  const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);\n  const curveOpts = {\n    Fp,\n    Fn,\n    uvRatio: c.uvRatio\n  };\n  const eddsaOpts = {\n    randomBytes: c.randomBytes,\n    adjustScalarBytes: c.adjustScalarBytes,\n    domain: c.domain,\n    prehash: c.prehash,\n    mapToCurve: c.mapToCurve\n  };\n  return {\n    CURVE,\n    curveOpts,\n    hash: c.hash,\n    eddsaOpts\n  };\n}\nfunction _eddsa_new_output_to_legacy(c, eddsa) {\n  const Point = eddsa.Point;\n  const legacy = Object.assign({}, eddsa, {\n    ExtendedPoint: Point,\n    CURVE: c,\n    nBitLength: Point.Fn.BITS,\n    nByteLength: Point.Fn.BYTES\n  });\n  return legacy;\n}\n// TODO: remove. Use eddsa\nfunction twistedEdwards(c) {\n  const {\n    CURVE,\n    curveOpts,\n    hash,\n    eddsaOpts\n  } = _eddsa_legacy_opts_to_new(c);\n  const Point = edwards(CURVE, curveOpts);\n  const EDDSA = eddsa(Point, hash, eddsaOpts);\n  return _eddsa_new_output_to_legacy(c, EDDSA);\n}","map":{"version":3,"names":["exports","edwards","eddsa","twistedEdwards","utils_ts_1","require","curve_ts_1","modular_ts_1","_0n","BigInt","_1n","_2n","_8n","isEdValidXY","Fp","CURVE","x","y","x2","sqr","y2","left","add","mul","a","right","ONE","d","eql","params","extraOpts","validated","_createCurveFields","FpFnLE","Fn","h","cofactor","_validateObject","uvRatio","MASK","BYTES","modP","n","create","u","v","isValid","value","sqrt","div","e","Gx","Gy","Error","acoord","title","banZero","min","aInRange","aextpoint","other","Point","toAffineMemo","memoized","p","iz","X","Y","Z","is0","inv","zz","assertValidMemo","T","X2","Y2","Z2","Z4","aX2","XY","ZT","constructor","Object","freeze","fromAffine","fromBytes","bytes","zip215","len","copyBytes","_abytes2","_abool2","normed","lastByte","bytesToNumberLE","max","ORDER","isXOdd","isLastByteOdd","fromHex","ensureBytes","toAffine","precompute","windowSize","isLazy","wnaf","createCache","multiply","assertValidity","equals","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","ZERO","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","subtract","scalar","isValidNot0","f","cached","normalizeZ","multiplyUnsafe","acc","unsafe","isSmallOrder","isTorsionFree","invertedZ","clearCofactor","toBytes","length","toHex","bytesToHex","toString","ex","ey","ez","et","points","msm","scalars","pippenger","_setWindowSize","toRawBytes","BASE","wNAF","BITS","PrimeEdwardsPoint","ep","_bytes","notImplemented","_hex","assertSame","init","cHash","eddsaOpts","adjustScalarBytes","randomBytes","domain","prehash","mapToCurve","data","ctx","phflag","modN_LE","hash","getPrivateScalar","key","lengths","secretKey","hashed","head","slice","prefix","getExtendedPublicKey","point","pointBytes","getPublicKey","hashDomainToScalar","context","Uint8Array","of","msgs","msg","concatBytes","sign","options","r","R","k","s","rs","signature","verifyOpts","verify","sig","publicKey","undefined","mid","subarray","SB","error","RkA","_size","seed","randomSecretKey","keygen","utils","isValidSecretKey","isBytes","isValidPublicKey","toMontgomery","size","is25519","toMontgomerySecret","randomPrivateKey","_eddsa_legacy_opts_to_new","c","Field","nBitLength","curveOpts","_eddsa_new_output_to_legacy","legacy","assign","ExtendedPoint","nByteLength","EDDSA"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/@noble/curves/src/abstract/edwards.ts"],"sourcesContent":["/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  _abool2 as abool,\n  _abytes2 as abytes,\n  aInRange,\n  bytesToHex,\n  bytesToNumberLE,\n  concatBytes,\n  copyBytes,\n  ensureBytes,\n  isBytes,\n  memoized,\n  notImplemented,\n  randomBytes as randomBytesWeb,\n  type FHash,\n  type Hex,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport { Field, type IField, type NLength } from './modular.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\nexport type UVRatio = (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPoint extends CurvePoint<bigint, EdwardsPoint> {\n  /** extended X coordinate. Different from affine x. */\n  readonly X: bigint;\n  /** extended Y coordinate. Different from affine y. */\n  readonly Y: bigint;\n  /** extended Z coordinate */\n  readonly Z: bigint;\n  /** extended T coordinate */\n  readonly T: bigint;\n\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n  /** @deprecated use .X */\n  readonly ex: bigint;\n  /** @deprecated use .Y */\n  readonly ey: bigint;\n  /** @deprecated use .Z */\n  readonly ez: bigint;\n  /** @deprecated use .T */\n  readonly et: bigint;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPointCons extends CurvePointCons<EdwardsPoint> {\n  new (X: bigint, Y: bigint, Z: bigint, T: bigint): EdwardsPoint;\n  CURVE(): EdwardsOpts;\n  fromBytes(bytes: Uint8Array, zip215?: boolean): EdwardsPoint;\n  fromHex(hex: Hex, zip215?: boolean): EdwardsPoint;\n  /** @deprecated use `import { pippenger } from '@noble/curves/abstract/curve.js';` */\n  msm(points: EdwardsPoint[], scalars: bigint[]): EdwardsPoint;\n}\n/** @deprecated use EdwardsPoint */\nexport type ExtPointType = EdwardsPoint;\n/** @deprecated use EdwardsPointCons */\nexport type ExtPointConstructor = EdwardsPointCons;\n\n/**\n * Twisted Edwards curve options.\n *\n * * a: formula param\n * * d: formula param\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor. h*n is group order; n is subgroup order\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type EdwardsOpts = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: bigint;\n  d: bigint;\n  Gx: bigint;\n  Gy: bigint;\n}>;\n\n/**\n * Extra curve options for Twisted Edwards.\n *\n * * Fp: redefined Field over curve.p\n * * Fn: redefined Field over curve.n\n * * uvRatio: helper function for decompression, calculating √(u/v)\n */\nexport type EdwardsExtraOpts = Partial<{\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  FpFnLE: boolean;\n  uvRatio: (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) options.\n *\n * * hash: hash function used to hash secret keys and messages\n * * adjustScalarBytes: clears bits to get valid field element\n * * domain: Used for hashing\n * * mapToCurve: for hash-to-curve standard\n * * prehash: RFC 8032 pre-hashing of messages to sign() / verify()\n * * randomBytes: function generating random bytes, used for randomSecretKey\n */\nexport type EdDSAOpts = Partial<{\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  domain: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  mapToCurve: (scalar: bigint[]) => AffinePoint<bigint>;\n  prehash: FHash;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) interface.\n *\n * Allows to create and verify signatures, create public and secret keys.\n */\nexport interface EdDSA {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Hex) => Uint8Array;\n  sign: (message: Hex, secretKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  Point: EdwardsPointCons;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    isValidSecretKey: (secretKey: Uint8Array) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, zip215?: boolean) => boolean;\n\n    /**\n     * Converts ed public key to x public key.\n     *\n     * There is NO `fromMontgomery`:\n     * - There are 2 valid ed25519 points for every x25519, with flipped coordinate\n     * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*\n     *   accepts inputs on the quadratic twist, which can't be moved to ed25519\n     *\n     * @example\n     * ```js\n     * const someonesPub = ed25519.getPublicKey(ed25519.utils.randomSecretKey());\n     * const aPriv = x25519.utils.randomSecretKey();\n     * x25519.getSharedSecret(aPriv, ed25519.utils.toMontgomery(someonesPub))\n     * ```\n     */\n    toMontgomery: (publicKey: Uint8Array) => Uint8Array;\n    /**\n     * Converts ed secret key to x secret key.\n     * @example\n     * ```js\n     * const someonesPub = x25519.getPublicKey(x25519.utils.randomSecretKey());\n     * const aPriv = ed25519.utils.randomSecretKey();\n     * x25519.getSharedSecret(ed25519.utils.toMontgomerySecret(aPriv), someonesPub)\n     * ```\n     */\n    toMontgomerySecret: (privateKey: Uint8Array) => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: EdwardsPoint;\n      pointBytes: Uint8Array;\n    };\n\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `point.precompute()` */\n    precompute: (windowSize?: number, point?: EdwardsPoint) => EdwardsPoint;\n  };\n  lengths: CurveLengths;\n}\n\nfunction isEdValidXY(Fp: IField<bigint>, CURVE: EdwardsOpts, x: bigint, y: bigint): boolean {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\n\nexport function edwards(params: EdwardsOpts, extraOpts: EdwardsExtraOpts = {}): EdwardsPointCons {\n  const validated = _createCurveFields('edwards', params, extraOpts, extraOpts.FpFnLE);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as EdwardsOpts;\n  const { h: cofactor } = CURVE;\n  _validateObject(extraOpts, {}, { uvRatio: 'function' });\n\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n  const modP = (n: bigint) => Fp.create(n); // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    extraOpts.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error('bad curve params: generator point');\n\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { X, Y, Z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(Z) as bigint); // 8 was chosen arbitrarily\n    const x = modP(X * iz);\n    const y = modP(Y * iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const { X, Y, Z, T } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements EdwardsPoint {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: bigint;\n    readonly Y: bigint;\n    readonly Z: bigint;\n    readonly T: bigint;\n\n    constructor(X: bigint, Y: bigint, Z: bigint, T: bigint) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y);\n      this.Z = acoord('z', Z, true);\n      this.T = acoord('t', T);\n      Object.freeze(this);\n    }\n\n    static CURVE(): EdwardsOpts {\n      return CURVE;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n\n    // Uses algo from RFC8032 5.1.3.\n    static fromBytes(bytes: Uint8Array, zip215 = false): Point {\n      const len = Fp.BYTES;\n      const { a, d } = CURVE;\n      bytes = copyBytes(abytes(bytes, len, 'point'));\n      abool(zip215, 'zip215');\n      const normed = copyBytes(bytes); // copy again, we'll manipulate it\n      const lastByte = bytes[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('point.y', y, _0n, max);\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('bad point: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('bad point: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromHex(bytes: Uint8Array, zip215 = false): Point {\n      return Point.fromBytes(ensureBytes('point', bytes), zip215);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    precompute(windowSize: number = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n\n    // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      // 1 <= scalar < L\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n      const { p, f } = wnaf.cached(this, scalar, (p) => normalizeZ(Point, p));\n      return normalizeZ(Point, [p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      // 0 <= scalar < L\n      if (!Fn.isValid(scalar)) throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n      if (scalar === _0n) return Point.ZERO;\n      if (this.is0() || scalar === _1n) return this;\n      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafe(this, CURVE.n).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    clearCofactor(): Point {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    toBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      // Fp.toBytes() allows non-canonical encoding of y (>= p).\n      const bytes = Fp.toBytes(y);\n      // Each y has 2 valid points: (x, y), (x,-y).\n      // When compressing, it's enough to store y and use the last byte to encode sign of x\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n      return bytes;\n    }\n    toHex(): string {\n      return bytesToHex(this.toBytes());\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n\n    // TODO: remove\n    get ex(): bigint {\n      return this.X;\n    }\n    get ey(): bigint {\n      return this.Y;\n    }\n    get ez(): bigint {\n      return this.Z;\n    }\n    get et(): bigint {\n      return this.T;\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, points);\n    }\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n    toRawBytes(): Uint8Array {\n      return this.toBytes();\n    }\n  }\n  const wnaf = new wNAF(Point, Fn.BITS);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport abstract class PrimeEdwardsPoint<T extends PrimeEdwardsPoint<T>>\n  implements CurvePoint<bigint, T>\n{\n  static BASE: PrimeEdwardsPoint<any>;\n  static ZERO: PrimeEdwardsPoint<any>;\n  static Fp: IField<bigint>;\n  static Fn: IField<bigint>;\n\n  protected readonly ep: EdwardsPoint;\n\n  constructor(ep: EdwardsPoint) {\n    this.ep = ep;\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract toBytes(): Uint8Array;\n  abstract equals(other: T): boolean;\n\n  // Static methods that must be implemented by subclasses\n  static fromBytes(_bytes: Uint8Array): any {\n    notImplemented();\n  }\n\n  static fromHex(_hex: Hex): any {\n    notImplemented();\n  }\n\n  get x(): bigint {\n    return this.toAffine().x;\n  }\n  get y(): bigint {\n    return this.toAffine().y;\n  }\n\n  // Common implementations\n  clearCofactor(): T {\n    // no-op for prime-order groups\n    return this as any;\n  }\n\n  assertValidity(): void {\n    this.ep.assertValidity();\n  }\n\n  toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n    return this.ep.toAffine(invertedZ);\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  isTorsionFree(): boolean {\n    return true;\n  }\n\n  isSmallOrder(): boolean {\n    return false;\n  }\n\n  add(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.add(other.ep));\n  }\n\n  subtract(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): T {\n    return this.init(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): T {\n    return this.init(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): T {\n    return this.init(this.ep.double());\n  }\n\n  negate(): T {\n    return this.init(this.ep.negate());\n  }\n\n  precompute(windowSize?: number, isLazy?: boolean): T {\n    return this.init(this.ep.precompute(windowSize, isLazy));\n  }\n\n  // Helper methods\n  abstract is0(): boolean;\n  protected abstract assertSame(other: T): void;\n  protected abstract init(ep: EdwardsPoint): T;\n\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array {\n    return this.toBytes();\n  }\n}\n\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point: EdwardsPointCons, cHash: FHash, eddsaOpts: EdDSAOpts = {}): EdDSA {\n  if (typeof cHash !== 'function') throw new Error('\"hash\" function param is required');\n  _validateObject(\n    eddsaOpts,\n    {},\n    {\n      adjustScalarBytes: 'function',\n      randomBytes: 'function',\n      domain: 'function',\n      prehash: 'function',\n      mapToCurve: 'function',\n    }\n  );\n\n  const { prehash } = eddsaOpts;\n  const { BASE, Fp, Fn } = Point;\n\n  const randomBytes = eddsaOpts.randomBytes || randomBytesWeb;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const domain =\n    eddsaOpts.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool(phflag, 'phflag');\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return Fn.create(bytesToNumberLE(hash)); // Not Fn.fromBytes: it has length limit\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = lengths.secretKey;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n  function getExtendedPublicKey(secretKey: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(secretKey);\n    const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n  function getPublicKey(secretKey: Hex): Uint8Array {\n    return getExtendedPublicKey(secretKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, secretKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = BASE.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n    if (!Fn.isValid(s)) throw new Error('sign failed: invalid s'); // 0 <= s < L\n    const rs = concatBytes(R, Fn.toBytes(s));\n    return abytes(rs, lengths.signature, 'result');\n  }\n\n  // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n  const verifyOpts: { context?: Hex; zip215?: boolean } = { zip215: true };\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = lengths.signature;\n    sig = ensureBytes('signature', sig, len);\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, lengths.publicKey);\n    if (zip215 !== undefined) abool(zip215, 'zip215');\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const mid = len / 2;\n    const r = sig.subarray(0, mid);\n    const s = bytesToNumberLE(sig.subarray(mid, len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromBytes(publicKey, zip215);\n      R = Point.fromBytes(r, zip215);\n      SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n\n  const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n  const lengths = {\n    secretKey: _size,\n    publicKey: _size,\n    signature: 2 * _size,\n    seed: _size,\n  };\n  function randomSecretKey(seed = randomBytes(lengths.seed)): Uint8Array {\n    return abytes(seed, lengths.seed, 'seed');\n  }\n  function keygen(seed?: Uint8Array) {\n    const secretKey = utils.randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  }\n  function isValidSecretKey(key: Uint8Array): boolean {\n    return isBytes(key) && key.length === Fn.BYTES;\n  }\n  function isValidPublicKey(key: Uint8Array, zip215?: boolean): boolean {\n    try {\n      return !!Point.fromBytes(key, zip215);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  const utils = {\n    getExtendedPublicKey,\n    randomSecretKey,\n    isValidSecretKey,\n    isValidPublicKey,\n    /**\n     * Converts ed public key to x public key. Uses formula:\n     * - ed25519:\n     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n     * - ed448:\n     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n     */\n    toMontgomery(publicKey: Uint8Array): Uint8Array {\n      const { y } = Point.fromBytes(publicKey);\n      const size = lengths.publicKey;\n      const is25519 = size === 32;\n      if (!is25519 && size !== 57) throw new Error('only defined for 25519 and 448');\n      const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n      return Fp.toBytes(u);\n    },\n\n    toMontgomerySecret(secretKey: Uint8Array): Uint8Array {\n      const size = lengths.secretKey;\n      abytes(secretKey, size);\n      const hashed = cHash(secretKey.subarray(0, size));\n      return adjustScalarBytes(hashed).subarray(0, size);\n    },\n\n    /** @deprecated */\n    randomPrivateKey: randomSecretKey,\n    /** @deprecated */\n    precompute(windowSize = 8, point: EdwardsPoint = Point.BASE): EdwardsPoint {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point,\n    lengths,\n  });\n}\n\n// TODO: remove everything below\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  /** @deprecated the property will be removed in next release */\n  hash: FHash; // Hashing\n  randomBytes?: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: UVRatio; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\nexport type CurveTypeWithLength = Readonly<CurveType & Partial<NLength>>;\nexport type CurveFn = {\n  /** @deprecated the property will be removed in next release */\n  CURVE: CurveType;\n  keygen: EdDSA['keygen'];\n  getPublicKey: EdDSA['getPublicKey'];\n  sign: EdDSA['sign'];\n  verify: EdDSA['verify'];\n  Point: EdwardsPointCons;\n  /** @deprecated use `Point` */\n  ExtendedPoint: EdwardsPointCons;\n  utils: EdDSA['utils'];\n  lengths: CurveLengths;\n};\nexport type EdComposed = {\n  CURVE: EdwardsOpts;\n  curveOpts: EdwardsExtraOpts;\n  hash: FHash;\n  eddsaOpts: EdDSAOpts;\n};\nfunction _eddsa_legacy_opts_to_new(c: CurveTypeWithLength): EdComposed {\n  const CURVE: EdwardsOpts = {\n    a: c.a,\n    d: c.d,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  const Fn = Field(CURVE.n, c.nBitLength, true);\n  const curveOpts: EdwardsExtraOpts = { Fp, Fn, uvRatio: c.uvRatio };\n  const eddsaOpts: EdDSAOpts = {\n    randomBytes: c.randomBytes,\n    adjustScalarBytes: c.adjustScalarBytes,\n    domain: c.domain,\n    prehash: c.prehash,\n    mapToCurve: c.mapToCurve,\n  };\n  return { CURVE, curveOpts, hash: c.hash, eddsaOpts };\n}\nfunction _eddsa_new_output_to_legacy(c: CurveTypeWithLength, eddsa: EdDSA): CurveFn {\n  const Point = eddsa.Point;\n  const legacy = Object.assign({}, eddsa, {\n    ExtendedPoint: Point,\n    CURVE: c,\n    nBitLength: Point.Fn.BITS,\n    nByteLength: Point.Fn.BYTES,\n  });\n  return legacy;\n}\n// TODO: remove. Use eddsa\nexport function twistedEdwards(c: CurveTypeWithLength): CurveFn {\n  const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n  const Point = edwards(CURVE, curveOpts);\n  const EDDSA = eddsa(Point, hash, eddsaOpts);\n  return _eddsa_new_output_to_legacy(c, EDDSA);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}