{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.STObject = void 0;\nconst enums_1 = require(\"../enums\");\nconst serialized_type_1 = require(\"./serialized-type\");\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst binary_parser_1 = require(\"../serdes/binary-parser\");\nconst binary_serializer_1 = require(\"../serdes/binary-serializer\");\nconst st_array_1 = require(\"./st-array\");\nconst uint_64_1 = require(\"./uint-64\");\nconst OBJECT_END_MARKER_BYTE = Uint8Array.from([0xe1]);\nconst OBJECT_END_MARKER = 'ObjectEndMarker';\nconst ST_OBJECT = 'STObject';\nconst DESTINATION = 'Destination';\nconst ACCOUNT = 'Account';\nconst SOURCE_TAG = 'SourceTag';\nconst DEST_TAG = 'DestinationTag';\n/**\n * Break down an X-Address into an account and a tag\n *\n * @param field Name of field\n * @param xAddress X-Address corresponding to the field\n */\nfunction handleXAddress(field, xAddress) {\n  const decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);\n  let tagName;\n  if (field === DESTINATION) tagName = DEST_TAG;else if (field === ACCOUNT) tagName = SOURCE_TAG;else if (decoded.tag !== false) throw new Error(`${field} cannot have an associated tag`);\n  return decoded.tag !== false ? {\n    [field]: decoded.classicAddress,\n    [tagName]: decoded.tag\n  } : {\n    [field]: decoded.classicAddress\n  };\n}\n/**\n * Validate that two objects don't both have the same tag fields\n *\n * @param obj1 First object to check for tags\n * @param obj2 Second object to check for tags\n * @throws When both objects have SourceTag or DestinationTag\n */\nfunction checkForDuplicateTags(obj1, obj2) {\n  if (!(obj1[SOURCE_TAG] === undefined || obj2[SOURCE_TAG] === undefined)) throw new Error('Cannot have Account X-Address and SourceTag');\n  if (!(obj1[DEST_TAG] === undefined || obj2[DEST_TAG] === undefined)) throw new Error('Cannot have Destination X-Address and DestinationTag');\n}\n/**\n * Class for Serializing/Deserializing objects\n */\nclass STObject extends serialized_type_1.SerializedType {\n  /**\n   * Construct a STObject from a BinaryParser\n   *\n   * @param parser BinaryParser to read STObject from\n   * @returns A STObject object\n   */\n  static fromParser(parser) {\n    const list = new binary_serializer_1.BytesList();\n    const bytes = new binary_serializer_1.BinarySerializer(list);\n    while (!parser.end()) {\n      const field = parser.readField();\n      if (field.name === OBJECT_END_MARKER) {\n        break;\n      }\n      const associatedValue = parser.readFieldValue(field);\n      bytes.writeFieldAndValue(field, associatedValue);\n      if (field.type.name === ST_OBJECT) {\n        bytes.put(OBJECT_END_MARKER_BYTE);\n      }\n    }\n    return new STObject(list.toBytes());\n  }\n  /**\n   * Construct a STObject from a JSON object\n   *\n   * @param value An object to include\n   * @param filter optional, denote which field to include in serialized object\n   * @param definitions optional, types and values to use to encode/decode a transaction\n   * @returns a STObject object\n   */\n  static from(value, filter, definitions = enums_1.DEFAULT_DEFINITIONS) {\n    if (value instanceof STObject) {\n      return value;\n    }\n    const list = new binary_serializer_1.BytesList();\n    const bytes = new binary_serializer_1.BinarySerializer(list);\n    let isUnlModify = false;\n    const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {\n      let handled = undefined;\n      if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {\n        handled = handleXAddress(key, val.toString());\n        checkForDuplicateTags(handled, value);\n      }\n      return Object.assign(acc, handled !== null && handled !== void 0 ? handled : {\n        [key]: val\n      });\n    }, {});\n    function isValidFieldInstance(f) {\n      return f !== undefined && xAddressDecoded[f.name] !== undefined && f.isSerialized;\n    }\n    let sorted = Object.keys(xAddressDecoded).map(f => {\n      if (!(f in definitions.field)) {\n        if (f[0] === f[0].toLowerCase()) return undefined;\n        throw new Error(`Field ${f} is not defined in the definitions`);\n      }\n      return definitions.field[f];\n    }).filter(isValidFieldInstance).sort((a, b) => {\n      return a.ordinal - b.ordinal;\n    });\n    if (filter !== undefined) {\n      sorted = sorted.filter(filter);\n    }\n    sorted.forEach(field => {\n      const associatedValue = field.type.name === ST_OBJECT ? this.from(xAddressDecoded[field.name], undefined, definitions) : field.type.name === 'STArray' ? st_array_1.STArray.from(xAddressDecoded[field.name], definitions) : field.type.name === 'UInt64' ? uint_64_1.UInt64.from(xAddressDecoded[field.name], field.name) : field.associatedType.from(xAddressDecoded[field.name]);\n      if (associatedValue == undefined) {\n        throw new TypeError(`Unable to interpret \"${field.name}: ${xAddressDecoded[field.name]}\".`);\n      }\n      if (associatedValue.name === 'UNLModify') {\n        // triggered when the TransactionType field has a value of 'UNLModify'\n        isUnlModify = true;\n      }\n      // true when in the UNLModify pseudotransaction (after the transaction type has been processed) and working with the\n      // Account field\n      // The Account field must not be a part of the UNLModify pseudotransaction encoding, due to a bug in rippled\n      const isUnlModifyWorkaround = field.name == 'Account' && isUnlModify;\n      bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);\n      if (field.type.name === ST_OBJECT) {\n        bytes.put(OBJECT_END_MARKER_BYTE);\n      }\n    });\n    return new STObject(list.toBytes());\n  }\n  /**\n   * Get the JSON interpretation of this.bytes\n   * @param definitions rippled definitions used to parse the values of transaction types and such.\n   *                          Can be customized for sidechains and amendments.\n   * @returns a JSON object\n   */\n  toJSON(definitions) {\n    const objectParser = new binary_parser_1.BinaryParser(this.toString(), definitions);\n    const accumulator = {};\n    while (!objectParser.end()) {\n      const field = objectParser.readField();\n      if (field.name === OBJECT_END_MARKER) {\n        break;\n      }\n      accumulator[field.name] = objectParser.readFieldValue(field).toJSON(definitions, field.name);\n    }\n    return accumulator;\n  }\n}\nexports.STObject = STObject;","map":{"version":3,"names":["enums_1","require","serialized_type_1","ripple_address_codec_1","binary_parser_1","binary_serializer_1","st_array_1","uint_64_1","OBJECT_END_MARKER_BYTE","Uint8Array","from","OBJECT_END_MARKER","ST_OBJECT","DESTINATION","ACCOUNT","SOURCE_TAG","DEST_TAG","handleXAddress","field","xAddress","decoded","xAddressToClassicAddress","tagName","tag","Error","classicAddress","checkForDuplicateTags","obj1","obj2","undefined","STObject","SerializedType","fromParser","parser","list","BytesList","bytes","BinarySerializer","end","readField","name","associatedValue","readFieldValue","writeFieldAndValue","type","put","toBytes","value","filter","definitions","DEFAULT_DEFINITIONS","isUnlModify","xAddressDecoded","Object","entries","reduce","acc","key","val","handled","isValidXAddress","toString","assign","isValidFieldInstance","f","isSerialized","sorted","keys","map","toLowerCase","sort","a","b","ordinal","forEach","STArray","UInt64","associatedType","TypeError","isUnlModifyWorkaround","toJSON","objectParser","BinaryParser","accumulator","exports"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/ripple-binary-codec/src/types/st-object.ts"],"sourcesContent":["import {\n  DEFAULT_DEFINITIONS,\n  FieldInstance,\n  Bytes,\n  XrplDefinitionsBase,\n} from '../enums'\nimport { SerializedType, JsonObject } from './serialized-type'\nimport { xAddressToClassicAddress, isValidXAddress } from 'ripple-address-codec'\nimport { BinaryParser } from '../serdes/binary-parser'\nimport { BinarySerializer, BytesList } from '../serdes/binary-serializer'\n\nimport { STArray } from './st-array'\nimport { UInt64 } from './uint-64'\n\nconst OBJECT_END_MARKER_BYTE = Uint8Array.from([0xe1])\nconst OBJECT_END_MARKER = 'ObjectEndMarker'\nconst ST_OBJECT = 'STObject'\nconst DESTINATION = 'Destination'\nconst ACCOUNT = 'Account'\nconst SOURCE_TAG = 'SourceTag'\nconst DEST_TAG = 'DestinationTag'\n\n/**\n * Break down an X-Address into an account and a tag\n *\n * @param field Name of field\n * @param xAddress X-Address corresponding to the field\n */\nfunction handleXAddress(field: string, xAddress: string): JsonObject {\n  const decoded = xAddressToClassicAddress(xAddress)\n\n  let tagName\n  if (field === DESTINATION) tagName = DEST_TAG\n  else if (field === ACCOUNT) tagName = SOURCE_TAG\n  else if (decoded.tag !== false)\n    throw new Error(`${field} cannot have an associated tag`)\n\n  return decoded.tag !== false\n    ? { [field]: decoded.classicAddress, [tagName]: decoded.tag }\n    : { [field]: decoded.classicAddress }\n}\n\n/**\n * Validate that two objects don't both have the same tag fields\n *\n * @param obj1 First object to check for tags\n * @param obj2 Second object to check for tags\n * @throws When both objects have SourceTag or DestinationTag\n */\nfunction checkForDuplicateTags(obj1: JsonObject, obj2: JsonObject): void {\n  if (!(obj1[SOURCE_TAG] === undefined || obj2[SOURCE_TAG] === undefined))\n    throw new Error('Cannot have Account X-Address and SourceTag')\n  if (!(obj1[DEST_TAG] === undefined || obj2[DEST_TAG] === undefined))\n    throw new Error('Cannot have Destination X-Address and DestinationTag')\n}\n\n/**\n * Class for Serializing/Deserializing objects\n */\nclass STObject extends SerializedType {\n  /**\n   * Construct a STObject from a BinaryParser\n   *\n   * @param parser BinaryParser to read STObject from\n   * @returns A STObject object\n   */\n  static fromParser(parser: BinaryParser): STObject {\n    const list: BytesList = new BytesList()\n    const bytes: BinarySerializer = new BinarySerializer(list)\n\n    while (!parser.end()) {\n      const field = parser.readField()\n      if (field.name === OBJECT_END_MARKER) {\n        break\n      }\n\n      const associatedValue = parser.readFieldValue(field)\n\n      bytes.writeFieldAndValue(field, associatedValue)\n      if (field.type.name === ST_OBJECT) {\n        bytes.put(OBJECT_END_MARKER_BYTE)\n      }\n    }\n\n    return new STObject(list.toBytes())\n  }\n\n  /**\n   * Construct a STObject from a JSON object\n   *\n   * @param value An object to include\n   * @param filter optional, denote which field to include in serialized object\n   * @param definitions optional, types and values to use to encode/decode a transaction\n   * @returns a STObject object\n   */\n  static from<T extends STObject | JsonObject>(\n    value: T,\n    filter?: (...any) => boolean,\n    definitions: XrplDefinitionsBase = DEFAULT_DEFINITIONS,\n  ): STObject {\n    if (value instanceof STObject) {\n      return value\n    }\n\n    const list: BytesList = new BytesList()\n    const bytes: BinarySerializer = new BinarySerializer(list)\n\n    let isUnlModify = false\n\n    const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {\n      let handled: JsonObject | undefined = undefined\n      if (val && isValidXAddress(val.toString())) {\n        handled = handleXAddress(key, val.toString())\n        checkForDuplicateTags(handled, value)\n      }\n      return Object.assign(acc, handled ?? { [key]: val })\n    }, {})\n\n    function isValidFieldInstance(\n      f: FieldInstance | undefined,\n    ): f is FieldInstance {\n      return (\n        f !== undefined &&\n        xAddressDecoded[f.name] !== undefined &&\n        f.isSerialized\n      )\n    }\n\n    let sorted = Object.keys(xAddressDecoded)\n      .map((f: string): FieldInstance | undefined => {\n        if (!(f in definitions.field)) {\n          if (f[0] === f[0].toLowerCase()) return undefined\n          throw new Error(`Field ${f} is not defined in the definitions`)\n        }\n        return definitions.field[f] as FieldInstance\n      })\n      .filter(isValidFieldInstance)\n      .sort((a, b) => {\n        return a.ordinal - b.ordinal\n      })\n\n    if (filter !== undefined) {\n      sorted = sorted.filter(filter)\n    }\n\n    sorted.forEach((field) => {\n      const associatedValue =\n        field.type.name === ST_OBJECT\n          ? this.from(xAddressDecoded[field.name], undefined, definitions)\n          : field.type.name === 'STArray'\n            ? STArray.from(xAddressDecoded[field.name], definitions)\n            : field.type.name === 'UInt64'\n              ? UInt64.from(xAddressDecoded[field.name], field.name)\n              : field.associatedType.from(xAddressDecoded[field.name])\n\n      if (associatedValue == undefined) {\n        throw new TypeError(\n          `Unable to interpret \"${field.name}: ${\n            xAddressDecoded[field.name]\n          }\".`,\n        )\n      }\n\n      if ((associatedValue as unknown as Bytes).name === 'UNLModify') {\n        // triggered when the TransactionType field has a value of 'UNLModify'\n        isUnlModify = true\n      }\n      // true when in the UNLModify pseudotransaction (after the transaction type has been processed) and working with the\n      // Account field\n      // The Account field must not be a part of the UNLModify pseudotransaction encoding, due to a bug in rippled\n      const isUnlModifyWorkaround = field.name == 'Account' && isUnlModify\n      bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround)\n      if (field.type.name === ST_OBJECT) {\n        bytes.put(OBJECT_END_MARKER_BYTE)\n      }\n    })\n\n    return new STObject(list.toBytes())\n  }\n\n  /**\n   * Get the JSON interpretation of this.bytes\n   * @param definitions rippled definitions used to parse the values of transaction types and such.\n   *                          Can be customized for sidechains and amendments.\n   * @returns a JSON object\n   */\n  toJSON(definitions?: XrplDefinitionsBase): JsonObject {\n    const objectParser = new BinaryParser(this.toString(), definitions)\n    const accumulator = {}\n\n    while (!objectParser.end()) {\n      const field = objectParser.readField()\n      if (field.name === OBJECT_END_MARKER) {\n        break\n      }\n\n      accumulator[field.name] = objectParser\n        .readFieldValue(field)\n        .toJSON(definitions, field.name)\n    }\n\n    return accumulator\n  }\n}\n\nexport { STObject }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}