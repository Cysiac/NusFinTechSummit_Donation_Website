{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\nconst eventemitter3_1 = require(\"eventemitter3\");\nconst errors_1 = require(\"../errors\");\nconst common_1 = require(\"../models/common\");\nconst flags_1 = require(\"../models/utils/flags\");\nconst sugar_1 = require(\"../sugar\");\nconst autofill_1 = require(\"../sugar/autofill\");\nconst balances_1 = require(\"../sugar/balances\");\nconst getOrderbook_1 = require(\"../sugar/getOrderbook\");\nconst utils_1 = require(\"../utils\");\nconst Wallet_1 = require(\"../Wallet\");\nconst fundWallet_1 = require(\"../Wallet/fundWallet\");\nconst connection_1 = require(\"./connection\");\nconst partialPayment_1 = require(\"./partialPayment\");\nfunction getCollectKeyFromCommand(command) {\n  switch (command) {\n    case 'account_channels':\n      return 'channels';\n    case 'account_lines':\n      return 'lines';\n    case 'account_objects':\n      return 'account_objects';\n    case 'account_tx':\n      return 'transactions';\n    case 'account_offers':\n    case 'book_offers':\n      return 'offers';\n    case 'ledger_data':\n      return 'state';\n    default:\n      return null;\n  }\n}\nfunction clamp(value, min, max) {\n  if (min > max) {\n    throw new Error('Illegal clamp bounds');\n  }\n  return Math.min(Math.max(value, min), max);\n}\nconst DEFAULT_FEE_CUSHION = 1.2;\nconst DEFAULT_MAX_FEE_XRP = '2';\nconst MIN_LIMIT = 10;\nconst MAX_LIMIT = 400;\nconst NORMAL_DISCONNECT_CODE = 1000;\nclass Client extends eventemitter3_1.EventEmitter {\n  constructor(server, options = {}) {\n    var _a, _b;\n    super();\n    this.apiVersion = common_1.DEFAULT_API_VERSION;\n    if (typeof server !== 'string' || !/wss?(?:\\+unix)?:\\/\\//u.exec(server)) {\n      throw new errors_1.ValidationError('server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.');\n    }\n    this.feeCushion = (_a = options.feeCushion) !== null && _a !== void 0 ? _a : DEFAULT_FEE_CUSHION;\n    this.maxFeeXRP = (_b = options.maxFeeXRP) !== null && _b !== void 0 ? _b : DEFAULT_MAX_FEE_XRP;\n    this.connection = new connection_1.Connection(server, options);\n    this.connection.on('error', (errorCode, errorMessage, data) => {\n      this.emit('error', errorCode, errorMessage, data);\n    });\n    this.connection.on('reconnect', () => {\n      this.connection.on('connected', () => this.emit('connected'));\n    });\n    this.connection.on('disconnected', code => {\n      let finalCode = code;\n      if (finalCode === connection_1.INTENTIONAL_DISCONNECT_CODE) {\n        finalCode = NORMAL_DISCONNECT_CODE;\n      }\n      this.emit('disconnected', finalCode);\n    });\n    this.connection.on('ledgerClosed', ledger => {\n      this.emit('ledgerClosed', ledger);\n    });\n    this.connection.on('transaction', tx => {\n      (0, partialPayment_1.handleStreamPartialPayment)(tx, this.connection.trace);\n      this.emit('transaction', tx);\n    });\n    this.connection.on('validationReceived', validation => {\n      this.emit('validationReceived', validation);\n    });\n    this.connection.on('manifestReceived', manifest => {\n      this.emit('manifestReceived', manifest);\n    });\n    this.connection.on('peerStatusChange', status => {\n      this.emit('peerStatusChange', status);\n    });\n    this.connection.on('consensusPhase', consensus => {\n      this.emit('consensusPhase', consensus);\n    });\n    this.connection.on('path_find', path => {\n      this.emit('path_find', path);\n    });\n  }\n  get url() {\n    return this.connection.getUrl();\n  }\n  request(req) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const request = Object.assign(Object.assign({}, req), {\n        account: typeof req.account === 'string' ? (0, sugar_1.ensureClassicAddress)(req.account) : undefined,\n        api_version: (_a = req.api_version) !== null && _a !== void 0 ? _a : this.apiVersion\n      });\n      const response = yield this.connection.request(request);\n      (0, partialPayment_1.handlePartialPayment)(req.command, response);\n      return response;\n    });\n  }\n  requestNextPage(req, resp) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!resp.result.marker) {\n        return Promise.reject(new errors_1.NotFoundError('response does not have a next page'));\n      }\n      const nextPageRequest = Object.assign(Object.assign({}, req), {\n        marker: resp.result.marker\n      });\n      return this.request(nextPageRequest);\n    });\n  }\n  on(eventName, listener) {\n    return super.on(eventName, listener);\n  }\n  requestAll(request, collect) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const collectKey = collect !== null && collect !== void 0 ? collect : getCollectKeyFromCommand(request.command);\n      if (!collectKey) {\n        throw new errors_1.ValidationError(`no collect key for command ${request.command}`);\n      }\n      const countTo = (_a = request.limit) !== null && _a !== void 0 ? _a : Infinity;\n      let count = 0;\n      let marker = request.marker;\n      const results = [];\n      do {\n        const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT);\n        const repeatProps = Object.assign(Object.assign({}, request), {\n          limit: countRemaining,\n          marker\n        });\n        const singleResponse = yield this.connection.request(repeatProps);\n        const singleResult = singleResponse.result;\n        if (!(collectKey in singleResult)) {\n          throw new errors_1.XrplError(`${collectKey} not in result`);\n        }\n        const collectedData = singleResult[collectKey];\n        marker = singleResult.marker;\n        results.push(singleResponse);\n        if (Array.isArray(collectedData)) {\n          count += collectedData.length;\n        }\n      } while (Boolean(marker) && count < countTo);\n      return results;\n    });\n  }\n  getServerInfo() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const response = yield this.request({\n          command: 'server_info'\n        });\n        this.networkID = (_a = response.result.info.network_id) !== null && _a !== void 0 ? _a : undefined;\n        this.buildVersion = response.result.info.build_version;\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.connection.connect().then(() => __awaiter(this, void 0, void 0, function* () {\n        yield this.getServerInfo();\n        this.emit('connected');\n      }));\n    });\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connection.disconnect();\n    });\n  }\n  isConnected() {\n    return this.connection.isConnected();\n  }\n  autofill(transaction, signersCount) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = Object.assign({}, transaction);\n      (0, autofill_1.setValidAddresses)(tx);\n      tx.Flags = (0, flags_1.convertTxFlagsToNumber)(tx);\n      const promises = [];\n      (_a = tx.NetworkID) !== null && _a !== void 0 ? _a : tx.NetworkID = (0, autofill_1.txNeedsNetworkID)(this) ? this.networkID : undefined;\n      if (tx.Sequence == null) {\n        promises.push((0, autofill_1.setNextValidSequenceNumber)(this, tx));\n      }\n      if (tx.Fee == null) {\n        promises.push((0, autofill_1.getTransactionFee)(this, tx, signersCount));\n      }\n      if (tx.LastLedgerSequence == null) {\n        promises.push((0, autofill_1.setLatestValidatedLedgerSequence)(this, tx));\n      }\n      if (tx.TransactionType === 'AccountDelete') {\n        promises.push((0, autofill_1.checkAccountDeleteBlockers)(this, tx));\n      }\n      if (tx.TransactionType === 'Batch') {\n        promises.push((0, autofill_1.autofillBatchTxn)(this, tx));\n      }\n      if (tx.TransactionType === 'Payment' && tx.DeliverMax != null) {\n        (0, autofill_1.handleDeliverMax)(tx);\n      }\n      return Promise.all(promises).then(() => tx);\n    });\n  }\n  simulate(transaction, opts) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const binary = (_a = opts === null || opts === void 0 ? void 0 : opts.binary) !== null && _a !== void 0 ? _a : false;\n      const request = typeof transaction === 'string' ? {\n        command: 'simulate',\n        tx_blob: transaction,\n        binary\n      } : {\n        command: 'simulate',\n        tx_json: transaction,\n        binary\n      };\n      return this.request(request);\n    });\n  }\n  submit(transaction, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);\n      return (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);\n    });\n  }\n  submitAndWait(transaction, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signedTx = yield (0, sugar_1.getSignedTx)(this, transaction, opts);\n      const lastLedger = (0, sugar_1.getLastLedgerSequence)(signedTx);\n      if (lastLedger == null) {\n        throw new errors_1.ValidationError('Transaction must contain a LastLedgerSequence value for reliable submission.');\n      }\n      const response = yield (0, sugar_1.submitRequest)(this, signedTx, opts === null || opts === void 0 ? void 0 : opts.failHard);\n      if (response.result.engine_result.startsWith('tem')) {\n        throw new errors_1.XrplError(`Transaction failed, ${response.result.engine_result}: ${response.result.engine_result_message}`);\n      }\n      const txHash = utils_1.hashes.hashSignedTx(signedTx);\n      return (0, sugar_1.waitForFinalTransactionOutcome)(this, txHash, lastLedger, response.result.engine_result);\n    });\n  }\n  prepareTransaction(transaction, signersCount) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.autofill(transaction, signersCount);\n    });\n  }\n  getXrpBalance(address, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const xrpRequest = {\n        command: 'account_info',\n        account: address,\n        ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',\n        ledger_hash: options.ledger_hash\n      };\n      const response = yield this.request(xrpRequest);\n      return (0, utils_1.dropsToXrp)(response.result.account_data.Balance);\n    });\n  }\n  getBalances(address, options = {}) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const balances = [];\n      let xrpPromise = Promise.resolve(0);\n      if (!options.peer) {\n        xrpPromise = this.getXrpBalance(address, {\n          ledger_hash: options.ledger_hash,\n          ledger_index: options.ledger_index\n        });\n      }\n      const linesRequest = {\n        command: 'account_lines',\n        account: address,\n        ledger_index: (_a = options.ledger_index) !== null && _a !== void 0 ? _a : 'validated',\n        ledger_hash: options.ledger_hash,\n        peer: options.peer,\n        limit: options.limit\n      };\n      const linesPromise = this.requestAll(linesRequest);\n      yield Promise.all([xrpPromise, linesPromise]).then(([xrpBalance, linesResponses]) => {\n        const accountLinesBalance = linesResponses.flatMap(response => (0, balances_1.formatBalances)(response.result.lines));\n        if (xrpBalance !== 0) {\n          balances.push({\n            currency: 'XRP',\n            value: xrpBalance.toString()\n          });\n        }\n        balances.push(...accountLinesBalance);\n      });\n      return balances.slice(0, options.limit);\n    });\n  }\n  getOrderbook(currency1, currency2, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      (0, getOrderbook_1.validateOrderbookOptions)(options);\n      const request = (0, getOrderbook_1.createBookOffersRequest)(currency1, currency2, options);\n      const directOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, request);\n      const reverseOfferResults = yield (0, getOrderbook_1.requestAllOffers)(this, (0, getOrderbook_1.reverseRequest)(request));\n      const directOffers = (0, getOrderbook_1.extractOffers)(directOfferResults);\n      const reverseOffers = (0, getOrderbook_1.extractOffers)(reverseOfferResults);\n      const orders = (0, getOrderbook_1.combineOrders)(directOffers, reverseOffers);\n      const {\n        buy,\n        sell\n      } = (0, getOrderbook_1.separateBuySellOrders)(orders);\n      return {\n        buy: (0, getOrderbook_1.sortAndLimitOffers)(buy, options.limit),\n        sell: (0, getOrderbook_1.sortAndLimitOffers)(sell, options.limit)\n      };\n    });\n  }\n  getLedgerIndex() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ledgerResponse = yield this.request({\n        command: 'ledger',\n        ledger_index: 'validated'\n      });\n      return ledgerResponse.result.ledger_index;\n    });\n  }\n  fundWallet(wallet, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isConnected()) {\n        throw new errors_1.RippledError('Client not connected, cannot call faucet');\n      }\n      const existingWallet = Boolean(wallet);\n      const walletToFund = wallet && (0, utils_1.isValidClassicAddress)(wallet.classicAddress) ? wallet : Wallet_1.Wallet.generate();\n      const postBody = {\n        destination: walletToFund.classicAddress,\n        xrpAmount: options.amount,\n        usageContext: options.usageContext,\n        userAgent: 'xrpl.js'\n      };\n      let startingBalance = 0;\n      if (existingWallet) {\n        try {\n          startingBalance = Number(yield this.getXrpBalance(walletToFund.classicAddress));\n        } catch (_a) {}\n      }\n      return (0, fundWallet_1.requestFunding)(options, this, startingBalance, walletToFund, postBody);\n    });\n  }\n}\nexports.Client = Client;","map":{"version":3,"names":["eventemitter3_1","require","errors_1","common_1","flags_1","sugar_1","autofill_1","balances_1","getOrderbook_1","utils_1","Wallet_1","fundWallet_1","connection_1","partialPayment_1","getCollectKeyFromCommand","command","clamp","value","min","max","Error","Math","DEFAULT_FEE_CUSHION","DEFAULT_MAX_FEE_XRP","MIN_LIMIT","MAX_LIMIT","NORMAL_DISCONNECT_CODE","Client","EventEmitter","constructor","server","options","apiVersion","DEFAULT_API_VERSION","exec","ValidationError","feeCushion","_a","maxFeeXRP","_b","connection","Connection","on","errorCode","errorMessage","data","emit","code","finalCode","INTENTIONAL_DISCONNECT_CODE","ledger","tx","handleStreamPartialPayment","trace","validation","manifest","status","consensus","path","url","getUrl","request","req","Object","assign","account","ensureClassicAddress","undefined","api_version","response","handlePartialPayment","requestNextPage","resp","result","marker","Promise","reject","NotFoundError","nextPageRequest","eventName","listener","requestAll","collect","collectKey","countTo","limit","Infinity","count","results","countRemaining","repeatProps","singleResponse","singleResult","XrplError","collectedData","push","Array","isArray","length","Boolean","getServerInfo","networkID","info","network_id","buildVersion","build_version","error","console","connect","then","__awaiter","disconnect","isConnected","autofill","transaction","signersCount","setValidAddresses","Flags","convertTxFlagsToNumber","promises","NetworkID","txNeedsNetworkID","Sequence","setNextValidSequenceNumber","Fee","getTransactionFee","LastLedgerSequence","setLatestValidatedLedgerSequence","TransactionType","checkAccountDeleteBlockers","autofillBatchTxn","DeliverMax","handleDeliverMax","all","simulate","opts","binary","tx_blob","tx_json","submit","signedTx","getSignedTx","submitRequest","failHard","submitAndWait","lastLedger","getLastLedgerSequence","engine_result","startsWith","engine_result_message","txHash","hashes","hashSignedTx","waitForFinalTransactionOutcome","prepareTransaction","getXrpBalance","address","xrpRequest","ledger_index","ledger_hash","dropsToXrp","account_data","Balance","getBalances","balances","xrpPromise","resolve","peer","linesRequest","linesPromise","xrpBalance","linesResponses","accountLinesBalance","flatMap","formatBalances","lines","currency","toString","slice","getOrderbook","currency1","currency2","validateOrderbookOptions","createBookOffersRequest","directOfferResults","requestAllOffers","reverseOfferResults","reverseRequest","directOffers","extractOffers","reverseOffers","orders","combineOrders","buy","sell","separateBuySellOrders","sortAndLimitOffers","getLedgerIndex","ledgerResponse","fundWallet","wallet","RippledError","existingWallet","walletToFund","isValidClassicAddress","classicAddress","Wallet","generate","postBody","destination","xrpAmount","amount","usageContext","userAgent","startingBalance","Number","requestFunding","exports"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/client/index.ts"],"sourcesContent":["/* eslint-disable jsdoc/require-jsdoc -- Request has many aliases, but they don't need unique docs */\n\n/* eslint-disable max-lines -- Client is a large file w/ lots of imports/exports */\nimport { EventEmitter } from 'eventemitter3'\n\nimport {\n  RippledError,\n  NotFoundError,\n  ValidationError,\n  XrplError,\n} from '../errors'\nimport {\n  APIVersion,\n  LedgerIndex,\n  Balance,\n  DEFAULT_API_VERSION,\n} from '../models/common'\nimport {\n  Request,\n  // account methods\n  AccountChannelsRequest,\n  AccountChannelsResponse,\n  AccountInfoRequest,\n  AccountLinesRequest,\n  AccountLinesResponse,\n  AccountObjectsRequest,\n  AccountObjectsResponse,\n  AccountOffersRequest,\n  AccountOffersResponse,\n  AccountTxRequest,\n  AccountTxResponse,\n  // ledger methods\n  LedgerDataRequest,\n  LedgerDataResponse,\n  TxResponse,\n} from '../models/methods'\nimport type {\n  RequestResponseMap,\n  RequestAllResponseMap,\n  MarkerRequest,\n  MarkerResponse,\n  SubmitResponse,\n  SimulateRequest,\n} from '../models/methods'\nimport type { BookOffer, BookOfferCurrency } from '../models/methods/bookOffers'\nimport {\n  SimulateBinaryResponse,\n  SimulateJsonResponse,\n} from '../models/methods/simulate'\nimport type {\n  EventTypes,\n  OnEventToListenerMap,\n} from '../models/methods/subscribe'\nimport type { SubmittableTransaction } from '../models/transactions'\nimport { convertTxFlagsToNumber } from '../models/utils/flags'\nimport {\n  ensureClassicAddress,\n  submitRequest,\n  getSignedTx,\n  getLastLedgerSequence,\n  waitForFinalTransactionOutcome,\n} from '../sugar'\nimport {\n  setValidAddresses,\n  setNextValidSequenceNumber,\n  setLatestValidatedLedgerSequence,\n  checkAccountDeleteBlockers,\n  txNeedsNetworkID,\n  autofillBatchTxn,\n  handleDeliverMax,\n  getTransactionFee,\n} from '../sugar/autofill'\nimport { formatBalances } from '../sugar/balances'\nimport {\n  validateOrderbookOptions,\n  createBookOffersRequest,\n  requestAllOffers,\n  reverseRequest,\n  extractOffers,\n  combineOrders,\n  separateBuySellOrders,\n  sortAndLimitOffers,\n} from '../sugar/getOrderbook'\nimport { dropsToXrp, hashes, isValidClassicAddress } from '../utils'\nimport { Wallet } from '../Wallet'\nimport {\n  type FaucetRequestBody,\n  FundingOptions,\n  requestFunding,\n} from '../Wallet/fundWallet'\n\nimport {\n  Connection,\n  ConnectionUserOptions,\n  INTENTIONAL_DISCONNECT_CODE,\n} from './connection'\nimport {\n  handlePartialPayment,\n  handleStreamPartialPayment,\n} from './partialPayment'\n\nexport interface ClientOptions extends ConnectionUserOptions {\n  /**\n   * Multiplication factor to multiply estimated fee by to provide a cushion in case the\n   * required fee rises during submission of a transaction. Defaults to 1.2.\n   *\n   * @category Fee\n   */\n  feeCushion?: number\n  /**\n   * Maximum transaction cost to allow, in decimal XRP. Must be a string-encoded\n   * number. Defaults to '2'.\n   *\n   * @category Fee\n   */\n  maxFeeXRP?: string\n  /**\n   * Duration to wait for a request to timeout.\n   */\n  timeout?: number\n}\n\n// Make sure to update both this and `RequestNextPageReturnMap` at the same time\ntype RequestNextPageType =\n  | AccountChannelsRequest\n  | AccountLinesRequest\n  | AccountObjectsRequest\n  | AccountOffersRequest\n  | AccountTxRequest\n  | LedgerDataRequest\n\ntype RequestNextPageReturnMap<T> = T extends AccountChannelsRequest\n  ? AccountChannelsResponse\n  : T extends AccountLinesRequest\n    ? AccountLinesResponse\n    : T extends AccountObjectsRequest\n      ? AccountObjectsResponse\n      : T extends AccountOffersRequest\n        ? AccountOffersResponse\n        : T extends AccountTxRequest\n          ? AccountTxResponse\n          : T extends LedgerDataRequest\n            ? LedgerDataResponse\n            : never\n\n/**\n * Get the response key / property name that contains the listed data for a\n * command. This varies from command to command, but we need to know it to\n * properly count across many requests.\n *\n * @param command - The rippled request command.\n * @returns The property key corresponding to the command.\n */\nfunction getCollectKeyFromCommand(command: string): string | null {\n  switch (command) {\n    case 'account_channels':\n      return 'channels'\n    case 'account_lines':\n      return 'lines'\n    case 'account_objects':\n      return 'account_objects'\n    case 'account_tx':\n      return 'transactions'\n    case 'account_offers':\n    case 'book_offers':\n      return 'offers'\n    case 'ledger_data':\n      return 'state'\n    default:\n      return null\n  }\n}\n\nfunction clamp(value: number, min: number, max: number): number {\n  if (min > max) {\n    throw new Error('Illegal clamp bounds')\n  }\n  return Math.min(Math.max(value, min), max)\n}\n\nconst DEFAULT_FEE_CUSHION = 1.2\nconst DEFAULT_MAX_FEE_XRP = '2'\n\nconst MIN_LIMIT = 10\nconst MAX_LIMIT = 400\n\nconst NORMAL_DISCONNECT_CODE = 1000\n\n/**\n * Client for interacting with rippled servers.\n *\n * @category Clients\n */\nclass Client extends EventEmitter<EventTypes> {\n  /*\n   * Underlying connection to rippled.\n   */\n  public readonly connection: Connection\n\n  /**\n   * Factor to multiply estimated fee by to provide a cushion in case the\n   * required fee rises during submission of a transaction. Defaults to 1.2.\n   *\n   * @category Fee\n   */\n  public readonly feeCushion: number\n\n  /**\n   * Maximum transaction cost to allow, in decimal XRP. Must be a string-encoded\n   * number. Defaults to '2'.\n   *\n   * @category Fee\n   */\n  public readonly maxFeeXRP: string\n\n  /**\n   * Network ID of the server this client is connected to\n   *\n   */\n  public networkID: number | undefined\n\n  /**\n   * Rippled Version used by the server this client is connected to\n   *\n   */\n  public buildVersion: string | undefined\n\n  /**\n   * API Version used by the server this client is connected to\n   *\n   */\n  public apiVersion: APIVersion = DEFAULT_API_VERSION\n\n  /**\n   * Creates a new Client with a websocket connection to a rippled server.\n   *\n   * @param server - URL of the server to connect to.\n   * @param options - Options for client settings.\n   * @category Constructor\n   *\n   * @example\n   * ```ts\n   * import { Client } from \"xrpl\"\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * ```\n   */\n  /* eslint-disable max-lines-per-function -- the constructor requires more lines to implement the logic */\n  public constructor(server: string, options: ClientOptions = {}) {\n    super()\n    if (typeof server !== 'string' || !/wss?(?:\\+unix)?:\\/\\//u.exec(server)) {\n      throw new ValidationError(\n        'server URI must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.',\n      )\n    }\n\n    this.feeCushion = options.feeCushion ?? DEFAULT_FEE_CUSHION\n    this.maxFeeXRP = options.maxFeeXRP ?? DEFAULT_MAX_FEE_XRP\n\n    this.connection = new Connection(server, options)\n\n    this.connection.on('error', (errorCode, errorMessage, data) => {\n      this.emit('error', errorCode, errorMessage, data)\n    })\n\n    this.connection.on('reconnect', () => {\n      this.connection.on('connected', () => this.emit('connected'))\n    })\n\n    this.connection.on('disconnected', (code: number) => {\n      let finalCode = code\n      /*\n       * 4000: Connection uses a 4000 code internally to indicate a manual disconnect/close\n       * Since 4000 is a normal disconnect reason, we convert this to the standard exit code 1000\n       */\n      if (finalCode === INTENTIONAL_DISCONNECT_CODE) {\n        finalCode = NORMAL_DISCONNECT_CODE\n      }\n      this.emit('disconnected', finalCode)\n    })\n\n    this.connection.on('ledgerClosed', (ledger) => {\n      this.emit('ledgerClosed', ledger)\n    })\n\n    this.connection.on('transaction', (tx) => {\n      // mutates `tx` to add warnings\n      handleStreamPartialPayment(tx, this.connection.trace)\n      this.emit('transaction', tx)\n    })\n\n    this.connection.on('validationReceived', (validation) => {\n      this.emit('validationReceived', validation)\n    })\n\n    this.connection.on('manifestReceived', (manifest) => {\n      this.emit('manifestReceived', manifest)\n    })\n\n    this.connection.on('peerStatusChange', (status) => {\n      this.emit('peerStatusChange', status)\n    })\n\n    this.connection.on('consensusPhase', (consensus) => {\n      this.emit('consensusPhase', consensus)\n    })\n\n    this.connection.on('path_find', (path) => {\n      this.emit('path_find', path)\n    })\n  }\n  /* eslint-enable max-lines-per-function */\n\n  /**\n   * Get the url that the client is connected to.\n   *\n   * @returns The URL of the server this client is connected to.\n   * @category Network\n   */\n  public get url(): string {\n    return this.connection.getUrl()\n  }\n\n  /**\n   * Makes a request to the client with the given command and\n   * additional request body parameters.\n   *\n   * @category Network\n   * @param req - Request to send to the server.\n   * @returns The response from the server.\n   *\n   * @example\n   * ```ts\n   * const response = await client.request({\n   *   command: 'account_info',\n   *   account: 'r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59',\n   * })\n   * console.log(response)\n   * ```\n   */\n  public async request<\n    R extends Request,\n    V extends APIVersion = typeof DEFAULT_API_VERSION,\n    T = RequestResponseMap<R, V>,\n  >(req: R): Promise<T> {\n    const request = {\n      ...req,\n      account:\n        typeof req.account === 'string'\n          ? ensureClassicAddress(req.account)\n          : undefined,\n      api_version: req.api_version ?? this.apiVersion,\n    }\n    const response = await this.connection.request<R, T>(request)\n\n    // mutates `response` to add warnings\n    handlePartialPayment(req.command, response)\n\n    return response\n  }\n\n  /**\n   * Requests the next page of data.\n   *\n   * @category Network\n   *\n   * @param req - Request to send.\n   * @param resp - Response with the marker to use in the request.\n   * @returns The response with the next page of data.\n   *\n   * @example\n   * ```ts\n   * const response = await client.request({\n   *  command: 'account_tx',\n   *  account: 'r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59',\n   * })\n   * console.log(response)\n   * const nextResponse = await client.requestNextPage({\n   *   command: 'account_tx',\n   *   account: 'r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59',\n   * },\n   * response)\n   * console.log(nextResponse)\n   * ```\n   */\n  public async requestNextPage<\n    T extends RequestNextPageType,\n    U extends RequestNextPageReturnMap<T>,\n  >(req: T, resp: U): Promise<RequestNextPageReturnMap<T>> {\n    if (!resp.result.marker) {\n      return Promise.reject(\n        new NotFoundError('response does not have a next page'),\n      )\n    }\n    const nextPageRequest = { ...req, marker: resp.result.marker }\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Necessary for overloading\n    return this.request(nextPageRequest) as unknown as U\n  }\n\n  /**\n   * Event handler for subscription streams.\n   *\n   * @category Network\n   *\n   * @param eventName - Name of the event. Only forwards streams.\n   * @param listener - Function to run on event.\n   * @returns This, because it inherits from EventEmitter.\n   *\n   * * @example\n   * ```ts\n   * const api = new Client('wss://s.altnet.rippletest.net:51233')\n   *\n   * api.on('transaction', (tx: TransactionStream) => {\n   *  console.log(\"Received Transaction\")\n   *  console.log(tx)\n   * })\n   *\n   * await api.connect()\n   * const response = await api.request({\n   *     command: 'subscribe',\n   *     streams: ['transactions_proposed']\n   * })\n   * ```\n   */\n  public on<\n    T extends EventTypes,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- needs to be any for overload\n    U extends (...args: any[]) => void = OnEventToListenerMap<T>,\n  >(eventName: T, listener: U): this {\n    return super.on(eventName, listener)\n  }\n\n  /**\n   * Makes multiple paged requests to the client to return a given number of\n   * resources. Multiple paged requests will be made until the `limit`\n   * number of resources is reached (if no `limit` is provided, a single request\n   * will be made).\n   *\n   * If the command is unknown, an additional `collect` property is required to\n   * know which response key contains the array of resources.\n   *\n   * NOTE: This command is used by existing methods and is not recommended for\n   * general use. Instead, use rippled's built-in pagination and make multiple\n   * requests as needed.\n   *\n   * @category Network\n   *\n   * @param request - The initial request to send to the server.\n   * @param collect - (Optional) the param to use to collect the array of resources (only needed if command is unknown).\n   * @returns The array of all responses.\n   * @throws ValidationError if there is no collection key (either from a known command or for the unknown command).\n   *\n   * @example\n   * // Request all ledger data pages\n   * const allResponses = await client.requestAll({ command: 'ledger_data' });\n   * console.log(allResponses);\n   *\n   * @example\n   * // Request all transaction data pages\n   * const allResponses = await client.requestAll({ command: 'transaction_data' });\n   * console.log(allResponses);\n   */\n\n  public async requestAll<\n    T extends MarkerRequest,\n    U = RequestAllResponseMap<T, APIVersion>,\n  >(request: T, collect?: string): Promise<U[]> {\n    /*\n     * The data under collection is keyed based on the command. Fail if command\n     * not recognized and collection key not provided.\n     */\n    const collectKey = collect ?? getCollectKeyFromCommand(request.command)\n    if (!collectKey) {\n      throw new ValidationError(`no collect key for command ${request.command}`)\n    }\n    /*\n     * If limit is not provided, fetches all data over multiple requests.\n     * NOTE: This may return much more than needed. Set limit when possible.\n     */\n    const countTo: number = request.limit ?? Infinity\n    let count = 0\n    let marker: unknown = request.marker\n    const results: U[] = []\n    do {\n      const countRemaining = clamp(countTo - count, MIN_LIMIT, MAX_LIMIT)\n      const repeatProps = {\n        ...request,\n        limit: countRemaining,\n        marker,\n      }\n      // eslint-disable-next-line no-await-in-loop -- Necessary for this, it really has to wait\n      const singleResponse = await this.connection.request(repeatProps)\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Should be true\n      const singleResult = (singleResponse as MarkerResponse<APIVersion>).result\n      if (!(collectKey in singleResult)) {\n        throw new XrplError(`${collectKey} not in result`)\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- Should be true\n      const collectedData = singleResult[collectKey]\n      marker = singleResult.marker\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Should be true\n      results.push(singleResponse as U)\n      // Make sure we handle when no data (not even an empty array) is returned.\n      if (Array.isArray(collectedData)) {\n        count += collectedData.length\n      }\n    } while (Boolean(marker) && count < countTo)\n    return results\n  }\n\n  /**\n   * Get networkID and buildVersion from server_info\n   *\n   * @returns void\n   * @example\n   * ```ts\n   * const { Client } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.getServerInfo()\n   * console.log(client.networkID)\n   * console.log(client.buildVersion)\n   * ```\n   */\n  public async getServerInfo(): Promise<void> {\n    try {\n      const response = await this.request({\n        command: 'server_info',\n      })\n      this.networkID = response.result.info.network_id ?? undefined\n      this.buildVersion = response.result.info.build_version\n    } catch (error) {\n      // eslint-disable-next-line no-console -- Print the error to console but allows client to be connected.\n      console.error(error)\n    }\n  }\n\n  /**\n   * Tells the Client instance to connect to its rippled server.\n   *\n   * @example\n   *\n   * Client.connect() establishes a connection between a Client object and the server.\n   *\n   * ```ts\n   * const { Client } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.connect()\n   * // do something with the client\n   * await client.disconnect()\n   * ```\n   * If you open a client connection, be sure to close it with `await client.disconnect()`\n   * before exiting your application.\n   * @returns A promise that resolves with a void value when a connection is established.\n   * @category Network\n   *\n   * @example\n   * ```ts\n   * const { Client } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.connect()\n   * // do something with the client\n   * await client.disconnect()\n   * ```\n   */\n  public async connect(): Promise<void> {\n    return this.connection.connect().then(async () => {\n      await this.getServerInfo()\n      this.emit('connected')\n    })\n  }\n\n  /**\n   * Disconnects the XRPL client from the server and cancels all pending requests and subscriptions. Call when\n   * you want to disconnect the client from the server, such as when you're finished using the client or when you\n   * need to switch to a different server.\n   *\n   * @example\n   *\n   * To use the disconnect() method, you first need to create a new Client object and connect it to a server:\n   *\n   * ```ts\n   * const { Client } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.connect()\n   * // do something with the client\n   * await client.disconnect()\n   * ```\n   *\n   * @returns A promise that resolves with a void value when a connection is destroyed.\n   * @category Network\n   */\n  public async disconnect(): Promise<void> {\n    /*\n     * backwards compatibility: connection.disconnect() can return a number, but\n     * this method returns nothing. SO we await but don't return any result.\n     */\n    await this.connection.disconnect()\n  }\n\n  /**\n   * Checks if the Client instance is connected to its rippled server.\n   *\n   * @returns Whether the client instance is connected.\n   * @category Network\n   * @example\n   * ```ts\n   * const { Client } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.connect()\n   * console.log(client.isConnected())\n   * // true\n   * await client.disconnect()\n   * console.log(client.isConnected())\n   * // false\n   * ```\n   */\n  public isConnected(): boolean {\n    return this.connection.isConnected()\n  }\n\n  /**\n   * Autofills fields in a transaction. This will set `Sequence`, `Fee`,\n   * `lastLedgerSequence` according to the current state of the server this Client\n   * is connected to. It also converts all X-Addresses to classic addresses and\n   * flags interfaces into numbers.\n   *\n   * @category Core\n   *\n   * @example\n   *\n   * ```ts\n   * const { Client } = require('xrpl')\n   *\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   *\n   * async function createAndAutofillTransaction() {\n   *   const transaction = {\n   *     TransactionType: 'Payment',\n   *     Account: 'rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh',\n   *     Destination: 'r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59',\n   *     Amount: '10000000' // 10 XRP in drops (1/1,000,000th of an XRP)\n   *   }\n   *\n   *   try {\n   *     const autofilledTransaction = await client.autofill(transaction)\n   *     console.log(autofilledTransaction)\n   *   } catch (error) {\n   *     console.error(`Failed to autofill transaction: ${error}`)\n   *   }\n   * }\n   *\n   * createAndAutofillTransaction()\n   * ```\n   *\n   * Autofill helps fill in fields which should be included in a transaction, but can be determined automatically\n   * such as `LastLedgerSequence` and `Fee`. If you override one of the fields `autofill` changes, your explicit\n   * values will be used instead. By default, this is done as part of `submit` and `submitAndWait` when you pass\n   * in an unsigned transaction along with your wallet to be submitted.\n   *\n   * @template T\n   * @param transaction - A {@link SubmittableTransaction} in JSON format\n   * @param signersCount - The expected number of signers for this transaction.\n   * Only used for multisigned transactions.\n   * @returns The autofilled transaction.\n   * @throws ValidationError If Amount and DeliverMax fields are not identical in a Payment Transaction\n   */\n  public async autofill<T extends SubmittableTransaction>(\n    transaction: T,\n    signersCount?: number,\n  ): Promise<T> {\n    const tx = { ...transaction }\n\n    setValidAddresses(tx)\n    tx.Flags = convertTxFlagsToNumber(tx)\n\n    const promises: Array<Promise<void>> = []\n    tx.NetworkID ??= txNeedsNetworkID(this) ? this.networkID : undefined\n    if (tx.Sequence == null) {\n      promises.push(setNextValidSequenceNumber(this, tx))\n    }\n    if (tx.Fee == null) {\n      promises.push(getTransactionFee(this, tx, signersCount))\n    }\n    if (tx.LastLedgerSequence == null) {\n      promises.push(setLatestValidatedLedgerSequence(this, tx))\n    }\n    if (tx.TransactionType === 'AccountDelete') {\n      promises.push(checkAccountDeleteBlockers(this, tx))\n    }\n    if (tx.TransactionType === 'Batch') {\n      promises.push(autofillBatchTxn(this, tx))\n    }\n    if (tx.TransactionType === 'Payment' && tx.DeliverMax != null) {\n      handleDeliverMax(tx)\n    }\n\n    return Promise.all(promises).then(() => tx)\n  }\n\n  /**\n   * Simulates an unsigned transaction.\n   * Steps performed on a transaction:\n   *    1. Autofill.\n   *    2. Sign & Encode.\n   *    3. Submit.\n   *\n   * @category Core\n   *\n   * @param transaction - A transaction to autofill, sign & encode, and submit.\n   * @param opts - (Optional) Options used to sign and submit a transaction.\n   * @param opts.binary - If true, return the metadata in a binary encoding.\n   *\n   * @returns A promise that contains SimulateResponse.\n   * @throws RippledError if the simulate request fails.\n   */\n\n  public async simulate<Binary extends boolean = false>(\n    transaction: SubmittableTransaction | string,\n    opts?: {\n      // If true, return the binary-encoded representation of the results.\n      binary?: Binary\n    },\n  ): Promise<\n    Binary extends true ? SimulateBinaryResponse : SimulateJsonResponse\n  > {\n    // send request\n    const binary = opts?.binary ?? false\n    const request: SimulateRequest =\n      typeof transaction === 'string'\n        ? { command: 'simulate', tx_blob: transaction, binary }\n        : { command: 'simulate', tx_json: transaction, binary }\n    return this.request(request)\n  }\n\n  /**\n   * Submits a signed/unsigned transaction.\n   * Steps performed on a transaction:\n   *    1. Autofill.\n   *    2. Sign & Encode.\n   *    3. Submit.\n   *\n   * @category Core\n   *\n   * @param transaction - A transaction to autofill, sign & encode, and submit.\n   * @param opts - (Optional) Options used to sign and submit a transaction.\n   * @param opts.autofill - If true, autofill a transaction.\n   * @param opts.failHard - If true, and the transaction fails locally, do not retry or relay the transaction to other servers.\n   * @param opts.wallet - A wallet to sign a transaction. It must be provided when submitting an unsigned transaction.\n   *\n   * @returns A promise that contains SubmitResponse.\n   * @throws RippledError if submit request fails.\n   *\n   * @example\n   * ```ts\n   * const { Client, Wallet } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.connect()\n   * const wallet = Wallet.generate()\n   * const transaction = {\n   *   TransactionType: 'Payment',\n   *   Account: wallet.classicAddress,\n   *   Destination: 'r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59',\n   *   Amount: '10000000' // 10 XRP in drops (1/1,000,000th of an XRP)\n   * }\n   * const submitResponse = await client.submit(transaction, { wallet })\n   * console.log(submitResponse)\n   * ```\n   */\n  public async submit(\n    transaction: SubmittableTransaction | string,\n    opts?: {\n      // If true, autofill a transaction.\n      autofill?: boolean\n      // If true, and the transaction fails locally, do not retry or relay the transaction to other servers.\n      failHard?: boolean\n      // A wallet to sign a transaction. It must be provided when submitting an unsigned transaction.\n      wallet?: Wallet\n    },\n  ): Promise<SubmitResponse> {\n    const signedTx = await getSignedTx(this, transaction, opts)\n    return submitRequest(this, signedTx, opts?.failHard)\n  }\n\n  /**\n   * Asynchronously submits a transaction and verifies that it has been included in a\n   * validated ledger (or has errored/will not be included for some reason).\n   * See [Reliable Transaction Submission](https://xrpl.org/reliable-transaction-submission.html).\n   *\n   * @category Core\n   *\n   * @example\n   *\n   * ```ts\n   * const { Client, Wallet } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   *\n   * async function submitTransaction() {\n   *   const senderWallet = client.fundWallet()\n   *   const recipientWallet = client.fundWallet()\n   *\n   *   const transaction = {\n   *     TransactionType: 'Payment',\n   *     Account: senderWallet.address,\n   *     Destination: recipientWallet.address,\n   *     Amount: '10'\n   *   }\n   *\n   *   try {\n   *     await client.submit(signedTransaction, { wallet: senderWallet })\n   *     console.log(result)\n   *   } catch (error) {\n   *     console.error(`Failed to submit transaction: ${error}`)\n   *   }\n   * }\n   *\n   * submitTransaction()\n   * ```\n   *\n   * In this example we submit a payment transaction between two newly created testnet accounts.\n   *\n   * Under the hood, `submit` will call `client.autofill` by default, and because we've passed in a `Wallet` it\n   * Will also sign the transaction for us before submitting the signed transaction binary blob to the ledger.\n   *\n   * This is similar to `submit`, which does all of the above, but also waits to see if the transaction has been validated.\n   * @param transaction - A transaction to autofill, sign & encode, and submit.\n   * @param opts - (Optional) Options used to sign and submit a transaction.\n   * @param opts.autofill - If true, autofill a transaction.\n   * @param opts.failHard - If true, and the transaction fails locally, do not retry or relay the transaction to other servers.\n   * @param opts.wallet - A wallet to sign a transaction. It must be provided when submitting an unsigned transaction.\n   * @throws Connection errors: If the `Client` object is unable to establish a connection to the specified WebSocket endpoint,\n   * an error will be thrown.\n   * @throws Transaction errors: If the submitted transaction is invalid or cannot be included in a validated ledger for any\n   * reason, the promise returned by `submitAndWait()` will be rejected with an error. This could include issues with insufficient\n   * balance, invalid transaction fields, or other issues specific to the transaction being submitted.\n   * @throws Ledger errors: If the ledger being used to submit the transaction is undergoing maintenance or otherwise unavailable,\n   * an error will be thrown.\n   * @throws Timeout errors: If the transaction takes longer than the specified timeout period to be included in a validated\n   * ledger, the promise returned by `submitAndWait()` will be rejected with an error.\n   * @returns A promise that contains TxResponse, that will return when the transaction has been validated.\n   */\n  public async submitAndWait<\n    T extends SubmittableTransaction = SubmittableTransaction,\n  >(\n    transaction: T | string,\n    opts?: {\n      // If true, autofill a transaction.\n      autofill?: boolean\n      // If true, and the transaction fails locally, do not retry or relay the transaction to other servers.\n      failHard?: boolean\n      // A wallet to sign a transaction. It must be provided when submitting an unsigned transaction.\n      wallet?: Wallet\n    },\n  ): Promise<TxResponse<T>> {\n    const signedTx = await getSignedTx(this, transaction, opts)\n\n    const lastLedger = getLastLedgerSequence(signedTx)\n    if (lastLedger == null) {\n      throw new ValidationError(\n        'Transaction must contain a LastLedgerSequence value for reliable submission.',\n      )\n    }\n\n    const response = await submitRequest(this, signedTx, opts?.failHard)\n\n    if (response.result.engine_result.startsWith('tem')) {\n      throw new XrplError(\n        `Transaction failed, ${response.result.engine_result}: ${response.result.engine_result_message}`,\n      )\n    }\n\n    const txHash = hashes.hashSignedTx(signedTx)\n    return waitForFinalTransactionOutcome(\n      this,\n      txHash,\n      lastLedger,\n      response.result.engine_result,\n    )\n  }\n\n  /**\n   * Deprecated: Use autofill instead, provided for users familiar with v1\n   *\n   * @param transaction - A {@link Transaction} in JSON format\n   * @param signersCount - The expected number of signers for this transaction.\n   * Only used for multisigned transactions.\n   * @returns The prepared transaction with required fields autofilled.\n   * @deprecated Use autofill instead, provided for users familiar with v1\n   */\n  public async prepareTransaction(\n    transaction: SubmittableTransaction,\n    signersCount?: number,\n  ): ReturnType<Client['autofill']> {\n    return this.autofill(transaction, signersCount)\n  }\n\n  /**\n   * Retrieves the XRP balance of a given account address.\n   *\n   * @category Abstraction\n   *\n   * @example\n   * ```ts\n   * const client = new Client(wss://s.altnet.rippletest.net:51233)\n   * await client.connect()\n   * const balance = await client.getXrpBalance('rG1QQv2nh2gr7RCZ1P8YYcBUKCCN633jCn')\n   * console.log(balance)\n   * await client.disconnect()\n   * /// '200'\n   * ```\n   *\n   * @param address - The XRP address to retrieve the balance for.\n   * @param [options] - Additional options for fetching the balance (optional).\n   * @param [options.ledger_hash] - The hash of the ledger to retrieve the balance from (optional).\n   * @param [options.ledger_index] - The index of the ledger to retrieve the balance from (optional).\n   * @returns A promise that resolves with the XRP balance as a number.\n   */\n  public async getXrpBalance(\n    address: string,\n    options: {\n      ledger_hash?: string\n      ledger_index?: LedgerIndex\n    } = {},\n  ): Promise<number> {\n    const xrpRequest: AccountInfoRequest = {\n      command: 'account_info',\n      account: address,\n      ledger_index: options.ledger_index ?? 'validated',\n      ledger_hash: options.ledger_hash,\n    }\n    const response = await this.request(xrpRequest)\n    return dropsToXrp(response.result.account_data.Balance)\n  }\n\n  /**\n   * Get XRP/non-XRP balances for an account.\n   *\n   * @category Abstraction\n   *\n   * @example\n   * ```ts\n   * const { Client } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.connect()\n   *\n   * async function getAccountBalances(address) {\n   *   try {\n   *     const options = {\n   *       ledger_index: 'validated',\n   *       limit: 10\n   *     };\n   *\n   *     const balances = await xrplClient.getBalances(address, options);\n   *\n   *     console.log('Account Balances:');\n   *     balances.forEach((balance) => {\n   *       console.log(`Currency: ${balance.currency}`);\n   *       console.log(`Value: ${balance.value}`);\n   *       console.log(`Issuer: ${balance.issuer}`);\n   *       console.log('---');\n   *     });\n   *   } catch (error) {\n   *     console.error('Error retrieving account balances:', error);\n   *   }\n   * }\n   *\n   * const address = 'rHb9CJAWyB4rj91VRWn96DkukG4bwdtyTh';\n   * await getAccountBalances(address);\n   * await client.disconnect();\n   * ```\n   *\n   * @param address - Address of the account to retrieve balances for.\n   * @param options - Allows the client to specify a ledger_hash, ledger_index,\n   * filter by peer, and/or limit number of balances.\n   * @param options.ledger_index - Retrieve the account balances at a given\n   * ledger_index.\n   * @param options.ledger_hash - Retrieve the account balances at the ledger with\n   * a given ledger_hash.\n   * @param options.peer - Filter balances by peer.\n   * @param options.limit - Limit number of balances to return.\n   * @returns An array of XRP/non-XRP balances for the given account.\n   */\n  /* eslint-disable max-lines-per-function -- getBalances requires more lines to implement logic */\n  public async getBalances(\n    address: string,\n    options: {\n      ledger_hash?: string\n      ledger_index?: LedgerIndex\n      peer?: string\n      limit?: number\n    } = {},\n  ): Promise<\n    Array<{ value: string; currency: string; issuer?: string | undefined }>\n  > {\n    const balances: Balance[] = []\n\n    // get XRP balance\n    let xrpPromise: Promise<number> = Promise.resolve(0)\n    if (!options.peer) {\n      xrpPromise = this.getXrpBalance(address, {\n        ledger_hash: options.ledger_hash,\n        ledger_index: options.ledger_index,\n      })\n    }\n\n    // get non-XRP balances\n    const linesRequest: AccountLinesRequest = {\n      command: 'account_lines',\n      account: address,\n      ledger_index: options.ledger_index ?? 'validated',\n      ledger_hash: options.ledger_hash,\n      peer: options.peer,\n      limit: options.limit,\n    }\n    const linesPromise = this.requestAll(linesRequest)\n\n    // combine results\n    await Promise.all([xrpPromise, linesPromise]).then(\n      ([xrpBalance, linesResponses]) => {\n        const accountLinesBalance = linesResponses.flatMap((response) =>\n          formatBalances(response.result.lines),\n        )\n        if (xrpBalance !== 0) {\n          balances.push({ currency: 'XRP', value: xrpBalance.toString() })\n        }\n        balances.push(...accountLinesBalance)\n      },\n    )\n    return balances.slice(0, options.limit)\n  }\n  /* eslint-enable max-lines-per-function */\n\n  /**\n   * Fetch orderbook (buy/sell orders) between two currency pairs. This checks both sides of the orderbook\n   * by making two `order_book` requests (with the second reversing takerPays and takerGets). Returned offers are\n   * not normalized in this function, so either currency could be takerGets or takerPays.\n   *\n   * @category Abstraction\n   *\n   * @param currency1 - Specification of one currency involved. (With a currency code and optionally an issuer)\n   * @param currency2 - Specification of a second currency involved. (With a currency code and optionally an issuer)\n   * @param options - Options allowing the client to specify ledger_index,\n   * ledger_hash, filter by taker, and/or limit number of orders.\n   * @param options.ledger_index - Retrieve the orderbook at a given ledger_index.\n   * @param options.ledger_hash - Retrieve the orderbook at the ledger with a\n   * given ledger_hash.\n   * @param options.taker - Filter orders by taker.\n   * @param options.limit - The limit passed into each book_offers request.\n   * Can return more than this due to two calls being made. Defaults to 20.\n   * @returns An object containing buy and sell objects.\n   */\n\n  public async getOrderbook(\n    currency1: BookOfferCurrency,\n    currency2: BookOfferCurrency,\n    options: {\n      limit?: number\n      ledger_index?: LedgerIndex\n      ledger_hash?: string | null\n      taker?: string | null\n    } = {},\n  ): Promise<{\n    buy: BookOffer[]\n    sell: BookOffer[]\n  }> {\n    validateOrderbookOptions(options)\n\n    const request = createBookOffersRequest(currency1, currency2, options)\n\n    const directOfferResults = await requestAllOffers(this, request)\n    const reverseOfferResults = await requestAllOffers(\n      this,\n      reverseRequest(request),\n    )\n\n    const directOffers = extractOffers(directOfferResults)\n    const reverseOffers = extractOffers(reverseOfferResults)\n\n    const orders = combineOrders(directOffers, reverseOffers)\n\n    const { buy, sell } = separateBuySellOrders(orders)\n\n    /*\n     * Sort the orders\n     * for both buys and sells, lowest quality is closest to mid-market\n     * we sort the orders so that earlier orders are closer to mid-market\n     */\n    return {\n      buy: sortAndLimitOffers(buy, options.limit),\n      sell: sortAndLimitOffers(sell, options.limit),\n    }\n  }\n\n  /**\n   * Returns the index of the most recently validated ledger.\n   *\n   * @category Abstraction\n   *\n   * @returns The most recently validated ledger index.\n   *\n   * @example\n   * ```ts\n   * const { Client } = require('xrpl')\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.connect()\n   * const ledgerIndex = await client.getLedgerIndex()\n   * console.log(ledgerIndex)\n   * // 884039\n   * ```\n   */\n  public async getLedgerIndex(): Promise<number> {\n    const ledgerResponse = await this.request({\n      command: 'ledger',\n      ledger_index: 'validated',\n    })\n    return ledgerResponse.result.ledger_index\n  }\n\n  /**\n   * The fundWallet() method is used to send an amount of XRP (usually 1000) to a new (randomly generated)\n   * or existing XRP Ledger wallet.\n   *\n   * @category Faucet\n   *\n   * @example\n   *\n   * Example 1: Fund a randomly generated wallet\n   * const { Client, Wallet } = require('xrpl')\n   *\n   * const client = new Client('wss://s.altnet.rippletest.net:51233')\n   * await client.connect()\n   * const { balance, wallet } = await client.fundWallet()\n   *\n   * Under the hood, this will use `Wallet.generate()` to create a new random wallet, then ask a testnet faucet\n   * To send it XRP on ledger to make it a real account. If successful, this will return the new account balance in XRP\n   * Along with the Wallet object to track the keys for that account. If you'd like, you can also re-fill an existing\n   * Account by passing in a Wallet you already have.\n   * ```ts\n   * const api = new xrpl.Client(\"wss://s.altnet.rippletest.net:51233\")\n   * await api.connect()\n   * const { wallet, balance } = await api.fundWallet()\n   * ```\n   *\n   * Example 2: Fund wallet using a custom faucet host and known wallet address\n   *\n   * `fundWallet` will try to infer the url of a faucet API from the network your client is connected to.\n   * There are hardcoded default faucets for popular test networks like testnet and devnet.\n   * However, if you're working with a newer or more obscure network, you may have to specify the faucetHost\n   * And faucetPath so `fundWallet` can ask that faucet to fund your wallet.\n   *\n   * ```ts\n   * const newWallet = Wallet.generate()\n   * const { balance, wallet  } = await client.fundWallet(newWallet, {\n   *       amount: '10',\n   *       faucetHost: 'https://custom-faucet.example.com',\n   *       faucetPath: '/accounts'\n   *     })\n   *     console.log(`Sent 10 XRP to wallet: ${address} from the given faucet. Resulting balance: ${balance} XRP`)\n   *   } catch (error) {\n   *     console.error(`Failed to fund wallet: ${error}`)\n   *   }\n   * }\n   * ```\n   *\n   * @param wallet - An existing XRPL Wallet to fund. If undefined or null, a new Wallet will be created.\n   * @param options - See below.\n   * @param options.faucetHost - A custom host for a faucet server. On devnet,\n   * testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n   * attempt to determine the correct server automatically. In other environments,\n   * or if you would like to customize the faucet host in devnet or testnet,\n   * you should provide the host using this option.\n   * @param options.faucetPath - A custom path for a faucet server. On devnet,\n   * testnet, AMM devnet, and HooksV3 testnet, `fundWallet` will\n   * attempt to determine the correct path automatically. In other environments,\n   * or if you would like to customize the faucet path in devnet or testnet,\n   * you should provide the path using this option.\n   * Ex: client.fundWallet(null,{'faucet.altnet.rippletest.net', '/accounts'})\n   * specifies a request to 'faucet.altnet.rippletest.net/accounts' to fund a new wallet.\n   * @param options.amount - A custom amount to fund, if undefined or null, the default amount will be 1000.\n   * @returns A Wallet on the Testnet or Devnet that contains some amount of XRP,\n   * and that wallet's balance in XRP.\n   * @throws When either Client isn't connected or unable to fund wallet address.\n   */\n  public async fundWallet(\n    this: Client,\n    wallet?: Wallet | null,\n    options: FundingOptions = {},\n  ): Promise<{\n    wallet: Wallet\n    balance: number\n  }> {\n    if (!this.isConnected()) {\n      throw new RippledError('Client not connected, cannot call faucet')\n    }\n    const existingWallet = Boolean(wallet)\n\n    // Generate a new Wallet if no existing Wallet is provided or its address is invalid to fund\n    const walletToFund =\n      wallet && isValidClassicAddress(wallet.classicAddress)\n        ? wallet\n        : Wallet.generate()\n\n    // Create the POST request body\n    const postBody: FaucetRequestBody = {\n      destination: walletToFund.classicAddress,\n      xrpAmount: options.amount,\n      usageContext: options.usageContext,\n      userAgent: 'xrpl.js',\n    }\n\n    let startingBalance = 0\n    if (existingWallet) {\n      try {\n        startingBalance = Number(\n          await this.getXrpBalance(walletToFund.classicAddress),\n        )\n      } catch {\n        /* startingBalance remains what it was previously */\n      }\n    }\n\n    return requestFunding(\n      options,\n      this,\n      startingBalance,\n      walletToFund,\n      postBody,\n    )\n  }\n}\n\nexport { Client }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}