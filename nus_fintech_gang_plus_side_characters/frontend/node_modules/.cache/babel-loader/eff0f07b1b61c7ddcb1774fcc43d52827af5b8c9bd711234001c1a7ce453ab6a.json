{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateDepositPreauth = void 0;\nconst errors_1 = require(\"../../errors\");\nconst common_1 = require(\"./common\");\nfunction validateDepositPreauth(tx) {\n  (0, common_1.validateBaseTransaction)(tx);\n  validateSingleAuthorizationFieldProvided(tx);\n  if (tx.Authorize !== undefined) {\n    if (typeof tx.Authorize !== 'string') {\n      throw new errors_1.ValidationError('DepositPreauth: Authorize must be a string');\n    }\n    if (tx.Account === tx.Authorize) {\n      throw new errors_1.ValidationError(\"DepositPreauth: Account can't preauthorize its own address\");\n    }\n  } else if (tx.Unauthorize !== undefined) {\n    if (typeof tx.Unauthorize !== 'string') {\n      throw new errors_1.ValidationError('DepositPreauth: Unauthorize must be a string');\n    }\n    if (tx.Account === tx.Unauthorize) {\n      throw new errors_1.ValidationError(\"DepositPreauth: Account can't unauthorize its own address\");\n    }\n  } else if (tx.AuthorizeCredentials !== undefined) {\n    (0, common_1.validateCredentialsList)(tx.AuthorizeCredentials, tx.TransactionType, false, common_1.MAX_AUTHORIZED_CREDENTIALS);\n  } else if (tx.UnauthorizeCredentials !== undefined) {\n    (0, common_1.validateCredentialsList)(tx.UnauthorizeCredentials, tx.TransactionType, false, common_1.MAX_AUTHORIZED_CREDENTIALS);\n  }\n}\nexports.validateDepositPreauth = validateDepositPreauth;\nfunction validateSingleAuthorizationFieldProvided(tx) {\n  const fields = ['Authorize', 'Unauthorize', 'AuthorizeCredentials', 'UnauthorizeCredentials'];\n  const countProvided = fields.filter(key => tx[key] !== undefined).length;\n  if (countProvided !== 1) {\n    throw new errors_1.ValidationError('DepositPreauth: Requires exactly one field of the following: Authorize, Unauthorize, AuthorizeCredentials, UnauthorizeCredentials.');\n  }\n}","map":{"version":3,"names":["errors_1","require","common_1","validateDepositPreauth","tx","validateBaseTransaction","validateSingleAuthorizationFieldProvided","Authorize","undefined","ValidationError","Account","Unauthorize","AuthorizeCredentials","validateCredentialsList","TransactionType","MAX_AUTHORIZED_CREDENTIALS","UnauthorizeCredentials","exports","fields","countProvided","filter","key","length"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/models/transactions/depositPreauth.ts"],"sourcesContent":["import { ValidationError } from '../../errors'\nimport { AuthorizeCredential } from '../common'\n\nimport {\n  BaseTransaction,\n  validateBaseTransaction,\n  validateCredentialsList,\n  MAX_AUTHORIZED_CREDENTIALS,\n} from './common'\n\n/**\n * A DepositPreauth transaction gives another account pre-approval to deliver\n * payments to the sender of this transaction. This is only useful if the sender\n * of this transaction is using (or plans to use) Deposit Authorization.\n *\n * @category Transaction Models\n */\nexport interface DepositPreauth extends BaseTransaction {\n  TransactionType: 'DepositPreauth'\n  /** The XRP Ledger address of the sender to preauthorize. */\n  Authorize?: string\n  /**\n   * The XRP Ledger address of a sender whose preauthorization should be.\n   * revoked.\n   */\n  Unauthorize?: string\n\n  /**\n   * The credential(s) to preauthorize.\n   */\n  AuthorizeCredentials?: AuthorizeCredential[]\n\n  /**\n   * The credential(s) whose preauthorization should be revoked.\n   */\n  UnauthorizeCredentials?: AuthorizeCredential[]\n}\n\n/**\n * Verify the form and type of a DepositPreauth at runtime.\n *\n * @param tx - A DepositPreauth Transaction.\n * @throws When the DepositPreauth is malformed.\n */\nexport function validateDepositPreauth(tx: Record<string, unknown>): void {\n  validateBaseTransaction(tx)\n\n  validateSingleAuthorizationFieldProvided(tx)\n\n  if (tx.Authorize !== undefined) {\n    if (typeof tx.Authorize !== 'string') {\n      throw new ValidationError('DepositPreauth: Authorize must be a string')\n    }\n\n    if (tx.Account === tx.Authorize) {\n      throw new ValidationError(\n        \"DepositPreauth: Account can't preauthorize its own address\",\n      )\n    }\n  } else if (tx.Unauthorize !== undefined) {\n    if (typeof tx.Unauthorize !== 'string') {\n      throw new ValidationError('DepositPreauth: Unauthorize must be a string')\n    }\n\n    if (tx.Account === tx.Unauthorize) {\n      throw new ValidationError(\n        \"DepositPreauth: Account can't unauthorize its own address\",\n      )\n    }\n  } else if (tx.AuthorizeCredentials !== undefined) {\n    validateCredentialsList(\n      tx.AuthorizeCredentials,\n      tx.TransactionType,\n      false,\n      MAX_AUTHORIZED_CREDENTIALS,\n    )\n  } else if (tx.UnauthorizeCredentials !== undefined) {\n    validateCredentialsList(\n      tx.UnauthorizeCredentials,\n      tx.TransactionType,\n      false,\n      MAX_AUTHORIZED_CREDENTIALS,\n    )\n  }\n}\n\n// Boolean logic to ensure exactly one of 4 inputs was provided\nfunction validateSingleAuthorizationFieldProvided(\n  tx: Record<string, unknown>,\n): void {\n  const fields = [\n    'Authorize',\n    'Unauthorize',\n    'AuthorizeCredentials',\n    'UnauthorizeCredentials',\n  ]\n  const countProvided = fields.filter((key) => tx[key] !== undefined).length\n\n  if (countProvided !== 1) {\n    throw new ValidationError(\n      'DepositPreauth: Requires exactly one field of the following: Authorize, Unauthorize, AuthorizeCredentials, UnauthorizeCredentials.',\n    )\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AAGA,MAAAC,QAAA,GAAAD,OAAA;AAyCA,SAAgBE,sBAAsBA,CAACC,EAA2B;EAChE,IAAAF,QAAA,CAAAG,uBAAuB,EAACD,EAAE,CAAC;EAE3BE,wCAAwC,CAACF,EAAE,CAAC;EAE5C,IAAIA,EAAE,CAACG,SAAS,KAAKC,SAAS,EAAE;IAC9B,IAAI,OAAOJ,EAAE,CAACG,SAAS,KAAK,QAAQ,EAAE;MACpC,MAAM,IAAIP,QAAA,CAAAS,eAAe,CAAC,4CAA4C,CAAC;;IAGzE,IAAIL,EAAE,CAACM,OAAO,KAAKN,EAAE,CAACG,SAAS,EAAE;MAC/B,MAAM,IAAIP,QAAA,CAAAS,eAAe,CACvB,4DAA4D,CAC7D;;GAEJ,MAAM,IAAIL,EAAE,CAACO,WAAW,KAAKH,SAAS,EAAE;IACvC,IAAI,OAAOJ,EAAE,CAACO,WAAW,KAAK,QAAQ,EAAE;MACtC,MAAM,IAAIX,QAAA,CAAAS,eAAe,CAAC,8CAA8C,CAAC;;IAG3E,IAAIL,EAAE,CAACM,OAAO,KAAKN,EAAE,CAACO,WAAW,EAAE;MACjC,MAAM,IAAIX,QAAA,CAAAS,eAAe,CACvB,2DAA2D,CAC5D;;GAEJ,MAAM,IAAIL,EAAE,CAACQ,oBAAoB,KAAKJ,SAAS,EAAE;IAChD,IAAAN,QAAA,CAAAW,uBAAuB,EACrBT,EAAE,CAACQ,oBAAoB,EACvBR,EAAE,CAACU,eAAe,EAClB,KAAK,EACLZ,QAAA,CAAAa,0BAA0B,CAC3B;GACF,MAAM,IAAIX,EAAE,CAACY,sBAAsB,KAAKR,SAAS,EAAE;IAClD,IAAAN,QAAA,CAAAW,uBAAuB,EACrBT,EAAE,CAACY,sBAAsB,EACzBZ,EAAE,CAACU,eAAe,EAClB,KAAK,EACLZ,QAAA,CAAAa,0BAA0B,CAC3B;;AAEL;AAxCAE,OAAA,CAAAd,sBAAA,GAAAA,sBAAA;AA2CA,SAASG,wCAAwCA,CAC/CF,EAA2B;EAE3B,MAAMc,MAAM,GAAG,CACb,WAAW,EACX,aAAa,EACb,sBAAsB,EACtB,wBAAwB,CACzB;EACD,MAAMC,aAAa,GAAGD,MAAM,CAACE,MAAM,CAAEC,GAAG,IAAKjB,EAAE,CAACiB,GAAG,CAAC,KAAKb,SAAS,CAAC,CAACc,MAAM;EAE1E,IAAIH,aAAa,KAAK,CAAC,EAAE;IACvB,MAAM,IAAInB,QAAA,CAAAS,eAAe,CACvB,oIAAoI,CACrI;;AAEL","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}