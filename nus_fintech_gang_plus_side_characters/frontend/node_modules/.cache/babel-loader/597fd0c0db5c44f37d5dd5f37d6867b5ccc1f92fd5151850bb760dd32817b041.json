{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateMPTokenMetadata = exports.decodeMPTokenMetadata = exports.encodeMPTokenMetadata = exports.MPT_META_WARNING_HEADER = exports.MAX_MPT_META_BYTE_LENGTH = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst fast_json_stable_stringify_1 = __importDefault(require(\"fast-json-stable-stringify\"));\nconst common_1 = require(\"../transactions/common\");\nconst _1 = require(\".\");\nexports.MAX_MPT_META_BYTE_LENGTH = 1024;\nexports.MPT_META_WARNING_HEADER = 'MPTokenMetadata is not properly formatted as JSON as per the XLS-89 standard. ' + \"While adherence to this standard is not mandatory, such non-compliant MPToken's might not be discoverable \" + 'by Explorers and Indexers in the XRPL ecosystem.';\nconst MPT_META_URI_FIELDS = [{\n  long: 'uri',\n  compact: 'u'\n}, {\n  long: 'category',\n  compact: 'c'\n}, {\n  long: 'title',\n  compact: 't'\n}];\nconst MPT_META_ALL_FIELDS = [{\n  long: 'ticker',\n  compact: 't',\n  validate(obj) {\n    var _a;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    if (!(0, common_1.isString)(value) || !/^[A-Z0-9]{1,6}$/u.test(value)) {\n      return [`${this.long}/${this.compact}: should have uppercase letters (A-Z) and digits (0-9) only. Max 6 characters recommended.`];\n    }\n    return [];\n  }\n}, {\n  long: 'name',\n  compact: 'n',\n  validate(obj) {\n    var _a;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    if (!(0, common_1.isString)(value) || value.length === 0) {\n      return [`${this.long}/${this.compact}: should be a non-empty string.`];\n    }\n    return [];\n  }\n}, {\n  long: 'icon',\n  compact: 'i',\n  validate(obj) {\n    var _a;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    if (!(0, common_1.isString)(value) || value.length === 0) {\n      return [`${this.long}/${this.compact}: should be a non-empty string.`];\n    }\n    return [];\n  }\n}, {\n  long: 'asset_class',\n  compact: 'ac',\n  validate(obj) {\n    var _a;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    const MPT_META_ASSET_CLASSES = ['rwa', 'memes', 'wrapped', 'gaming', 'defi', 'other'];\n    if (!(0, common_1.isString)(value) || !MPT_META_ASSET_CLASSES.includes(value)) {\n      return [`${this.long}/${this.compact}: should be one of ${MPT_META_ASSET_CLASSES.join(', ')}.`];\n    }\n    return [];\n  }\n}, {\n  long: 'issuer_name',\n  compact: 'in',\n  validate(obj) {\n    var _a;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    if (!(0, common_1.isString)(value) || value.length === 0) {\n      return [`${this.long}/${this.compact}: should be a non-empty string.`];\n    }\n    return [];\n  }\n}, {\n  long: 'desc',\n  compact: 'd',\n  validate(obj) {\n    var _a;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    if (obj[this.long] === undefined && obj[this.compact] === undefined) {\n      return [];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    if (!(0, common_1.isString)(value) || value.length === 0) {\n      return [`${this.long}/${this.compact}: should be a non-empty string.`];\n    }\n    return [];\n  }\n}, {\n  long: 'asset_subclass',\n  compact: 'as',\n  required: false,\n  validate(obj) {\n    var _a;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    if ((obj.asset_class === 'rwa' || obj.ac === 'rwa') && value === undefined) {\n      return [`${this.long}/${this.compact}: required when asset_class is rwa.`];\n    }\n    if (obj[this.long] === undefined && obj[this.compact] === undefined) {\n      return [];\n    }\n    const MPT_META_ASSET_SUB_CLASSES = ['stablecoin', 'commodity', 'real_estate', 'private_credit', 'equity', 'treasury', 'other'];\n    if (!(0, common_1.isString)(value) || !MPT_META_ASSET_SUB_CLASSES.includes(value)) {\n      return [`${this.long}/${this.compact}: should be one of ${MPT_META_ASSET_SUB_CLASSES.join(', ')}.`];\n    }\n    return [];\n  }\n}, {\n  long: 'uris',\n  compact: 'us',\n  required: false,\n  validate(obj) {\n    var _a, _b, _c, _d;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    if (obj[this.long] === undefined && obj[this.compact] === undefined) {\n      return [];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    if (!Array.isArray(value) || value.length === 0) {\n      return [`${this.long}/${this.compact}: should be a non-empty array.`];\n    }\n    const messages = [];\n    for (const uriObj of value) {\n      if (!(0, common_1.isRecord)(uriObj) || Object.keys(uriObj).length !== MPT_META_URI_FIELDS.length) {\n        messages.push(`${this.long}/${this.compact}: should be an array of objects each with uri/u, category/c, and title/t properties.`);\n        continue;\n      }\n      for (const uriField of MPT_META_URI_FIELDS) {\n        if (uriObj[uriField.long] != null && uriObj[uriField.compact] != null) {\n          messages.push(`${this.long}/${this.compact}: should not have both ${uriField.long} and ${uriField.compact} fields.`);\n          break;\n        }\n      }\n      const uri = (_b = uriObj.uri) !== null && _b !== void 0 ? _b : uriObj.u;\n      const category = (_c = uriObj.category) !== null && _c !== void 0 ? _c : uriObj.c;\n      const title = (_d = uriObj.title) !== null && _d !== void 0 ? _d : uriObj.t;\n      if (!(0, common_1.isString)(uri) || !(0, common_1.isString)(category) || !(0, common_1.isString)(title)) {\n        messages.push(`${this.long}/${this.compact}: should be an array of objects each with uri/u, category/c, and title/t properties.`);\n      }\n    }\n    return messages;\n  }\n}, {\n  long: 'additional_info',\n  compact: 'ai',\n  required: false,\n  validate(obj) {\n    var _a;\n    if (obj[this.long] != null && obj[this.compact] != null) {\n      return [`${this.long}/${this.compact}: both long and compact forms present. expected only one.`];\n    }\n    if (obj[this.long] === undefined && obj[this.compact] === undefined) {\n      return [];\n    }\n    const value = (_a = obj[this.long]) !== null && _a !== void 0 ? _a : obj[this.compact];\n    if (!(0, common_1.isString)(value) && !(0, common_1.isRecord)(value)) {\n      return [`${this.long}/${this.compact}: should be a string or JSON object.`];\n    }\n    return [];\n  }\n}];\nfunction shortenKeys(input, mappings) {\n  const output = {};\n  for (const [key, value] of Object.entries(input)) {\n    const mapping = mappings.find(({\n      long,\n      compact\n    }) => long === key || compact === key);\n    if (mapping === undefined) {\n      output[key] = value;\n      continue;\n    }\n    if (input[mapping.long] !== undefined && input[mapping.compact] !== undefined) {\n      output[key] = value;\n      continue;\n    }\n    output[mapping.compact] = value;\n  }\n  return output;\n}\nfunction encodeMPTokenMetadata(mptokenMetadata) {\n  let input = mptokenMetadata;\n  if (!(0, common_1.isRecord)(input)) {\n    throw new Error('MPTokenMetadata must be JSON object.');\n  }\n  input = shortenKeys(input, MPT_META_ALL_FIELDS);\n  if (Array.isArray(input.uris)) {\n    input.uris = input.uris.map(uri => {\n      if ((0, common_1.isRecord)(uri)) {\n        return shortenKeys(uri, MPT_META_URI_FIELDS);\n      }\n      return uri;\n    });\n  }\n  if (Array.isArray(input.us)) {\n    input.us = input.us.map(uri => {\n      if ((0, common_1.isRecord)(uri)) {\n        return shortenKeys(uri, MPT_META_URI_FIELDS);\n      }\n      return uri;\n    });\n  }\n  return (0, utils_1.stringToHex)((0, fast_json_stable_stringify_1.default)(input)).toUpperCase();\n}\nexports.encodeMPTokenMetadata = encodeMPTokenMetadata;\nfunction expandKeys(input, mappings) {\n  const output = {};\n  for (const [key, value] of Object.entries(input)) {\n    const mapping = mappings.find(({\n      long,\n      compact\n    }) => long === key || compact === key);\n    if (mapping === undefined) {\n      output[key] = value;\n      continue;\n    }\n    if (input[mapping.long] !== undefined && input[mapping.compact] !== undefined) {\n      output[key] = value;\n      continue;\n    }\n    output[mapping.long] = value;\n  }\n  return output;\n}\nfunction decodeMPTokenMetadata(input) {\n  if (!(0, _1.isHex)(input)) {\n    throw new Error('MPTokenMetadata must be in hex format.');\n  }\n  let jsonMetaData;\n  try {\n    jsonMetaData = JSON.parse((0, utils_1.hexToString)(input));\n  } catch (err) {\n    throw new Error(`MPTokenMetadata is not properly formatted as JSON - ${String(err)}`);\n  }\n  if (!(0, common_1.isRecord)(jsonMetaData)) {\n    throw new Error('MPTokenMetadata must be a JSON object.');\n  }\n  let output = jsonMetaData;\n  output = expandKeys(output, MPT_META_ALL_FIELDS);\n  if (Array.isArray(output.uris)) {\n    output.uris = output.uris.map(uri => {\n      if ((0, common_1.isRecord)(uri)) {\n        return expandKeys(uri, MPT_META_URI_FIELDS);\n      }\n      return uri;\n    });\n  }\n  if (Array.isArray(output.us)) {\n    output.us = output.us.map(uri => {\n      if ((0, common_1.isRecord)(uri)) {\n        return expandKeys(uri, MPT_META_URI_FIELDS);\n      }\n      return uri;\n    });\n  }\n  return output;\n}\nexports.decodeMPTokenMetadata = decodeMPTokenMetadata;\nfunction validateMPTokenMetadata(input) {\n  const validationMessages = [];\n  if (!(0, _1.isHex)(input)) {\n    validationMessages.push(`MPTokenMetadata must be in hex format.`);\n    return validationMessages;\n  }\n  if (input.length / 2 > exports.MAX_MPT_META_BYTE_LENGTH) {\n    validationMessages.push(`MPTokenMetadata must be max ${exports.MAX_MPT_META_BYTE_LENGTH} bytes.`);\n    return validationMessages;\n  }\n  let jsonMetaData;\n  try {\n    jsonMetaData = JSON.parse((0, utils_1.hexToString)(input));\n  } catch (err) {\n    validationMessages.push(`MPTokenMetadata is not properly formatted as JSON - ${String(err)}`);\n    return validationMessages;\n  }\n  if (!(0, common_1.isRecord)(jsonMetaData)) {\n    validationMessages.push('MPTokenMetadata is not properly formatted JSON object as per XLS-89.');\n    return validationMessages;\n  }\n  if (Object.keys(jsonMetaData).length > MPT_META_ALL_FIELDS.length) {\n    validationMessages.push(`MPTokenMetadata must not contain more than ${MPT_META_ALL_FIELDS.length} top-level fields (found ${Object.keys(jsonMetaData).length}).`);\n  }\n  const obj = jsonMetaData;\n  for (const property of MPT_META_ALL_FIELDS) {\n    validationMessages.push(...property.validate(obj));\n  }\n  return validationMessages;\n}\nexports.validateMPTokenMetadata = validateMPTokenMetadata;","map":{"version":3,"names":["utils_1","require","fast_json_stable_stringify_1","__importDefault","common_1","_1","exports","MAX_MPT_META_BYTE_LENGTH","MPT_META_WARNING_HEADER","MPT_META_URI_FIELDS","long","compact","MPT_META_ALL_FIELDS","validate","obj","value","_a","isString","test","length","MPT_META_ASSET_CLASSES","includes","join","undefined","required","asset_class","ac","MPT_META_ASSET_SUB_CLASSES","Array","isArray","messages","uriObj","isRecord","Object","keys","push","uriField","uri","_b","u","category","_c","c","title","_d","t","shortenKeys","input","mappings","output","key","entries","mapping","find","encodeMPTokenMetadata","mptokenMetadata","Error","uris","map","us","stringToHex","default","toUpperCase","expandKeys","decodeMPTokenMetadata","isHex","jsonMetaData","JSON","parse","hexToString","err","String","validateMPTokenMetadata","validationMessages","property"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/models/utils/mptokenMetadata.ts"],"sourcesContent":["/* eslint-disable max-lines -- utility file */\n/* eslint-disable no-continue -- makes logic easier to write and read in this case */\n\nimport { hexToString, stringToHex } from '@xrplf/isomorphic/utils'\nimport stableStringify from 'fast-json-stable-stringify'\n\nimport type { MPTokenMetadata } from '../common'\nimport { isRecord, isString } from '../transactions/common'\n\nimport { isHex } from '.'\n\nexport const MAX_MPT_META_BYTE_LENGTH = 1024\nexport const MPT_META_WARNING_HEADER =\n  'MPTokenMetadata is not properly formatted as JSON as per the XLS-89 standard. ' +\n  \"While adherence to this standard is not mandatory, such non-compliant MPToken's might not be discoverable \" +\n  'by Explorers and Indexers in the XRPL ecosystem.'\n\nconst MPT_META_URI_FIELDS = [\n  {\n    long: 'uri',\n    compact: 'u',\n  },\n  {\n    long: 'category',\n    compact: 'c',\n  },\n  {\n    long: 'title',\n    compact: 't',\n  },\n]\n\nconst MPT_META_ALL_FIELDS = [\n  {\n    long: 'ticker',\n    compact: 't',\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      const value = obj[this.long] ?? obj[this.compact]\n      if (!isString(value) || !/^[A-Z0-9]{1,6}$/u.test(value)) {\n        return [\n          `${this.long}/${this.compact}: should have uppercase letters (A-Z) and digits (0-9) only. Max 6 characters recommended.`,\n        ]\n      }\n\n      return []\n    },\n  },\n  {\n    long: 'name',\n    compact: 'n',\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      const value = obj[this.long] ?? obj[this.compact]\n      if (!isString(value) || value.length === 0) {\n        return [`${this.long}/${this.compact}: should be a non-empty string.`]\n      }\n\n      return []\n    },\n  },\n  {\n    long: 'icon',\n    compact: 'i',\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      const value = obj[this.long] ?? obj[this.compact]\n      if (!isString(value) || value.length === 0) {\n        return [`${this.long}/${this.compact}: should be a non-empty string.`]\n      }\n\n      return []\n    },\n  },\n  {\n    long: 'asset_class',\n    compact: 'ac',\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      const value = obj[this.long] ?? obj[this.compact]\n      const MPT_META_ASSET_CLASSES = [\n        'rwa',\n        'memes',\n        'wrapped',\n        'gaming',\n        'defi',\n        'other',\n      ]\n\n      if (!isString(value) || !MPT_META_ASSET_CLASSES.includes(value)) {\n        return [\n          `${this.long}/${this.compact}: should be one of ${MPT_META_ASSET_CLASSES.join(\n            ', ',\n          )}.`,\n        ]\n      }\n      return []\n    },\n  },\n  {\n    long: 'issuer_name',\n    compact: 'in',\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      const value = obj[this.long] ?? obj[this.compact]\n      if (!isString(value) || value.length === 0) {\n        return [`${this.long}/${this.compact}: should be a non-empty string.`]\n      }\n\n      return []\n    },\n  },\n  {\n    long: 'desc',\n    compact: 'd',\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      if (obj[this.long] === undefined && obj[this.compact] === undefined) {\n        return []\n      }\n      const value = obj[this.long] ?? obj[this.compact]\n      if (!isString(value) || value.length === 0) {\n        return [`${this.long}/${this.compact}: should be a non-empty string.`]\n      }\n\n      return []\n    },\n  },\n  {\n    long: 'asset_subclass',\n    compact: 'as',\n    required: false,\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      const value = obj[this.long] ?? obj[this.compact]\n      if (\n        (obj.asset_class === 'rwa' || obj.ac === 'rwa') &&\n        value === undefined\n      ) {\n        return [\n          `${this.long}/${this.compact}: required when asset_class is rwa.`,\n        ]\n      }\n\n      if (obj[this.long] === undefined && obj[this.compact] === undefined) {\n        return []\n      }\n\n      const MPT_META_ASSET_SUB_CLASSES = [\n        'stablecoin',\n        'commodity',\n        'real_estate',\n        'private_credit',\n        'equity',\n        'treasury',\n        'other',\n      ]\n      if (!isString(value) || !MPT_META_ASSET_SUB_CLASSES.includes(value)) {\n        return [\n          `${this.long}/${this.compact}: should be one of ${MPT_META_ASSET_SUB_CLASSES.join(\n            ', ',\n          )}.`,\n        ]\n      }\n      return []\n    },\n  },\n  {\n    long: 'uris',\n    compact: 'us',\n    required: false,\n    // eslint-disable-next-line max-lines-per-function -- required for validation\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      if (obj[this.long] === undefined && obj[this.compact] === undefined) {\n        return []\n      }\n      const value = obj[this.long] ?? obj[this.compact]\n      if (!Array.isArray(value) || value.length === 0) {\n        return [`${this.long}/${this.compact}: should be a non-empty array.`]\n      }\n\n      const messages: string[] = []\n      for (const uriObj of value) {\n        if (\n          !isRecord(uriObj) ||\n          Object.keys(uriObj).length !== MPT_META_URI_FIELDS.length\n        ) {\n          messages.push(\n            `${this.long}/${this.compact}: should be an array of objects each with uri/u, category/c, and title/t properties.`,\n          )\n          continue\n        }\n\n        // Check for both long and compact forms in the same URI object\n        for (const uriField of MPT_META_URI_FIELDS) {\n          if (\n            uriObj[uriField.long] != null &&\n            uriObj[uriField.compact] != null\n          ) {\n            messages.push(\n              `${this.long}/${this.compact}: should not have both ${uriField.long} and ${uriField.compact} fields.`,\n            )\n            break\n          }\n        }\n\n        const uri = uriObj.uri ?? uriObj.u\n        const category = uriObj.category ?? uriObj.c\n        const title = uriObj.title ?? uriObj.t\n        if (!isString(uri) || !isString(category) || !isString(title)) {\n          messages.push(\n            `${this.long}/${this.compact}: should be an array of objects each with uri/u, category/c, and title/t properties.`,\n          )\n        }\n      }\n      return messages\n    },\n  },\n  {\n    long: 'additional_info',\n    compact: 'ai',\n    required: false,\n    validate(obj: Record<string, unknown>): string[] {\n      if (obj[this.long] != null && obj[this.compact] != null) {\n        return [\n          `${this.long}/${this.compact}: both long and compact forms present. expected only one.`,\n        ]\n      }\n\n      if (obj[this.long] === undefined && obj[this.compact] === undefined) {\n        return []\n      }\n      const value = obj[this.long] ?? obj[this.compact]\n      if (!isString(value) && !isRecord(value)) {\n        return [\n          `${this.long}/${this.compact}: should be a string or JSON object.`,\n        ]\n      }\n\n      return []\n    },\n  },\n]\n\n/**\n * Shortens long field names to their compact form equivalents.\n * Reverse operation of {@link expandKeys}.\n *\n * @param input - Object with potentially long field names.\n * @param mappings - Array of field mappings with long and compact names.\n * @returns Object with shortened compact field names.\n */\nfunction shortenKeys(\n  input: Record<string, unknown>,\n  mappings: Array<{ long: string; compact: string }>,\n): Record<string, unknown> {\n  const output: Record<string, unknown> = {}\n\n  for (const [key, value] of Object.entries(input)) {\n    const mapping = mappings.find(\n      ({ long, compact }) => long === key || compact === key,\n    )\n    // Extra keys stays there\n    if (mapping === undefined) {\n      output[key] = value\n      continue\n    }\n\n    // Both long and compact forms are present\n    if (\n      input[mapping.long] !== undefined &&\n      input[mapping.compact] !== undefined\n    ) {\n      output[key] = value\n      continue\n    }\n\n    output[mapping.compact] = value\n  }\n\n  return output\n}\n\n/**\n * Encodes {@link MPTokenMetadata} object to a hex string.\n * Steps:\n * 1. Shorten long field names to their compact form equivalents.\n * 2. Sort the fields alphabetically for deterministic encoding.\n * 3. Stringify the object.\n * 4. Convert to hex.\n *\n * @param mptokenMetadata - {@link MPTokenMetadata} to encode.\n * @returns Hex encoded {@link MPTokenMetadata}.\n * @throws Error if input is not a JSON object.\n * @category Utilities\n */\nexport function encodeMPTokenMetadata(\n  mptokenMetadata: MPTokenMetadata,\n): string {\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Required here to implement type-guard\n  let input = mptokenMetadata as unknown as Record<string, unknown>\n\n  if (!isRecord(input)) {\n    throw new Error('MPTokenMetadata must be JSON object.')\n  }\n\n  input = shortenKeys(input, MPT_META_ALL_FIELDS)\n\n  if (Array.isArray(input.uris)) {\n    input.uris = input.uris.map(\n      (uri: Record<string, unknown>): Record<string, unknown> => {\n        if (isRecord(uri)) {\n          return shortenKeys(uri, MPT_META_URI_FIELDS)\n        }\n        return uri\n      },\n    )\n  }\n\n  if (Array.isArray(input.us)) {\n    input.us = input.us.map(\n      (uri: Record<string, unknown>): Record<string, unknown> => {\n        if (isRecord(uri)) {\n          return shortenKeys(uri, MPT_META_URI_FIELDS)\n        }\n        return uri\n      },\n    )\n  }\n\n  return stringToHex(stableStringify(input)).toUpperCase()\n}\n\n/**\n * Expands compact field names to their long form equivalents.\n * Reverse operation of {@link shortenKeys}.\n *\n * @param input - Object with potentially compact field names.\n * @param mappings - Array of field mappings with long and compact names.\n * @returns Object with expanded long field names.\n */\nfunction expandKeys(\n  input: Record<string, unknown>,\n  mappings: Array<{ long: string; compact: string }>,\n): Record<string, unknown> {\n  const output: Record<string, unknown> = {}\n\n  for (const [key, value] of Object.entries(input)) {\n    const mapping = mappings.find(\n      ({ long, compact }) => long === key || compact === key,\n    )\n    // Extra keys stays there\n    if (mapping === undefined) {\n      output[key] = value\n      continue\n    }\n\n    // Both long and compact forms are present\n    if (\n      input[mapping.long] !== undefined &&\n      input[mapping.compact] !== undefined\n    ) {\n      output[key] = value\n      continue\n    }\n\n    output[mapping.long] = value\n  }\n\n  return output\n}\n\n/**\n * Decodes hex-encoded {@link MPTokenMetadata} into a JSON object.\n * Converts compact field names to their corresponding long-form equivalents.\n *\n * @param input - Hex encoded {@link MPTokenMetadata}.\n * @returns Decoded {@link MPTokenMetadata} object with long field names.\n * @throws Error if input is not valid hex or cannot be parsed as JSON.\n * @category Utilities\n */\nexport function decodeMPTokenMetadata(input: string): MPTokenMetadata {\n  if (!isHex(input)) {\n    throw new Error('MPTokenMetadata must be in hex format.')\n  }\n\n  let jsonMetaData: unknown\n  try {\n    jsonMetaData = JSON.parse(hexToString(input))\n  } catch (err) {\n    throw new Error(\n      `MPTokenMetadata is not properly formatted as JSON - ${String(err)}`,\n    )\n  }\n\n  if (!isRecord(jsonMetaData)) {\n    throw new Error('MPTokenMetadata must be a JSON object.')\n  }\n\n  let output = jsonMetaData\n\n  output = expandKeys(output, MPT_META_ALL_FIELDS)\n\n  if (Array.isArray(output.uris)) {\n    output.uris = output.uris.map(\n      (uri: Record<string, unknown>): Record<string, unknown> => {\n        if (isRecord(uri)) {\n          return expandKeys(uri, MPT_META_URI_FIELDS)\n        }\n        return uri\n      },\n    )\n  }\n\n  if (Array.isArray(output.us)) {\n    output.us = output.us.map(\n      (uri: Record<string, unknown>): Record<string, unknown> => {\n        if (isRecord(uri)) {\n          return expandKeys(uri, MPT_META_URI_FIELDS)\n        }\n        return uri\n      },\n    )\n  }\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Required here as output is now properly formatted\n  return output as unknown as MPTokenMetadata\n}\n\n/**\n * Validates {@link MPTokenMetadata} adheres to XLS-89 standard.\n *\n * @param input - Hex encoded {@link MPTokenMetadata}.\n * @returns Validation messages if {@link MPTokenMetadata} does not adheres to XLS-89 standard.\n * @category Utilities\n */\nexport function validateMPTokenMetadata(input: string): string[] {\n  const validationMessages: string[] = []\n\n  // Validate hex format\n  if (!isHex(input)) {\n    validationMessages.push(`MPTokenMetadata must be in hex format.`)\n    return validationMessages\n  }\n\n  // Validate byte length\n  if (input.length / 2 > MAX_MPT_META_BYTE_LENGTH) {\n    validationMessages.push(\n      `MPTokenMetadata must be max ${MAX_MPT_META_BYTE_LENGTH} bytes.`,\n    )\n    return validationMessages\n  }\n\n  // Parse JSON\n  let jsonMetaData: unknown\n  try {\n    jsonMetaData = JSON.parse(hexToString(input))\n  } catch (err) {\n    validationMessages.push(\n      `MPTokenMetadata is not properly formatted as JSON - ${String(err)}`,\n    )\n    return validationMessages\n  }\n\n  // Validate JSON structure\n  if (!isRecord(jsonMetaData)) {\n    validationMessages.push(\n      'MPTokenMetadata is not properly formatted JSON object as per XLS-89.',\n    )\n    return validationMessages\n  }\n\n  if (Object.keys(jsonMetaData).length > MPT_META_ALL_FIELDS.length) {\n    validationMessages.push(\n      `MPTokenMetadata must not contain more than ${MPT_META_ALL_FIELDS.length} top-level fields (found ${\n        Object.keys(jsonMetaData).length\n      }).`,\n    )\n  }\n\n  const obj = jsonMetaData\n\n  for (const property of MPT_META_ALL_FIELDS) {\n    validationMessages.push(...property.validate(obj))\n  }\n\n  return validationMessages\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}