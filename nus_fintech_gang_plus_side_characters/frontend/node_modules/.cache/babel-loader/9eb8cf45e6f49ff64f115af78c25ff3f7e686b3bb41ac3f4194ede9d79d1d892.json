{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDomainID = exports.containsDuplicates = exports.validateCredentialsList = exports.validateCredentialType = exports.parseAmountValue = exports.validateBaseTransaction = exports.GlobalFlags = exports.validateOptionalField = exports.validateRequiredField = exports.validateHexMetadata = exports.isLedgerEntryId = exports.isArray = exports.isXChainBridge = exports.isTokenAmount = exports.isAmount = exports.isAccount = exports.isClawbackAmount = exports.isMPTAmount = exports.isAuthorizeCredential = exports.isIssuedCurrencyAmount = exports.isIssuedCurrency = exports.isCurrency = exports.isXRPLNumber = exports.isValue = exports.isNull = exports.isNumber = exports.isString = exports.isRecord = exports.VAULT_DATA_MAX_BYTE_LENGTH = exports.MAX_AUTHORIZED_CREDENTIALS = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst ripple_address_codec_1 = require(\"ripple-address-codec\");\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst errors_1 = require(\"../../errors\");\nconst utils_2 = require(\"../utils\");\nconst MEMO_SIZE = 3;\nexports.MAX_AUTHORIZED_CREDENTIALS = 8;\nconst MAX_CREDENTIAL_BYTE_LENGTH = 64;\nconst MAX_CREDENTIAL_TYPE_LENGTH = MAX_CREDENTIAL_BYTE_LENGTH * 2;\nconst SHA_512_HALF_LENGTH = 64;\nexports.VAULT_DATA_MAX_BYTE_LENGTH = 256;\nfunction isMemo(obj) {\n  if (!isRecord(obj)) {\n    return false;\n  }\n  const memo = obj.Memo;\n  if (!isRecord(memo)) {\n    return false;\n  }\n  const size = Object.keys(memo).length;\n  const validData = memo.MemoData == null || isString(memo.MemoData) && (0, utils_2.isHex)(memo.MemoData);\n  const validFormat = memo.MemoFormat == null || isString(memo.MemoFormat) && (0, utils_2.isHex)(memo.MemoFormat);\n  const validType = memo.MemoType == null || isString(memo.MemoType) && (0, utils_2.isHex)(memo.MemoType);\n  return size >= 1 && size <= MEMO_SIZE && validData && validFormat && validType && (0, utils_2.onlyHasFields)(memo, ['MemoFormat', 'MemoData', 'MemoType']);\n}\nconst SIGNER_SIZE = 3;\nfunction isSigner(obj) {\n  if (!isRecord(obj)) {\n    return false;\n  }\n  const signer = obj.Signer;\n  if (!isRecord(signer)) {\n    return false;\n  }\n  return Object.keys(signer).length === SIGNER_SIZE && isString(signer.Account) && isString(signer.TxnSignature) && isString(signer.SigningPubKey);\n}\nconst XRP_CURRENCY_SIZE = 1;\nconst MPT_CURRENCY_SIZE = 1;\nconst ISSUE_CURRENCY_SIZE = 2;\nconst MPT_CURRENCY_AMOUNT_SIZE = 2;\nconst ISSUED_CURRENCY_AMOUNT_SIZE = 3;\nconst XCHAIN_BRIDGE_SIZE = 4;\nconst AUTHORIZE_CREDENTIAL_SIZE = 1;\nfunction isRecord(value) {\n  return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\nexports.isRecord = isRecord;\nfunction isString(str) {\n  return typeof str === 'string';\n}\nexports.isString = isString;\nfunction isNumber(num) {\n  return typeof num === 'number';\n}\nexports.isNumber = isNumber;\nfunction isNull(inp) {\n  return inp == null;\n}\nexports.isNull = isNull;\nfunction isValue(value) {\n  const isValueInternal = inp => inp === value;\n  return isValueInternal;\n}\nexports.isValue = isValue;\nfunction isXRPLNumber(value) {\n  return typeof value === 'string' && /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][-+]?\\d+)?$/u.test(value.trim());\n}\nexports.isXRPLNumber = isXRPLNumber;\nfunction isCurrency(input) {\n  return isRecord(input) && (Object.keys(input).length === ISSUE_CURRENCY_SIZE && isString(input.issuer) && isString(input.currency) || Object.keys(input).length === XRP_CURRENCY_SIZE && input.currency === 'XRP' || Object.keys(input).length === MPT_CURRENCY_SIZE && isString(input.mpt_issuance_id));\n}\nexports.isCurrency = isCurrency;\nfunction isIssuedCurrency(input) {\n  return isRecord(input) && (Object.keys(input).length === ISSUE_CURRENCY_SIZE && isString(input.issuer) && isString(input.currency) || Object.keys(input).length === XRP_CURRENCY_SIZE && input.currency === 'XRP');\n}\nexports.isIssuedCurrency = isIssuedCurrency;\nfunction isIssuedCurrencyAmount(input) {\n  return isRecord(input) && Object.keys(input).length === ISSUED_CURRENCY_AMOUNT_SIZE && isString(input.value) && isString(input.issuer) && isString(input.currency);\n}\nexports.isIssuedCurrencyAmount = isIssuedCurrencyAmount;\nfunction isAuthorizeCredential(input) {\n  return isRecord(input) && isRecord(input.Credential) && Object.keys(input).length === AUTHORIZE_CREDENTIAL_SIZE && typeof input.Credential.CredentialType === 'string' && typeof input.Credential.Issuer === 'string';\n}\nexports.isAuthorizeCredential = isAuthorizeCredential;\nfunction isMPTAmount(input) {\n  return isRecord(input) && Object.keys(input).length === MPT_CURRENCY_AMOUNT_SIZE && typeof input.value === 'string' && typeof input.mpt_issuance_id === 'string';\n}\nexports.isMPTAmount = isMPTAmount;\nfunction isClawbackAmount(input) {\n  return isIssuedCurrencyAmount(input) || isMPTAmount(input);\n}\nexports.isClawbackAmount = isClawbackAmount;\nfunction isAccount(account) {\n  return typeof account === 'string' && ((0, ripple_address_codec_1.isValidClassicAddress)(account) || (0, ripple_address_codec_1.isValidXAddress)(account));\n}\nexports.isAccount = isAccount;\nfunction isAmount(amount) {\n  return typeof amount === 'string' || isIssuedCurrencyAmount(amount) || isMPTAmount(amount);\n}\nexports.isAmount = isAmount;\nfunction isTokenAmount(amount) {\n  return isIssuedCurrencyAmount(amount) || isMPTAmount(amount);\n}\nexports.isTokenAmount = isTokenAmount;\nfunction isXChainBridge(input) {\n  return isRecord(input) && Object.keys(input).length === XCHAIN_BRIDGE_SIZE && typeof input.LockingChainDoor === 'string' && isIssuedCurrency(input.LockingChainIssue) && typeof input.IssuingChainDoor === 'string' && isIssuedCurrency(input.IssuingChainIssue);\n}\nexports.isXChainBridge = isXChainBridge;\nfunction isArray(input) {\n  return input != null && Array.isArray(input);\n}\nexports.isArray = isArray;\nfunction isLedgerEntryId(input) {\n  return isString(input) && (0, utils_2.isHex)(input) && input.length === SHA_512_HALF_LENGTH;\n}\nexports.isLedgerEntryId = isLedgerEntryId;\nfunction validateHexMetadata(input, lengthUpto) {\n  return isString(input) && (0, utils_2.isHex)(input) && input.length > 0 && input.length <= lengthUpto;\n}\nexports.validateHexMetadata = validateHexMetadata;\nfunction validateRequiredField(tx, param, checkValidity, errorOpts = {}) {\n  var _a, _b;\n  const paramNameStr = (_a = errorOpts.paramName) !== null && _a !== void 0 ? _a : param;\n  const txType = (_b = errorOpts.txType) !== null && _b !== void 0 ? _b : tx.TransactionType;\n  if (tx[param] == null) {\n    throw new errors_1.ValidationError(`${txType}: missing field ${String(paramNameStr)}`);\n  }\n  if (!checkValidity(tx[param])) {\n    throw new errors_1.ValidationError(`${txType}: invalid field ${String(paramNameStr)}`);\n  }\n}\nexports.validateRequiredField = validateRequiredField;\nfunction validateOptionalField(tx, param, checkValidity, errorOpts = {}) {\n  var _a, _b;\n  const paramNameStr = (_a = errorOpts.paramName) !== null && _a !== void 0 ? _a : param;\n  const txType = (_b = errorOpts.txType) !== null && _b !== void 0 ? _b : tx.TransactionType;\n  if (tx[param] !== undefined && !checkValidity(tx[param])) {\n    throw new errors_1.ValidationError(`${txType}: invalid field ${String(paramNameStr)}`);\n  }\n}\nexports.validateOptionalField = validateOptionalField;\nvar GlobalFlags;\n(function (GlobalFlags) {\n  GlobalFlags[GlobalFlags[\"tfInnerBatchTxn\"] = 1073741824] = \"tfInnerBatchTxn\";\n})(GlobalFlags || (exports.GlobalFlags = GlobalFlags = {}));\nfunction validateBaseTransaction(common) {\n  if (!isRecord(common)) {\n    throw new errors_1.ValidationError('BaseTransaction: invalid, expected a valid object');\n  }\n  if (common.TransactionType === undefined) {\n    throw new errors_1.ValidationError('BaseTransaction: missing field TransactionType');\n  }\n  if (typeof common.TransactionType !== 'string') {\n    throw new errors_1.ValidationError('BaseTransaction: TransactionType not string');\n  }\n  if (!ripple_binary_codec_1.TRANSACTION_TYPES.includes(common.TransactionType)) {\n    throw new errors_1.ValidationError(`BaseTransaction: Unknown TransactionType ${common.TransactionType}`);\n  }\n  validateRequiredField(common, 'Account', isString);\n  validateOptionalField(common, 'Fee', isString);\n  validateOptionalField(common, 'Sequence', isNumber);\n  validateOptionalField(common, 'AccountTxnID', isString);\n  validateOptionalField(common, 'LastLedgerSequence', isNumber);\n  const memos = common.Memos;\n  if (memos != null && (!isArray(memos) || !memos.every(isMemo))) {\n    throw new errors_1.ValidationError('BaseTransaction: invalid Memos');\n  }\n  const signers = common.Signers;\n  if (signers != null && (!isArray(signers) || signers.length === 0 || !signers.every(isSigner))) {\n    throw new errors_1.ValidationError('BaseTransaction: invalid Signers');\n  }\n  validateOptionalField(common, 'SourceTag', isNumber);\n  validateOptionalField(common, 'SigningPubKey', isString);\n  validateOptionalField(common, 'TicketSequence', isNumber);\n  validateOptionalField(common, 'TxnSignature', isString);\n  validateOptionalField(common, 'NetworkID', isNumber);\n  validateOptionalField(common, 'Delegate', isAccount);\n  const delegate = common.Delegate;\n  if (delegate != null && delegate === common.Account) {\n    throw new errors_1.ValidationError('BaseTransaction: Account and Delegate addresses cannot be the same');\n  }\n}\nexports.validateBaseTransaction = validateBaseTransaction;\nfunction parseAmountValue(amount) {\n  if (!isAmount(amount)) {\n    return NaN;\n  }\n  if (typeof amount === 'string') {\n    return parseFloat(amount);\n  }\n  return parseFloat(amount.value);\n}\nexports.parseAmountValue = parseAmountValue;\nfunction validateCredentialType(tx) {\n  if (typeof tx.TransactionType !== 'string') {\n    throw new errors_1.ValidationError('Invalid TransactionType');\n  }\n  if (tx.CredentialType === undefined) {\n    throw new errors_1.ValidationError(`${tx.TransactionType}: missing field CredentialType`);\n  }\n  if (!isString(tx.CredentialType)) {\n    throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType must be a string`);\n  }\n  if (tx.CredentialType.length === 0) {\n    throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType cannot be an empty string`);\n  } else if (tx.CredentialType.length > MAX_CREDENTIAL_TYPE_LENGTH) {\n    throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType length cannot be > ${MAX_CREDENTIAL_TYPE_LENGTH}`);\n  }\n  if (!utils_1.HEX_REGEX.test(tx.CredentialType)) {\n    throw new errors_1.ValidationError(`${tx.TransactionType}: CredentialType must be encoded in hex`);\n  }\n}\nexports.validateCredentialType = validateCredentialType;\nfunction validateCredentialsList(credentials, transactionType, isStringID, maxCredentials) {\n  if (credentials == null) {\n    return;\n  }\n  if (!isArray(credentials)) {\n    throw new errors_1.ValidationError(`${transactionType}: Credentials must be an array`);\n  }\n  if (credentials.length > maxCredentials) {\n    throw new errors_1.ValidationError(`${transactionType}: Credentials length cannot exceed ${maxCredentials} elements`);\n  } else if (credentials.length === 0) {\n    throw new errors_1.ValidationError(`${transactionType}: Credentials cannot be an empty array`);\n  }\n  credentials.forEach(credential => {\n    if (isStringID) {\n      if (!isString(credential)) {\n        throw new errors_1.ValidationError(`${transactionType}: Invalid Credentials ID list format`);\n      }\n    } else if (!isAuthorizeCredential(credential)) {\n      throw new errors_1.ValidationError(`${transactionType}: Invalid Credentials format`);\n    }\n  });\n  if (containsDuplicates(credentials)) {\n    throw new errors_1.ValidationError(`${transactionType}: Credentials cannot contain duplicate elements`);\n  }\n}\nexports.validateCredentialsList = validateCredentialsList;\nfunction isAuthorizeCredentialArray(list) {\n  return typeof list[0] !== 'string';\n}\nfunction containsDuplicates(objectList) {\n  if (typeof objectList[0] === 'string') {\n    const objSet = new Set(objectList.map(obj => JSON.stringify(obj)));\n    return objSet.size !== objectList.length;\n  }\n  const seen = new Set();\n  if (isAuthorizeCredentialArray(objectList)) {\n    for (const item of objectList) {\n      const key = `${item.Credential.Issuer}-${item.Credential.CredentialType}`;\n      if (seen.has(key)) {\n        return true;\n      }\n      seen.add(key);\n    }\n  }\n  return false;\n}\nexports.containsDuplicates = containsDuplicates;\nconst _DOMAIN_ID_LENGTH = 64;\nfunction isDomainID(domainID) {\n  return isString(domainID) && domainID.length === _DOMAIN_ID_LENGTH && (0, utils_2.isHex)(domainID);\n}\nexports.isDomainID = isDomainID;","map":{"version":3,"names":["utils_1","require","ripple_address_codec_1","ripple_binary_codec_1","errors_1","utils_2","MEMO_SIZE","exports","MAX_AUTHORIZED_CREDENTIALS","MAX_CREDENTIAL_BYTE_LENGTH","MAX_CREDENTIAL_TYPE_LENGTH","SHA_512_HALF_LENGTH","VAULT_DATA_MAX_BYTE_LENGTH","isMemo","obj","isRecord","memo","Memo","size","Object","keys","length","validData","MemoData","isString","isHex","validFormat","MemoFormat","validType","MemoType","onlyHasFields","SIGNER_SIZE","isSigner","signer","Signer","Account","TxnSignature","SigningPubKey","XRP_CURRENCY_SIZE","MPT_CURRENCY_SIZE","ISSUE_CURRENCY_SIZE","MPT_CURRENCY_AMOUNT_SIZE","ISSUED_CURRENCY_AMOUNT_SIZE","XCHAIN_BRIDGE_SIZE","AUTHORIZE_CREDENTIAL_SIZE","value","Array","isArray","str","isNumber","num","isNull","inp","isValue","isValueInternal","isXRPLNumber","test","trim","isCurrency","input","issuer","currency","mpt_issuance_id","isIssuedCurrency","isIssuedCurrencyAmount","isAuthorizeCredential","Credential","CredentialType","Issuer","isMPTAmount","isClawbackAmount","isAccount","account","isValidClassicAddress","isValidXAddress","isAmount","amount","isTokenAmount","isXChainBridge","LockingChainDoor","LockingChainIssue","IssuingChainDoor","IssuingChainIssue","isLedgerEntryId","validateHexMetadata","lengthUpto","validateRequiredField","tx","param","checkValidity","errorOpts","paramNameStr","_a","paramName","txType","_b","TransactionType","ValidationError","String","validateOptionalField","undefined","GlobalFlags","validateBaseTransaction","common","TRANSACTION_TYPES","includes","memos","Memos","every","signers","Signers","delegate","Delegate","parseAmountValue","NaN","parseFloat","validateCredentialType","HEX_REGEX","validateCredentialsList","credentials","transactionType","isStringID","maxCredentials","forEach","credential","containsDuplicates","isAuthorizeCredentialArray","list","objectList","objSet","Set","map","JSON","stringify","seen","item","key","has","add","_DOMAIN_ID_LENGTH","isDomainID","domainID"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/models/transactions/common.ts"],"sourcesContent":["/* eslint-disable max-lines -- common utility file */\nimport { HEX_REGEX } from '@xrplf/isomorphic/utils'\nimport { isValidClassicAddress, isValidXAddress } from 'ripple-address-codec'\nimport { TRANSACTION_TYPES } from 'ripple-binary-codec'\n\nimport { ValidationError } from '../../errors'\nimport {\n  Amount,\n  AuthorizeCredential,\n  ClawbackAmount,\n  Currency,\n  IssuedCurrency,\n  IssuedCurrencyAmount,\n  MPTAmount,\n  Memo,\n  Signer,\n  XChainBridge,\n} from '../common'\nimport { isHex, onlyHasFields } from '../utils'\n\nconst MEMO_SIZE = 3\nexport const MAX_AUTHORIZED_CREDENTIALS = 8\nconst MAX_CREDENTIAL_BYTE_LENGTH = 64\nconst MAX_CREDENTIAL_TYPE_LENGTH = MAX_CREDENTIAL_BYTE_LENGTH * 2\nconst SHA_512_HALF_LENGTH = 64\n\n// Used for Vault transactions\nexport const VAULT_DATA_MAX_BYTE_LENGTH = 256\n\nfunction isMemo(obj: unknown): obj is Memo {\n  if (!isRecord(obj)) {\n    return false\n  }\n\n  const memo = obj.Memo\n  if (!isRecord(memo)) {\n    return false\n  }\n  const size = Object.keys(memo).length\n  const validData =\n    memo.MemoData == null || (isString(memo.MemoData) && isHex(memo.MemoData))\n  const validFormat =\n    memo.MemoFormat == null ||\n    (isString(memo.MemoFormat) && isHex(memo.MemoFormat))\n  const validType =\n    memo.MemoType == null || (isString(memo.MemoType) && isHex(memo.MemoType))\n\n  return (\n    size >= 1 &&\n    size <= MEMO_SIZE &&\n    validData &&\n    validFormat &&\n    validType &&\n    onlyHasFields(memo, ['MemoFormat', 'MemoData', 'MemoType'])\n  )\n}\n\nconst SIGNER_SIZE = 3\n\nfunction isSigner(obj: unknown): obj is Signer {\n  if (!isRecord(obj)) {\n    return false\n  }\n\n  const signer = obj.Signer\n  if (!isRecord(signer)) {\n    return false\n  }\n\n  return (\n    Object.keys(signer).length === SIGNER_SIZE &&\n    isString(signer.Account) &&\n    isString(signer.TxnSignature) &&\n    isString(signer.SigningPubKey)\n  )\n}\n\n// Currency object sizes\nconst XRP_CURRENCY_SIZE = 1\nconst MPT_CURRENCY_SIZE = 1\nconst ISSUE_CURRENCY_SIZE = 2\n\n// Currency Amount object sizes\nconst MPT_CURRENCY_AMOUNT_SIZE = 2\nconst ISSUED_CURRENCY_AMOUNT_SIZE = 3\n\nconst XCHAIN_BRIDGE_SIZE = 4\nconst AUTHORIZE_CREDENTIAL_SIZE = 1\n\n/**\n * Verify the form and type of a Record/Object at runtime.\n *\n * @param value - The object to check the form and type of.\n * @returns Whether the Record/Object is properly formed.\n */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === 'object' && !Array.isArray(value)\n}\n\n/**\n * Verify the form and type of a string at runtime.\n *\n * @param str - The object to check the form and type of.\n * @returns Whether the string is properly formed.\n */\nexport function isString(str: unknown): str is string {\n  return typeof str === 'string'\n}\n\n/**\n * Verify the form and type of a number at runtime.\n *\n * @param num - The object to check the form and type of.\n * @returns Whether the number is properly formed.\n */\nexport function isNumber(num: unknown): num is number {\n  return typeof num === 'number'\n}\n\n/**\n * Verify the form and type of a null value at runtime.\n *\n * @param inp - The value to check the form and type of.\n * @returns Whether the value is properly formed.\n */\nexport function isNull(inp: unknown): inp is null {\n  return inp == null\n}\n\n/**\n * Verify that a certain field has a certain exact value at runtime.\n *\n * @param value The value to compare against.\n * @returns Whether the number is properly formed and within the bounds.\n */\nexport function isValue<V>(value: V): (inp: unknown) => inp is V {\n  // eslint-disable-next-line func-style -- returning a function\n  const isValueInternal = (inp: unknown): inp is V => inp === value\n  return isValueInternal\n}\n\n/**\n * Checks whether the given value is a valid XRPL number string.\n * Accepts integer, decimal, or scientific notation strings.\n *\n * Examples of valid input:\n *   - \"123\"\n *   - \"-987.654\"\n *   - \"+3.14e10\"\n *   - \"-7.2e-9\"\n *\n * @param value - The value to check.\n * @returns True if value is a string that matches the XRPL number format, false otherwise.\n */\nexport function isXRPLNumber(value: unknown): value is XRPLNumber {\n  // Matches optional sign, digits, optional decimal, optional exponent (scientific)\n  // Allows leading zeros, but not empty string, lone sign, or missing digits\n  return (\n    typeof value === 'string' &&\n    /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][-+]?\\d+)?$/u.test(value.trim())\n  )\n}\n\n/**\n * Verify the form and type of a Currency at runtime.\n *\n * @param input - The input to check the form and type of.\n * @returns Whether the Currency is properly formed.\n */\nexport function isCurrency(input: unknown): input is Currency {\n  return (\n    isRecord(input) &&\n    ((Object.keys(input).length === ISSUE_CURRENCY_SIZE &&\n      isString(input.issuer) &&\n      isString(input.currency)) ||\n      (Object.keys(input).length === XRP_CURRENCY_SIZE &&\n        input.currency === 'XRP') ||\n      (Object.keys(input).length === MPT_CURRENCY_SIZE &&\n        isString(input.mpt_issuance_id)))\n  )\n}\n\n/**\n * Verify the form and type of an IssuedCurrency at runtime.\n *\n * @param input - The input to check the form and type of.\n * @returns Whether the IssuedCurrency is properly formed.\n */\nexport function isIssuedCurrency(input: unknown): input is IssuedCurrency {\n  return (\n    isRecord(input) &&\n    ((Object.keys(input).length === ISSUE_CURRENCY_SIZE &&\n      isString(input.issuer) &&\n      isString(input.currency)) ||\n      (Object.keys(input).length === XRP_CURRENCY_SIZE &&\n        input.currency === 'XRP'))\n  )\n}\n\n/**\n * Verify the form and type of an IssuedCurrencyAmount at runtime.\n *\n * @param input - The input to check the form and type of.\n * @returns Whether the IssuedCurrencyAmount is properly formed.\n */\nexport function isIssuedCurrencyAmount(\n  input: unknown,\n): input is IssuedCurrencyAmount {\n  return (\n    isRecord(input) &&\n    Object.keys(input).length === ISSUED_CURRENCY_AMOUNT_SIZE &&\n    isString(input.value) &&\n    isString(input.issuer) &&\n    isString(input.currency)\n  )\n}\n\n/**\n * Verify the form and type of an AuthorizeCredential at runtime\n *\n * @param input - The input to check the form and type of\n * @returns Whether the AuthorizeCredential is properly formed\n */\nexport function isAuthorizeCredential(\n  input: unknown,\n): input is AuthorizeCredential {\n  return (\n    isRecord(input) &&\n    isRecord(input.Credential) &&\n    Object.keys(input).length === AUTHORIZE_CREDENTIAL_SIZE &&\n    typeof input.Credential.CredentialType === 'string' &&\n    typeof input.Credential.Issuer === 'string'\n  )\n}\n\n/**\n * Verify the form and type of an MPT at runtime.\n *\n * @param input - The input to check the form and type of.\n * @returns Whether the MPTAmount is properly formed.\n */\nexport function isMPTAmount(input: unknown): input is MPTAmount {\n  return (\n    isRecord(input) &&\n    Object.keys(input).length === MPT_CURRENCY_AMOUNT_SIZE &&\n    typeof input.value === 'string' &&\n    typeof input.mpt_issuance_id === 'string'\n  )\n}\n\n/**\n * Type guard to verify if the input is a valid ClawbackAmount.\n *\n * A ClawbackAmount can be either an {@link IssuedCurrencyAmount} or an {@link MPTAmount}.\n * This function checks if the input matches either type.\n *\n * @param input - The value to check for ClawbackAmount structure.\n * @returns True if the input is an IssuedCurrencyAmount or MPTAmount, otherwise false.\n */\nexport function isClawbackAmount(input: unknown): input is ClawbackAmount {\n  return isIssuedCurrencyAmount(input) || isMPTAmount(input)\n}\n\n/**\n * Must be a valid account address\n */\nexport type Account = string\n\n/**\n * XRPL Number type represented as a string.\n *\n * This string can be an integer (e.g., \"123\"), a decimal (e.g., \"123.45\"),\n * or in scientific notation (e.g., \"1.23e5\", \"-4.56e-7\").\n * Used for fields that accept arbitrary-precision numbers in XRPL transactions and ledger objects.\n */\nexport type XRPLNumber = string\n\n/**\n * Verify a string is in fact a valid account address.\n *\n * @param account - The object to check the form and type of.\n * @returns Whether the account is properly formed account for a transaction.\n */\nexport function isAccount(account: unknown): account is Account {\n  return (\n    typeof account === 'string' &&\n    (isValidClassicAddress(account) || isValidXAddress(account))\n  )\n}\n\n/**\n * Verify the form and type of an Amount at runtime.\n *\n * @param amount - The object to check the form and type of.\n * @returns Whether the Amount is properly formed.\n */\nexport function isAmount(amount: unknown): amount is Amount {\n  return (\n    typeof amount === 'string' ||\n    isIssuedCurrencyAmount(amount) ||\n    isMPTAmount(amount)\n  )\n}\n\n/**\n * Verify the form and type of IOU/MPT token amount at runtime.\n *\n * @param amount - The object to check the form and type of.\n * @returns Whether the Amount is properly formed.\n */\nexport function isTokenAmount(\n  amount: unknown,\n): amount is IssuedCurrencyAmount | MPTAmount {\n  return isIssuedCurrencyAmount(amount) || isMPTAmount(amount)\n}\n\n/**\n * Verify the form and type of an XChainBridge at runtime.\n *\n * @param input - The input to check the form and type of.\n * @returns Whether the XChainBridge is properly formed.\n */\nexport function isXChainBridge(input: unknown): input is XChainBridge {\n  return (\n    isRecord(input) &&\n    Object.keys(input).length === XCHAIN_BRIDGE_SIZE &&\n    typeof input.LockingChainDoor === 'string' &&\n    isIssuedCurrency(input.LockingChainIssue) &&\n    typeof input.IssuingChainDoor === 'string' &&\n    isIssuedCurrency(input.IssuingChainIssue)\n  )\n}\n\n/**\n * Verify the form and type of an Array at runtime.\n *\n * @param input - The object to check the form and type of.\n * @returns Whether the Array is properly formed.\n */\nexport function isArray<T = unknown>(input: unknown): input is T[] {\n  return input != null && Array.isArray(input)\n}\n\n/**\n * Verify the input is a valid ledger entry id.\n *\n * @param input - The object to validate.\n * @returns Whether the input is a valid ledger entry id.\n */\nexport function isLedgerEntryId(input: unknown): input is string {\n  return isString(input) && isHex(input) && input.length === SHA_512_HALF_LENGTH\n}\n\n/**\n * Validate input is non-empty hex string of up to a certain length.\n *\n * @param input - The metadata to validate.\n * @param lengthUpto - The maximum length of the hex string.\n * @returns Whether the input is a valid non-empty hex string up to the specified length.\n */\nexport function validateHexMetadata(\n  input: unknown,\n  lengthUpto: number,\n): input is string {\n  return (\n    isString(input) &&\n    isHex(input) &&\n    input.length > 0 &&\n    input.length <= lengthUpto\n  )\n}\n\n/* eslint-disable @typescript-eslint/restrict-template-expressions -- tx.TransactionType is checked before any calls */\n\n/**\n * Verify the form and type of a required type for a transaction at runtime.\n *\n * @param tx - The object input to check the form and type of.\n * @param param - The object parameter.\n * @param checkValidity - The function to use to check the type.\n * @param errorOpts - Extra values to make the error message easier to understand.\n * @param errorOpts.txType - The transaction type throwing the error.\n * @param errorOpts.paramName - The name of the parameter in the transaction with the error.\n * @throws ValidationError if the parameter is missing or invalid.\n */\n// eslint-disable-next-line max-params -- helper function\nexport function validateRequiredField<\n  T extends Record<string, unknown>,\n  K extends keyof T,\n  V,\n>(\n  tx: T,\n  param: K,\n  checkValidity: (inp: unknown) => inp is V,\n  errorOpts: {\n    txType?: string\n    paramName?: string\n  } = {},\n): asserts tx is T & { [P in K]: V } {\n  const paramNameStr = errorOpts.paramName ?? param\n  const txType = errorOpts.txType ?? tx.TransactionType\n  if (tx[param] == null) {\n    throw new ValidationError(\n      `${txType}: missing field ${String(paramNameStr)}`,\n    )\n  }\n\n  if (!checkValidity(tx[param])) {\n    throw new ValidationError(\n      `${txType}: invalid field ${String(paramNameStr)}`,\n    )\n  }\n}\n\n/**\n * Verify the form and type of an optional type for a transaction at runtime.\n *\n * @param tx - The transaction input to check the form and type of.\n * @param param - The object parameter.\n * @param checkValidity - The function to use to check the type.\n * @param errorOpts - Extra values to make the error message easier to understand.\n * @param errorOpts.txType - The transaction type throwing the error.\n * @param errorOpts.paramName - The name of the parameter in the transaction with the error.\n * @throws ValidationError if the parameter is invalid.\n */\n// eslint-disable-next-line max-params -- helper function\nexport function validateOptionalField<\n  T extends Record<string, unknown>,\n  K extends keyof T,\n  V,\n>(\n  tx: T,\n  param: K,\n  checkValidity: (inp: unknown) => inp is V,\n  errorOpts: {\n    txType?: string\n    paramName?: string\n  } = {},\n): asserts tx is T & { [P in K]: V | undefined } {\n  const paramNameStr = errorOpts.paramName ?? param\n  const txType = errorOpts.txType ?? tx.TransactionType\n  if (tx[param] !== undefined && !checkValidity(tx[param])) {\n    throw new ValidationError(\n      `${txType}: invalid field ${String(paramNameStr)}`,\n    )\n  }\n}\n\n/* eslint-enable @typescript-eslint/restrict-template-expressions -- checked before */\n\nexport enum GlobalFlags {\n  tfInnerBatchTxn = 0x40000000,\n}\n\nexport interface GlobalFlagsInterface {\n  tfInnerBatchTxn?: boolean\n}\n\n/**\n * Every transaction has the same set of common fields.\n */\nexport interface BaseTransaction extends Record<string, unknown> {\n  /** The unique address of the transaction sender. */\n  Account: Account\n  /**\n   * The type of transaction. Valid types include: `Payment`, `OfferCreate`,\n   * `TrustSet`, and many others.\n   */\n  TransactionType: string\n  /**\n   * Integer amount of XRP, in drops, to be destroyed as a cost for\n   * distributing this transaction to the network. Some transaction types have\n   * different minimum requirements.\n   */\n  Fee?: string\n  /**\n   * The sequence number of the account sending the transaction. A transaction\n   * is only valid if the Sequence number is exactly 1 greater than the previous\n   * transaction from the same account. The special case 0 means the transaction\n   * is using a Ticket instead.\n   */\n  Sequence?: number\n  /**\n   * Hash value identifying another transaction. If provided, this transaction\n   * is only valid if the sending account's previously-sent transaction matches\n   * the provided hash.\n   */\n  AccountTxnID?: string\n  /** Set of bit-flags for this transaction. */\n  Flags?: number | GlobalFlagsInterface\n  /**\n   * Highest ledger index this transaction can appear in. Specifying this field\n   * places a strict upper limit on how long the transaction can wait to be\n   * validated or rejected.\n   */\n  LastLedgerSequence?: number\n  /**\n   * Additional arbitrary information used to identify this transaction.\n   */\n  Memos?: Memo[]\n  /**\n   * Array of objects that represent a multi-signature which authorizes this\n   * transaction.\n   */\n  Signers?: Signer[]\n  /**\n   * Arbitrary integer used to identify the reason for this payment, or a sender\n   * on whose behalf this transaction is made. Conventionally, a refund should\n   * specify the initial payment's SourceTag as the refund payment's\n   * DestinationTag.\n   */\n  SourceTag?: number\n  /**\n   * Hex representation of the public key that corresponds to the private key\n   * used to sign this transaction. If an empty string, indicates a\n   * multi-signature is present in the Signers field instead.\n   */\n  SigningPubKey?: string\n  /**\n   * The sequence number of the ticket to use in place of a Sequence number. If\n   * this is provided, Sequence must be 0. Cannot be used with AccountTxnID.\n   */\n  TicketSequence?: number\n  /**\n   * The signature that verifies this transaction as originating from the\n   * account it says it is from.\n   */\n  TxnSignature?: string\n  /**\n   * The network id of the transaction.\n   */\n  NetworkID?: number\n  /**\n   * The delegate account that is sending the transaction.\n   */\n  Delegate?: Account\n}\n\n/**\n * Verify the common fields of a transaction. The validate functionality will be\n * optional, and will check transaction form at runtime. This should be called\n * any time a transaction will be verified.\n *\n * @param common - An interface w/ common transaction fields.\n * @throws When the common param is malformed.\n */\n// eslint-disable-next-line max-statements, max-lines-per-function -- lines required for validation\nexport function validateBaseTransaction(\n  common: unknown,\n): asserts common is BaseTransaction {\n  if (!isRecord(common)) {\n    throw new ValidationError(\n      'BaseTransaction: invalid, expected a valid object',\n    )\n  }\n\n  if (common.TransactionType === undefined) {\n    throw new ValidationError('BaseTransaction: missing field TransactionType')\n  }\n\n  if (typeof common.TransactionType !== 'string') {\n    throw new ValidationError('BaseTransaction: TransactionType not string')\n  }\n\n  if (!TRANSACTION_TYPES.includes(common.TransactionType)) {\n    throw new ValidationError(\n      `BaseTransaction: Unknown TransactionType ${common.TransactionType}`,\n    )\n  }\n\n  validateRequiredField(common, 'Account', isString)\n\n  validateOptionalField(common, 'Fee', isString)\n\n  validateOptionalField(common, 'Sequence', isNumber)\n\n  validateOptionalField(common, 'AccountTxnID', isString)\n\n  validateOptionalField(common, 'LastLedgerSequence', isNumber)\n\n  const memos = common.Memos\n  if (memos != null && (!isArray(memos) || !memos.every(isMemo))) {\n    throw new ValidationError('BaseTransaction: invalid Memos')\n  }\n\n  const signers = common.Signers\n\n  if (\n    signers != null &&\n    (!isArray(signers) || signers.length === 0 || !signers.every(isSigner))\n  ) {\n    throw new ValidationError('BaseTransaction: invalid Signers')\n  }\n\n  validateOptionalField(common, 'SourceTag', isNumber)\n\n  validateOptionalField(common, 'SigningPubKey', isString)\n\n  validateOptionalField(common, 'TicketSequence', isNumber)\n\n  validateOptionalField(common, 'TxnSignature', isString)\n\n  validateOptionalField(common, 'NetworkID', isNumber)\n\n  validateOptionalField(common, 'Delegate', isAccount)\n\n  const delegate = common.Delegate\n  if (delegate != null && delegate === common.Account) {\n    throw new ValidationError(\n      'BaseTransaction: Account and Delegate addresses cannot be the same',\n    )\n  }\n}\n\n/**\n * Parse the value of an amount, expressed either in XRP or as an Issued Currency, into a number.\n *\n * @param amount - An Amount to parse for its value.\n * @returns The parsed amount value, or NaN if the amount count not be parsed.\n */\nexport function parseAmountValue(amount: unknown): number {\n  if (!isAmount(amount)) {\n    return NaN\n  }\n  if (typeof amount === 'string') {\n    return parseFloat(amount)\n  }\n  return parseFloat(amount.value)\n}\n\n/**\n * Verify the form and type of a CredentialType at runtime.\n *\n * @param tx A CredentialType Transaction.\n * @throws when the CredentialType is malformed.\n */\nexport function validateCredentialType<\n  T extends BaseTransaction & Record<string, unknown>,\n>(tx: T): void {\n  if (typeof tx.TransactionType !== 'string') {\n    throw new ValidationError('Invalid TransactionType')\n  }\n  if (tx.CredentialType === undefined) {\n    throw new ValidationError(\n      `${tx.TransactionType}: missing field CredentialType`,\n    )\n  }\n\n  if (!isString(tx.CredentialType)) {\n    throw new ValidationError(\n      `${tx.TransactionType}: CredentialType must be a string`,\n    )\n  }\n  if (tx.CredentialType.length === 0) {\n    throw new ValidationError(\n      `${tx.TransactionType}: CredentialType cannot be an empty string`,\n    )\n  } else if (tx.CredentialType.length > MAX_CREDENTIAL_TYPE_LENGTH) {\n    throw new ValidationError(\n      `${tx.TransactionType}: CredentialType length cannot be > ${MAX_CREDENTIAL_TYPE_LENGTH}`,\n    )\n  }\n\n  if (!HEX_REGEX.test(tx.CredentialType)) {\n    throw new ValidationError(\n      `${tx.TransactionType}: CredentialType must be encoded in hex`,\n    )\n  }\n}\n\n/**\n * Check a CredentialAuthorize array for parameter errors\n *\n * @param credentials An array of credential IDs to check for errors\n * @param transactionType The transaction type to include in error messages\n * @param isStringID Toggle for if array contains IDs instead of AuthorizeCredential objects\n * @param maxCredentials The maximum length of the credentials array.\n *        PermissionedDomainSet transaction uses 10, other transactions use 8.\n * @throws Validation Error if the formatting is incorrect\n */\n// eslint-disable-next-line max-params, max-lines-per-function -- separating logic further will add unnecessary complexity\nexport function validateCredentialsList(\n  credentials: unknown,\n  transactionType: string,\n  isStringID: boolean,\n  maxCredentials: number,\n): void {\n  if (credentials == null) {\n    return\n  }\n  if (!isArray(credentials)) {\n    throw new ValidationError(\n      `${transactionType}: Credentials must be an array`,\n    )\n  }\n  if (credentials.length > maxCredentials) {\n    throw new ValidationError(\n      `${transactionType}: Credentials length cannot exceed ${maxCredentials} elements`,\n    )\n  } else if (credentials.length === 0) {\n    throw new ValidationError(\n      `${transactionType}: Credentials cannot be an empty array`,\n    )\n  }\n  credentials.forEach((credential) => {\n    if (isStringID) {\n      if (!isString(credential)) {\n        throw new ValidationError(\n          `${transactionType}: Invalid Credentials ID list format`,\n        )\n      }\n    } else if (!isAuthorizeCredential(credential)) {\n      throw new ValidationError(\n        `${transactionType}: Invalid Credentials format`,\n      )\n    }\n  })\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- checked above\n  if (containsDuplicates(credentials as string[] | AuthorizeCredential[])) {\n    throw new ValidationError(\n      `${transactionType}: Credentials cannot contain duplicate elements`,\n    )\n  }\n}\n\n// Type guard to ensure we're working with AuthorizeCredential[]\n// Note: This is not a rigorous type-guard. A more thorough solution would be to iterate over the array and check each item.\nfunction isAuthorizeCredentialArray(\n  list: AuthorizeCredential[] | string[],\n): list is AuthorizeCredential[] {\n  return typeof list[0] !== 'string'\n}\n\n/**\n * Check if an array of objects contains any duplicates.\n *\n * @param objectList - Array of objects to check for duplicates\n * @returns True if duplicates exist, false otherwise\n */\nexport function containsDuplicates(\n  objectList: AuthorizeCredential[] | string[],\n): boolean {\n  // Case-1: Process a list of string-IDs\n  if (typeof objectList[0] === 'string') {\n    const objSet = new Set(objectList.map((obj) => JSON.stringify(obj)))\n    return objSet.size !== objectList.length\n  }\n\n  // Case-2: Process a list of nested objects\n  const seen = new Set<string>()\n\n  if (isAuthorizeCredentialArray(objectList)) {\n    for (const item of objectList) {\n      const key = `${item.Credential.Issuer}-${item.Credential.CredentialType}`\n      if (seen.has(key)) {\n        return true\n      }\n      seen.add(key)\n    }\n  }\n\n  return false\n}\n\nconst _DOMAIN_ID_LENGTH = 64\n\n/**\n * Utility method used across OfferCreate and Payment transactions to validate the DomainID.\n *\n * @param domainID - The domainID is a 64-character string that is used to identify a domain.\n *\n * @returns true if the domainID is a valid 64-character string, false otherwise\n */\nexport function isDomainID(domainID: unknown): domainID is string {\n  return (\n    isString(domainID) &&\n    domainID.length === _DOMAIN_ID_LENGTH &&\n    isHex(domainID)\n  )\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}