{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"@noble/curves/abstract/utils\");\nconst secp256k1_1 = require(\"@noble/curves/secp256k1\");\nconst utils_2 = require(\"@xrplf/isomorphic/utils\");\nconst utils_3 = require(\"./utils\");\nconst assert_1 = __importDefault(require(\"../../utils/assert\"));\nconst Sha512_1 = __importDefault(require(\"../../utils/Sha512\"));\nconst SECP256K1_PREFIX = '00';\nconst secp256k1 = {\n  deriveKeypair(entropy, options) {\n    const derived = (0, utils_3.derivePrivateKey)(entropy, options);\n    const privateKey = SECP256K1_PREFIX + (0, utils_2.bytesToHex)((0, utils_1.numberToBytesBE)(derived, 32));\n    const publicKey = (0, utils_2.bytesToHex)(secp256k1_1.secp256k1.getPublicKey(derived, true));\n    return {\n      privateKey,\n      publicKey\n    };\n  },\n  sign(message, privateKey) {\n    // Some callers pass the privateKey with the prefix, others without.\n    // @noble/curves will throw if the key is not exactly 32 bytes, so we\n    // normalize it before passing to the sign method.\n    assert_1.default.ok(privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX) || privateKey.length === 64);\n    const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;\n    return secp256k1_1.secp256k1.sign(Sha512_1.default.half(message), normedPrivateKey, {\n      // \"Canonical\" signatures\n      lowS: true,\n      // Would fail tests if signatures aren't deterministic\n      extraEntropy: undefined\n    }).toDERHex(true).toUpperCase();\n  },\n  verify(message, signature, publicKey) {\n    const decoded = secp256k1_1.secp256k1.Signature.fromDER(signature);\n    return secp256k1_1.secp256k1.verify(decoded, Sha512_1.default.half(message), publicKey);\n  }\n};\nexports.default = secp256k1;","map":{"version":3,"names":["utils_1","require","secp256k1_1","utils_2","utils_3","assert_1","__importDefault","Sha512_1","SECP256K1_PREFIX","secp256k1","deriveKeypair","entropy","options","derived","derivePrivateKey","privateKey","bytesToHex","numberToBytesBE","publicKey","getPublicKey","sign","message","default","ok","length","startsWith","normedPrivateKey","slice","half","lowS","extraEntropy","undefined","toDERHex","toUpperCase","verify","signature","decoded","Signature","fromDER","exports"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/ripple-keypairs/src/signing-schemes/secp256k1/index.ts"],"sourcesContent":["import { numberToBytesBE } from '@noble/curves/abstract/utils'\nimport { secp256k1 as nobleSecp256k1 } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\n\nimport type {\n  DeriveKeyPairOptions,\n  HexString,\n  SigningScheme,\n} from '../../types'\n\nimport { derivePrivateKey } from './utils'\nimport assert from '../../utils/assert'\nimport Sha512 from '../../utils/Sha512'\n\nconst SECP256K1_PREFIX = '00'\n\nconst secp256k1: SigningScheme = {\n  deriveKeypair(\n    entropy: Uint8Array,\n    options?: DeriveKeyPairOptions,\n  ): {\n    privateKey: string\n    publicKey: string\n  } {\n    const derived = derivePrivateKey(entropy, options)\n    const privateKey =\n      SECP256K1_PREFIX + bytesToHex(numberToBytesBE(derived, 32))\n\n    const publicKey = bytesToHex(nobleSecp256k1.getPublicKey(derived, true))\n    return { privateKey, publicKey }\n  },\n\n  sign(message: Uint8Array, privateKey: HexString): string {\n    // Some callers pass the privateKey with the prefix, others without.\n    // @noble/curves will throw if the key is not exactly 32 bytes, so we\n    // normalize it before passing to the sign method.\n    assert.ok(\n      (privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX)) ||\n        privateKey.length === 64,\n    )\n    const normedPrivateKey =\n      privateKey.length === 66 ? privateKey.slice(2) : privateKey\n    return nobleSecp256k1\n      .sign(Sha512.half(message), normedPrivateKey, {\n        // \"Canonical\" signatures\n        lowS: true,\n        // Would fail tests if signatures aren't deterministic\n        extraEntropy: undefined,\n      })\n      .toDERHex(true)\n      .toUpperCase()\n  },\n\n  verify(\n    message: Uint8Array,\n    signature: HexString,\n    publicKey: HexString,\n  ): boolean {\n    const decoded = nobleSecp256k1.Signature.fromDER(signature)\n    return nobleSecp256k1.verify(decoded, Sha512.half(message), publicKey)\n  },\n}\n\nexport default secp256k1\n"],"mappings":";;;;;;;;;;AAAA,MAAAA,OAAA,GAAAC,OAAA;AACA,MAAAC,WAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AAQA,MAAAG,OAAA,GAAAH,OAAA;AACA,MAAAI,QAAA,GAAAC,eAAA,CAAAL,OAAA;AACA,MAAAM,QAAA,GAAAD,eAAA,CAAAL,OAAA;AAEA,MAAMO,gBAAgB,GAAG,IAAI;AAE7B,MAAMC,SAAS,GAAkB;EAC/BC,aAAaA,CACXC,OAAmB,EACnBC,OAA8B;IAK9B,MAAMC,OAAO,GAAG,IAAAT,OAAA,CAAAU,gBAAgB,EAACH,OAAO,EAAEC,OAAO,CAAC;IAClD,MAAMG,UAAU,GACdP,gBAAgB,GAAG,IAAAL,OAAA,CAAAa,UAAU,EAAC,IAAAhB,OAAA,CAAAiB,eAAe,EAACJ,OAAO,EAAE,EAAE,CAAC,CAAC;IAE7D,MAAMK,SAAS,GAAG,IAAAf,OAAA,CAAAa,UAAU,EAACd,WAAA,CAAAO,SAAc,CAACU,YAAY,CAACN,OAAO,EAAE,IAAI,CAAC,CAAC;IACxE,OAAO;MAAEE,UAAU;MAAEG;IAAS,CAAE;EAClC,CAAC;EAEDE,IAAIA,CAACC,OAAmB,EAAEN,UAAqB;IAC7C;IACA;IACA;IACAV,QAAA,CAAAiB,OAAM,CAACC,EAAE,CACNR,UAAU,CAACS,MAAM,KAAK,EAAE,IAAIT,UAAU,CAACU,UAAU,CAACjB,gBAAgB,CAAC,IAClEO,UAAU,CAACS,MAAM,KAAK,EAAE,CAC3B;IACD,MAAME,gBAAgB,GACpBX,UAAU,CAACS,MAAM,KAAK,EAAE,GAAGT,UAAU,CAACY,KAAK,CAAC,CAAC,CAAC,GAAGZ,UAAU;IAC7D,OAAOb,WAAA,CAAAO,SAAc,CAClBW,IAAI,CAACb,QAAA,CAAAe,OAAM,CAACM,IAAI,CAACP,OAAO,CAAC,EAAEK,gBAAgB,EAAE;MAC5C;MACAG,IAAI,EAAE,IAAI;MACV;MACAC,YAAY,EAAEC;KACf,CAAC,CACDC,QAAQ,CAAC,IAAI,CAAC,CACdC,WAAW,EAAE;EAClB,CAAC;EAEDC,MAAMA,CACJb,OAAmB,EACnBc,SAAoB,EACpBjB,SAAoB;IAEpB,MAAMkB,OAAO,GAAGlC,WAAA,CAAAO,SAAc,CAAC4B,SAAS,CAACC,OAAO,CAACH,SAAS,CAAC;IAC3D,OAAOjC,WAAA,CAAAO,SAAc,CAACyB,MAAM,CAACE,OAAO,EAAE7B,QAAA,CAAAe,OAAM,CAACM,IAAI,CAACP,OAAO,CAAC,EAAEH,SAAS,CAAC;EACxE;CACD;AAEDqB,OAAA,CAAAjB,OAAA,GAAeb,SAAS","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}