{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Issue = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst binary_parser_1 = require(\"../serdes/binary-parser\");\nconst account_id_1 = require(\"./account-id\");\nconst currency_1 = require(\"./currency\");\nconst serialized_type_1 = require(\"./serialized-type\");\nconst hash_192_1 = require(\"./hash-192\");\nconst utils_2 = require(\"../utils\");\n/**\n * Type guard for Issue Object\n */\nfunction isIssueObject(arg) {\n  const keys = Object.keys(arg).sort();\n  const isXRP = keys.length === 1 && keys[0] === 'currency';\n  const isIOU = keys.length === 2 && keys[0] === 'currency' && keys[1] === 'issuer';\n  const isMPT = keys.length === 1 && keys[0] === 'mpt_issuance_id';\n  return isXRP || isIOU || isMPT;\n}\nconst MPT_WIDTH = 44;\nconst NO_ACCOUNT = account_id_1.AccountID.from('0000000000000000000000000000000000000001');\n/**\n * Class for serializing/Deserializing Issue\n */\nclass Issue extends serialized_type_1.SerializedType {\n  constructor(bytes) {\n    super(bytes !== null && bytes !== void 0 ? bytes : Issue.XRP_ISSUE.bytes);\n  }\n  /**\n   * Construct Issue from XRPIssue, IOUIssue or MPTIssue\n   *\n   * @param value An object representing an XRPIssue, IOUIssue or MPTIssue\n   * @returns An Issue object\n   */\n  static from(value) {\n    if (value instanceof Issue) {\n      return value;\n    }\n    if (isIssueObject(value)) {\n      if (value.currency) {\n        const currency = currency_1.Currency.from(value.currency.toString()).toBytes();\n        //IOU case\n        if (value.issuer) {\n          const issuer = account_id_1.AccountID.from(value.issuer.toString()).toBytes();\n          return new Issue((0, utils_1.concat)([currency, issuer]));\n        }\n        //XRP case\n        return new Issue(currency);\n      }\n      // MPT case\n      if (value.mpt_issuance_id) {\n        const mptIssuanceIdBytes = hash_192_1.Hash192.from(value.mpt_issuance_id.toString()).toBytes();\n        const issuerAccount = mptIssuanceIdBytes.slice(4);\n        const sequence = Number((0, utils_2.readUInt32BE)(mptIssuanceIdBytes.slice(0, 4), 0)); // sequence is in Big-endian format in mpt_issuance_id\n        // Convert to Little-endian\n        const sequenceBuffer = new Uint8Array(4);\n        new DataView(sequenceBuffer.buffer).setUint32(0, sequence, true);\n        return new Issue((0, utils_1.concat)([issuerAccount, NO_ACCOUNT.toBytes(), sequenceBuffer]));\n      }\n    }\n    throw new Error('Invalid type to construct an Issue');\n  }\n  /**\n   * Read Issue from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Issue from\n   *\n   * @returns An Issue object\n   */\n  static fromParser(parser) {\n    // XRP\n    const currencyOrAccount = parser.read(20);\n    if (new currency_1.Currency(currencyOrAccount).toJSON() === 'XRP') {\n      return new Issue(currencyOrAccount);\n    }\n    // MPT\n    const issuerAccountId = new account_id_1.AccountID(parser.read(20));\n    if (NO_ACCOUNT.toHex() === issuerAccountId.toHex()) {\n      const sequence = parser.read(4);\n      return new Issue((0, utils_1.concat)([currencyOrAccount, NO_ACCOUNT.toBytes(), sequence]));\n    }\n    // IOU\n    return new Issue((0, utils_1.concat)([currencyOrAccount, issuerAccountId.toBytes()]));\n  }\n  /**\n   * Get the JSON representation of this IssueObject\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON() {\n    // If the buffer is exactly 44 bytes, treat it as an MPTIssue.\n    if (this.toBytes().length === MPT_WIDTH) {\n      const issuerAccount = this.toBytes().slice(0, 20);\n      const sequence = new DataView(this.toBytes().slice(40).buffer).getUint32(0, true);\n      // sequence part of mpt_issuance_id should be in Big-endian\n      const sequenceBuffer = new Uint8Array(4);\n      (0, utils_2.writeUInt32BE)(sequenceBuffer, sequence, 0);\n      return {\n        mpt_issuance_id: (0, utils_1.bytesToHex)((0, utils_1.concat)([sequenceBuffer, issuerAccount]))\n      };\n    }\n    const parser = new binary_parser_1.BinaryParser(this.toString());\n    const currency = currency_1.Currency.fromParser(parser);\n    if (currency.toJSON() === 'XRP') {\n      return {\n        currency: currency.toJSON()\n      };\n    }\n    const issuer = account_id_1.AccountID.fromParser(parser);\n    return {\n      currency: currency.toJSON(),\n      issuer: issuer.toJSON()\n    };\n  }\n}\nexports.Issue = Issue;\nIssue.XRP_ISSUE = new Issue(new Uint8Array(20));","map":{"version":3,"names":["utils_1","require","binary_parser_1","account_id_1","currency_1","serialized_type_1","hash_192_1","utils_2","isIssueObject","arg","keys","Object","sort","isXRP","length","isIOU","isMPT","MPT_WIDTH","NO_ACCOUNT","AccountID","from","Issue","SerializedType","constructor","bytes","XRP_ISSUE","value","currency","Currency","toString","toBytes","issuer","concat","mpt_issuance_id","mptIssuanceIdBytes","Hash192","issuerAccount","slice","sequence","Number","readUInt32BE","sequenceBuffer","Uint8Array","DataView","buffer","setUint32","Error","fromParser","parser","currencyOrAccount","read","toJSON","issuerAccountId","toHex","getUint32","writeUInt32BE","bytesToHex","BinaryParser","exports"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/ripple-binary-codec/src/types/issue.ts"],"sourcesContent":["import { bytesToHex, concat } from '@xrplf/isomorphic/utils'\nimport { BinaryParser } from '../serdes/binary-parser'\n\nimport { AccountID } from './account-id'\nimport { Currency } from './currency'\nimport { JsonObject, SerializedType } from './serialized-type'\nimport { Hash192 } from './hash-192'\nimport { readUInt32BE, writeUInt32BE } from '../utils'\n\ninterface XRPIssue extends JsonObject {\n  currency: string\n}\n\ninterface IOUIssue extends JsonObject {\n  currency: string\n  issuer: string\n}\ninterface MPTIssue extends JsonObject {\n  mpt_issuance_id: string\n}\n/**\n * Interface for JSON objects that represent issues\n */\ntype IssueObject = XRPIssue | IOUIssue | MPTIssue\n\n/**\n * Type guard for Issue Object\n */\nfunction isIssueObject(arg): arg is IssueObject {\n  const keys = Object.keys(arg).sort()\n  const isXRP = keys.length === 1 && keys[0] === 'currency'\n  const isIOU =\n    keys.length === 2 && keys[0] === 'currency' && keys[1] === 'issuer'\n  const isMPT = keys.length === 1 && keys[0] === 'mpt_issuance_id'\n\n  return isXRP || isIOU || isMPT\n}\n\nconst MPT_WIDTH = 44\nconst NO_ACCOUNT = AccountID.from('0000000000000000000000000000000000000001')\n\n/**\n * Class for serializing/Deserializing Issue\n */\nclass Issue extends SerializedType {\n  static readonly XRP_ISSUE: Issue = new Issue(new Uint8Array(20))\n\n  constructor(bytes: Uint8Array) {\n    super(bytes ?? Issue.XRP_ISSUE.bytes)\n  }\n\n  /**\n   * Construct Issue from XRPIssue, IOUIssue or MPTIssue\n   *\n   * @param value An object representing an XRPIssue, IOUIssue or MPTIssue\n   * @returns An Issue object\n   */\n  static from<T extends Issue | IssueObject>(value: T): Issue {\n    if (value instanceof Issue) {\n      return value\n    }\n\n    if (isIssueObject(value)) {\n      if (value.currency) {\n        const currency = Currency.from(value.currency.toString()).toBytes()\n\n        //IOU case\n        if (value.issuer) {\n          const issuer = AccountID.from(value.issuer.toString()).toBytes()\n          return new Issue(concat([currency, issuer]))\n        }\n\n        //XRP case\n        return new Issue(currency)\n      }\n\n      // MPT case\n      if (value.mpt_issuance_id) {\n        const mptIssuanceIdBytes = Hash192.from(\n          value.mpt_issuance_id.toString(),\n        ).toBytes()\n        const issuerAccount = mptIssuanceIdBytes.slice(4)\n        const sequence = Number(readUInt32BE(mptIssuanceIdBytes.slice(0, 4), 0)) // sequence is in Big-endian format in mpt_issuance_id\n\n        // Convert to Little-endian\n        const sequenceBuffer = new Uint8Array(4)\n        new DataView(sequenceBuffer.buffer).setUint32(0, sequence, true)\n\n        return new Issue(\n          concat([issuerAccount, NO_ACCOUNT.toBytes(), sequenceBuffer]),\n        )\n      }\n    }\n\n    throw new Error('Invalid type to construct an Issue')\n  }\n\n  /**\n   * Read Issue from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Issue from\n   *\n   * @returns An Issue object\n   */\n  static fromParser(parser: BinaryParser): Issue {\n    // XRP\n    const currencyOrAccount = parser.read(20)\n    if (new Currency(currencyOrAccount).toJSON() === 'XRP') {\n      return new Issue(currencyOrAccount)\n    }\n\n    // MPT\n    const issuerAccountId = new AccountID(parser.read(20))\n    if (NO_ACCOUNT.toHex() === issuerAccountId.toHex()) {\n      const sequence = parser.read(4)\n      return new Issue(\n        concat([currencyOrAccount, NO_ACCOUNT.toBytes(), sequence]),\n      )\n    }\n\n    // IOU\n    return new Issue(concat([currencyOrAccount, issuerAccountId.toBytes()]))\n  }\n\n  /**\n   * Get the JSON representation of this IssueObject\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON(): IssueObject {\n    // If the buffer is exactly 44 bytes, treat it as an MPTIssue.\n    if (this.toBytes().length === MPT_WIDTH) {\n      const issuerAccount = this.toBytes().slice(0, 20)\n      const sequence = new DataView(this.toBytes().slice(40).buffer).getUint32(\n        0,\n        true,\n      )\n\n      // sequence part of mpt_issuance_id should be in Big-endian\n      const sequenceBuffer = new Uint8Array(4)\n      writeUInt32BE(sequenceBuffer, sequence, 0)\n\n      return {\n        mpt_issuance_id: bytesToHex(concat([sequenceBuffer, issuerAccount])),\n      }\n    }\n\n    const parser = new BinaryParser(this.toString())\n\n    const currency = Currency.fromParser(parser) as Currency\n    if (currency.toJSON() === 'XRP') {\n      return { currency: currency.toJSON() }\n    }\n    const issuer = AccountID.fromParser(parser) as AccountID\n\n    return {\n      currency: currency.toJSON(),\n      issuer: issuer.toJSON(),\n    }\n  }\n}\n\nexport { Issue, IssueObject }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}