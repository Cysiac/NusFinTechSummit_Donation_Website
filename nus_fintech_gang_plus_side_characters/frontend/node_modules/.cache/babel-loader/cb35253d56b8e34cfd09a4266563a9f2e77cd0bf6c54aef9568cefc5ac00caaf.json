{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateNFTokenMint = exports.NFTokenMintFlags = void 0;\nconst errors_1 = require(\"../../errors\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nvar NFTokenMintFlags;\n(function (NFTokenMintFlags) {\n  NFTokenMintFlags[NFTokenMintFlags[\"tfBurnable\"] = 1] = \"tfBurnable\";\n  NFTokenMintFlags[NFTokenMintFlags[\"tfOnlyXRP\"] = 2] = \"tfOnlyXRP\";\n  NFTokenMintFlags[NFTokenMintFlags[\"tfTrustLine\"] = 4] = \"tfTrustLine\";\n  NFTokenMintFlags[NFTokenMintFlags[\"tfTransferable\"] = 8] = \"tfTransferable\";\n  NFTokenMintFlags[NFTokenMintFlags[\"tfMutable\"] = 16] = \"tfMutable\";\n})(NFTokenMintFlags || (exports.NFTokenMintFlags = NFTokenMintFlags = {}));\nfunction validateNFTokenMint(tx) {\n  (0, common_1.validateBaseTransaction)(tx);\n  if (tx.Account === tx.Issuer) {\n    throw new errors_1.ValidationError('NFTokenMint: Issuer must not be equal to Account');\n  }\n  (0, common_1.validateOptionalField)(tx, 'Issuer', common_1.isAccount);\n  if (typeof tx.URI === 'string' && tx.URI === '') {\n    throw new errors_1.ValidationError('NFTokenMint: URI must not be empty string');\n  }\n  if (typeof tx.URI === 'string' && !(0, utils_1.isHex)(tx.URI)) {\n    throw new errors_1.ValidationError('NFTokenMint: URI must be in hex format');\n  }\n  if (tx.NFTokenTaxon == null) {\n    throw new errors_1.ValidationError('NFTokenMint: missing field NFTokenTaxon');\n  }\n  if (tx.Amount == null) {\n    if (tx.Expiration != null || tx.Destination != null) {\n      throw new errors_1.ValidationError('NFTokenMint: Amount is required when Expiration or Destination is present');\n    }\n  }\n  (0, common_1.validateOptionalField)(tx, 'Amount', common_1.isAmount);\n  (0, common_1.validateOptionalField)(tx, 'Expiration', common_1.isNumber);\n  (0, common_1.validateOptionalField)(tx, 'Destination', common_1.isAccount);\n}\nexports.validateNFTokenMint = validateNFTokenMint;","map":{"version":3,"names":["errors_1","require","utils_1","common_1","NFTokenMintFlags","exports","validateNFTokenMint","tx","validateBaseTransaction","Account","Issuer","ValidationError","validateOptionalField","isAccount","URI","isHex","NFTokenTaxon","Amount","Expiration","Destination","isAmount","isNumber"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/models/transactions/NFTokenMint.ts"],"sourcesContent":["import { ValidationError } from '../../errors'\nimport { Amount } from '../common'\nimport { isHex } from '../utils'\n\nimport {\n  Account,\n  BaseTransaction,\n  GlobalFlagsInterface,\n  isAccount,\n  isAmount,\n  isNumber,\n  validateBaseTransaction,\n  validateOptionalField,\n} from './common'\nimport type { TransactionMetadataBase } from './metadata'\n\n/**\n * Transaction Flags for an NFTokenMint Transaction.\n *\n * @category Transaction Flags\n */\nexport enum NFTokenMintFlags {\n  /**\n   * If set, indicates that the minted token may be burned by the issuer even\n   * if the issuer does not currently hold the token. The current holder of\n   * the token may always burn it.\n   */\n  tfBurnable = 0x00000001,\n  /**\n   * If set, indicates that the token may only be offered or sold for XRP.\n   */\n  tfOnlyXRP = 0x00000002,\n  /**\n   * If set, indicates that the issuer wants a trustline to be automatically\n   * created.\n   */\n  tfTrustLine = 0x00000004,\n  /**\n   * If set, indicates that this NFT can be transferred. This flag has no\n   * effect if the token is being transferred from the issuer or to the\n   * issuer.\n   */\n  tfTransferable = 0x00000008,\n  /**\n   * If set, indicates that this NFT's URI can be modified.\n   */\n  tfMutable = 0x00000010,\n}\n\n/**\n * Map of flags to boolean values representing {@link NFTokenMint} transaction\n * flags.\n *\n * @category Transaction Flags\n */\nexport interface NFTokenMintFlagsInterface extends GlobalFlagsInterface {\n  tfBurnable?: boolean\n  tfOnlyXRP?: boolean\n  tfTrustLine?: boolean\n  tfTransferable?: boolean\n  tfMutable?: boolean\n}\n\n/**\n * The NFTokenMint transaction creates an NFToken object and adds it to the\n * relevant NFTokenPage object of the minter. If the transaction is\n * successful, the newly minted token will be owned by the minter account\n * specified by the transaction.\n */\nexport interface NFTokenMint extends BaseTransaction {\n  TransactionType: 'NFTokenMint'\n  /**\n   * Indicates the taxon associated with this token. The taxon is generally a\n   * value chosen by the minter of the token and a given taxon may be used for\n   * multiple tokens. The implementation reserves taxon identifiers greater\n   * than or equal to 2147483648 (0x80000000). If you have no use for this\n   * field, set it to 0.\n   */\n  NFTokenTaxon: number\n  /**\n   * Indicates the account that should be the issuer of this token. This value\n   * is optional and should only be specified if the account executing the\n   * transaction is not the `Issuer` of the `NFToken` object. If it is\n   * present, the `MintAccount` field in the `AccountRoot` of the `Issuer`\n   * field must match the `Account`, otherwise the transaction will fail.\n   */\n  Issuer?: Account\n  /**\n   * Specifies the fee charged by the issuer for secondary sales of the Token,\n   * if such sales are allowed. Valid values for this field are between 0 and\n   * 50000 inclusive, allowing transfer rates between 0.000% and 50.000% in\n   * increments of 0.001%. This field must NOT be present if the\n   * `tfTransferable` flag is not set.\n   */\n  TransferFee?: number\n  /**\n   * URI that points to the data and/or metadata associated with the NFT.\n   * This field need not be an HTTP or HTTPS URL; it could be an IPFS URI, a\n   * magnet link, immediate data encoded as an RFC2379 \"data\" URL, or even an\n   * opaque issuer-specific encoding. The URI is NOT checked for validity, but\n   * the field is limited to a maximum length of 256 bytes.\n   *\n   * This field must be hex-encoded. You can use `convertStringToHex` to\n   * convert this field to the proper encoding.\n   *\n   * This field must not be an empty string. Omit it from the transaction or\n   * set to `undefined` value if you do not use it.\n   */\n  URI?: string | null\n  /**\n   * Indicates the amount expected for the Token.\n   *\n   * The amount can be zero. This would indicate that the account is giving\n   * the token away free, either to anyone at all, or to the account identified\n   * by the Destination field.\n   */\n  Amount?: Amount\n  /**\n   * Indicates the time after which the offer will no longer\n   * be valid. The value is the number of seconds since the\n   * Ripple Epoch.\n   */\n  Expiration?: number\n  /**\n   * If present, indicates that this offer may only be\n   * accepted by the specified account. Attempts by other\n   * accounts to accept this offer MUST fail.\n   */\n  Destination?: Account\n  Flags?: number | NFTokenMintFlagsInterface\n}\n\nexport interface NFTokenMintMetadata extends TransactionMetadataBase {\n  // rippled 1.11.0 or later\n  nftoken_id?: string\n  // if Amount is present\n  offer_id?: string\n}\n\n/**\n * Verify the form and type of an NFTokenMint at runtime.\n *\n * @param tx - An NFTokenMint Transaction.\n * @throws When the NFTokenMint is Malformed.\n */\nexport function validateNFTokenMint(tx: Record<string, unknown>): void {\n  validateBaseTransaction(tx)\n\n  if (tx.Account === tx.Issuer) {\n    throw new ValidationError(\n      'NFTokenMint: Issuer must not be equal to Account',\n    )\n  }\n\n  validateOptionalField(tx, 'Issuer', isAccount)\n\n  if (typeof tx.URI === 'string' && tx.URI === '') {\n    throw new ValidationError('NFTokenMint: URI must not be empty string')\n  }\n\n  if (typeof tx.URI === 'string' && !isHex(tx.URI)) {\n    throw new ValidationError('NFTokenMint: URI must be in hex format')\n  }\n\n  if (tx.NFTokenTaxon == null) {\n    throw new ValidationError('NFTokenMint: missing field NFTokenTaxon')\n  }\n\n  if (tx.Amount == null) {\n    if (tx.Expiration != null || tx.Destination != null) {\n      throw new ValidationError(\n        'NFTokenMint: Amount is required when Expiration or Destination is present',\n      )\n    }\n  }\n\n  validateOptionalField(tx, 'Amount', isAmount)\n  validateOptionalField(tx, 'Expiration', isNumber)\n  validateOptionalField(tx, 'Destination', isAccount)\n}\n"],"mappings":";;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AAEA,MAAAE,QAAA,GAAAF,OAAA;AAiBA,IAAYG,gBA0BX;AA1BD,WAAYA,gBAAgB;EAM1BA,gBAAA,CAAAA,gBAAA,kCAAuB;EAIvBA,gBAAA,CAAAA,gBAAA,gCAAsB;EAKtBA,gBAAA,CAAAA,gBAAA,oCAAwB;EAMxBA,gBAAA,CAAAA,gBAAA,0CAA2B;EAI3BA,gBAAA,CAAAA,gBAAA,iCAAsB;AACxB,CAAC,EA1BWA,gBAAgB,KAAAC,OAAA,CAAAD,gBAAA,GAAhBA,gBAAgB;AA4H5B,SAAgBE,mBAAmBA,CAACC,EAA2B;EAC7D,IAAAJ,QAAA,CAAAK,uBAAuB,EAACD,EAAE,CAAC;EAE3B,IAAIA,EAAE,CAACE,OAAO,KAAKF,EAAE,CAACG,MAAM,EAAE;IAC5B,MAAM,IAAIV,QAAA,CAAAW,eAAe,CACvB,kDAAkD,CACnD;;EAGH,IAAAR,QAAA,CAAAS,qBAAqB,EAACL,EAAE,EAAE,QAAQ,EAAEJ,QAAA,CAAAU,SAAS,CAAC;EAE9C,IAAI,OAAON,EAAE,CAACO,GAAG,KAAK,QAAQ,IAAIP,EAAE,CAACO,GAAG,KAAK,EAAE,EAAE;IAC/C,MAAM,IAAId,QAAA,CAAAW,eAAe,CAAC,2CAA2C,CAAC;;EAGxE,IAAI,OAAOJ,EAAE,CAACO,GAAG,KAAK,QAAQ,IAAI,CAAC,IAAAZ,OAAA,CAAAa,KAAK,EAACR,EAAE,CAACO,GAAG,CAAC,EAAE;IAChD,MAAM,IAAId,QAAA,CAAAW,eAAe,CAAC,wCAAwC,CAAC;;EAGrE,IAAIJ,EAAE,CAACS,YAAY,IAAI,IAAI,EAAE;IAC3B,MAAM,IAAIhB,QAAA,CAAAW,eAAe,CAAC,yCAAyC,CAAC;;EAGtE,IAAIJ,EAAE,CAACU,MAAM,IAAI,IAAI,EAAE;IACrB,IAAIV,EAAE,CAACW,UAAU,IAAI,IAAI,IAAIX,EAAE,CAACY,WAAW,IAAI,IAAI,EAAE;MACnD,MAAM,IAAInB,QAAA,CAAAW,eAAe,CACvB,2EAA2E,CAC5E;;;EAIL,IAAAR,QAAA,CAAAS,qBAAqB,EAACL,EAAE,EAAE,QAAQ,EAAEJ,QAAA,CAAAiB,QAAQ,CAAC;EAC7C,IAAAjB,QAAA,CAAAS,qBAAqB,EAACL,EAAE,EAAE,YAAY,EAAEJ,QAAA,CAAAkB,QAAQ,CAAC;EACjD,IAAAlB,QAAA,CAAAS,qBAAqB,EAACL,EAAE,EAAE,aAAa,EAAEJ,QAAA,CAAAU,SAAS,CAAC;AACrD;AAlCAR,OAAA,CAAAC,mBAAA,GAAAA,mBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}