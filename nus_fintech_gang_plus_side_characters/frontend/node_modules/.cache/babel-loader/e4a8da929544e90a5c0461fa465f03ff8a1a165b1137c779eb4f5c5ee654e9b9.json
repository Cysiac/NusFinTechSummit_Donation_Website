{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Amount = void 0;\nconst binary_parser_1 = require(\"../serdes/binary-parser\");\nconst account_id_1 = require(\"./account-id\");\nconst currency_1 = require(\"./currency\");\nconst serialized_type_1 = require(\"./serialized-type\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst utils_2 = require(\"../utils\");\nconst hash_192_1 = require(\"./hash-192\");\n/**\n * Constants for validating amounts\n */\nconst MIN_IOU_EXPONENT = -96;\nconst MAX_IOU_EXPONENT = 80;\nconst MAX_IOU_PRECISION = 16;\nconst MAX_DROPS = new bignumber_js_1.default('1e17');\nconst MIN_XRP = new bignumber_js_1.default('1e-6');\nconst mask = BigInt(0x00000000ffffffff);\nconst mptMask = BigInt(0x8000000000000000);\n/**\n * BigNumber configuration for Amount IOUs\n */\nbignumber_js_1.default.config({\n  EXPONENTIAL_AT: [MIN_IOU_EXPONENT - MAX_IOU_PRECISION, MAX_IOU_EXPONENT + MAX_IOU_PRECISION]\n});\n/**\n * Type guard for AmountObjectIOU\n */\nfunction isAmountObjectIOU(arg) {\n  const keys = Object.keys(arg).sort();\n  return keys.length === 3 && keys[0] === 'currency' && keys[1] === 'issuer' && keys[2] === 'value';\n}\n/**\n * Type guard for AmountObjectMPT\n */\nfunction isAmountObjectMPT(arg) {\n  const keys = Object.keys(arg).sort();\n  return keys.length === 2 && keys[0] === 'mpt_issuance_id' && keys[1] === 'value';\n}\n/**\n * Class for serializing/Deserializing Amounts\n */\nclass Amount extends serialized_type_1.SerializedType {\n  constructor(bytes) {\n    super(bytes !== null && bytes !== void 0 ? bytes : Amount.defaultAmount.bytes);\n  }\n  /**\n   * Construct an amount from an IOU, MPT or string amount\n   *\n   * @param value An Amount, object representing an IOU, or a string\n   *     representing an integer amount\n   * @returns An Amount object\n   */\n  static from(value) {\n    if (value instanceof Amount) {\n      return value;\n    }\n    let amount = new Uint8Array(8);\n    if (typeof value === 'string') {\n      Amount.assertXrpIsValid(value);\n      const number = BigInt(value);\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)];\n      (0, utils_2.writeUInt32BE)(intBuf[0], Number(number >> BigInt(32)), 0);\n      (0, utils_2.writeUInt32BE)(intBuf[1], Number(number & BigInt(mask)), 0);\n      amount = (0, utils_1.concat)(intBuf);\n      amount[0] |= 0x40;\n      return new Amount(amount);\n    }\n    if (isAmountObjectIOU(value)) {\n      const number = new bignumber_js_1.default(value.value);\n      Amount.assertIouIsValid(number);\n      if (number.isZero()) {\n        amount[0] |= 0x80;\n      } else {\n        const integerNumberString = number.times(`1e${-((number.e || 0) - 15)}`).abs().toString();\n        const num = BigInt(integerNumberString);\n        const intBuf = [new Uint8Array(4), new Uint8Array(4)];\n        (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);\n        (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);\n        amount = (0, utils_1.concat)(intBuf);\n        amount[0] |= 0x80;\n        if (number.gt(new bignumber_js_1.default(0))) {\n          amount[0] |= 0x40;\n        }\n        const exponent = (number.e || 0) - 15;\n        const exponentByte = 97 + exponent;\n        amount[0] |= exponentByte >>> 2;\n        amount[1] |= (exponentByte & 0x03) << 6;\n      }\n      const currency = currency_1.Currency.from(value.currency).toBytes();\n      const issuer = account_id_1.AccountID.from(value.issuer).toBytes();\n      return new Amount((0, utils_1.concat)([amount, currency, issuer]));\n    }\n    if (isAmountObjectMPT(value)) {\n      Amount.assertMptIsValid(value.value);\n      let leadingByte = new Uint8Array(1);\n      leadingByte[0] |= 0x60;\n      const num = BigInt(value.value);\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)];\n      (0, utils_2.writeUInt32BE)(intBuf[0], Number(num >> BigInt(32)), 0);\n      (0, utils_2.writeUInt32BE)(intBuf[1], Number(num & BigInt(mask)), 0);\n      amount = (0, utils_1.concat)(intBuf);\n      const mptIssuanceID = hash_192_1.Hash192.from(value.mpt_issuance_id).toBytes();\n      return new Amount((0, utils_1.concat)([leadingByte, amount, mptIssuanceID]));\n    }\n    throw new Error('Invalid type to construct an Amount');\n  }\n  /**\n   * Read an amount from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Amount from\n   * @returns An Amount object\n   */\n  static fromParser(parser) {\n    const isIOU = parser.peek() & 0x80;\n    if (isIOU) return new Amount(parser.read(48));\n    // the amount can be either MPT or XRP at this point\n    const isMPT = parser.peek() & 0x20;\n    const numBytes = isMPT ? 33 : 8;\n    return new Amount(parser.read(numBytes));\n  }\n  /**\n   * Get the JSON representation of this Amount\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON() {\n    if (this.isNative()) {\n      const bytes = this.bytes;\n      const isPositive = bytes[0] & 0x40;\n      const sign = isPositive ? '' : '-';\n      bytes[0] &= 0x3f;\n      const msb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(0, 4), 0));\n      const lsb = BigInt((0, utils_2.readUInt32BE)(bytes.slice(4), 0));\n      const num = msb << BigInt(32) | lsb;\n      return `${sign}${num.toString()}`;\n    }\n    if (this.isIOU()) {\n      const parser = new binary_parser_1.BinaryParser(this.toString());\n      const mantissa = parser.read(8);\n      const currency = currency_1.Currency.fromParser(parser);\n      const issuer = account_id_1.AccountID.fromParser(parser);\n      const b1 = mantissa[0];\n      const b2 = mantissa[1];\n      const isPositive = b1 & 0x40;\n      const sign = isPositive ? '' : '-';\n      const exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97;\n      mantissa[0] = 0;\n      mantissa[1] &= 0x3f;\n      const value = new bignumber_js_1.default(`${sign}0x${(0, utils_1.bytesToHex)(mantissa)}`).times(`1e${exponent}`);\n      Amount.assertIouIsValid(value);\n      return {\n        value: value.toString(),\n        currency: currency.toJSON(),\n        issuer: issuer.toJSON()\n      };\n    }\n    if (this.isMPT()) {\n      const parser = new binary_parser_1.BinaryParser(this.toString());\n      const leadingByte = parser.read(1);\n      const amount = parser.read(8);\n      const mptID = hash_192_1.Hash192.fromParser(parser);\n      const isPositive = leadingByte[0] & 0x40;\n      const sign = isPositive ? '' : '-';\n      const msb = BigInt((0, utils_2.readUInt32BE)(amount.slice(0, 4), 0));\n      const lsb = BigInt((0, utils_2.readUInt32BE)(amount.slice(4), 0));\n      const num = msb << BigInt(32) | lsb;\n      return {\n        value: `${sign}${num.toString()}`,\n        mpt_issuance_id: mptID.toString()\n      };\n    }\n    throw new Error('Invalid amount to construct JSON');\n  }\n  /**\n   * Validate XRP amount\n   *\n   * @param amount String representing XRP amount\n   * @returns void, but will throw if invalid amount\n   */\n  static assertXrpIsValid(amount) {\n    if (amount.indexOf('.') !== -1) {\n      throw new Error(`${amount.toString()} is an illegal amount`);\n    }\n    const decimal = new bignumber_js_1.default(amount);\n    if (!decimal.isZero()) {\n      if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {\n        throw new Error(`${amount.toString()} is an illegal amount`);\n      }\n    }\n  }\n  /**\n   * Validate IOU.value amount\n   *\n   * @param decimal BigNumber object representing IOU.value\n   * @returns void, but will throw if invalid amount\n   */\n  static assertIouIsValid(decimal) {\n    if (!decimal.isZero()) {\n      const p = decimal.precision();\n      const e = (decimal.e || 0) - 15;\n      if (p > MAX_IOU_PRECISION || e > MAX_IOU_EXPONENT || e < MIN_IOU_EXPONENT) {\n        throw new Error('Decimal precision out of range');\n      }\n      this.verifyNoDecimal(decimal);\n    }\n  }\n  /**\n   * Validate MPT.value amount\n   *\n   * @param decimal BigNumber object representing MPT.value\n   * @returns void, but will throw if invalid amount\n   */\n  static assertMptIsValid(amount) {\n    if (amount.indexOf('.') !== -1) {\n      throw new Error(`${amount.toString()} is an illegal amount`);\n    }\n    const decimal = new bignumber_js_1.default(amount);\n    if (!decimal.isZero()) {\n      if (decimal < (0, bignumber_js_1.default)(0)) {\n        throw new Error(`${amount.toString()} is an illegal amount`);\n      }\n      if (Number(BigInt(amount) & BigInt(mptMask)) != 0) {\n        throw new Error(`${amount.toString()} is an illegal amount`);\n      }\n    }\n  }\n  /**\n   * Ensure that the value after being multiplied by the exponent does not\n   * contain a decimal.\n   *\n   * @param decimal a Decimal object\n   * @returns a string of the object without a decimal\n   */\n  static verifyNoDecimal(decimal) {\n    const integerNumberString = decimal.times(`1e${-((decimal.e || 0) - 15)}`).abs().toString();\n    if (integerNumberString.indexOf('.') !== -1) {\n      throw new Error('Decimal place found in integerNumberString');\n    }\n  }\n  /**\n   * Test if this amount is in units of Native Currency(XRP)\n   *\n   * @returns true if Native (XRP)\n   */\n  isNative() {\n    return (this.bytes[0] & 0x80) === 0 && (this.bytes[0] & 0x20) === 0;\n  }\n  /**\n   * Test if this amount is in units of MPT\n   *\n   * @returns true if MPT\n   */\n  isMPT() {\n    return (this.bytes[0] & 0x80) === 0 && (this.bytes[0] & 0x20) !== 0;\n  }\n  /**\n   * Test if this amount is in units of IOU\n   *\n   * @returns true if IOU\n   */\n  isIOU() {\n    return (this.bytes[0] & 0x80) !== 0;\n  }\n}\nexports.Amount = Amount;\nAmount.defaultAmount = new Amount((0, utils_1.hexToBytes)('4000000000000000'));","map":{"version":3,"names":["binary_parser_1","require","account_id_1","currency_1","serialized_type_1","bignumber_js_1","__importDefault","utils_1","utils_2","hash_192_1","MIN_IOU_EXPONENT","MAX_IOU_EXPONENT","MAX_IOU_PRECISION","MAX_DROPS","default","MIN_XRP","mask","BigInt","mptMask","config","EXPONENTIAL_AT","isAmountObjectIOU","arg","keys","Object","sort","length","isAmountObjectMPT","Amount","SerializedType","constructor","bytes","defaultAmount","from","value","amount","Uint8Array","assertXrpIsValid","number","intBuf","writeUInt32BE","Number","concat","assertIouIsValid","isZero","integerNumberString","times","e","abs","toString","num","gt","exponent","exponentByte","currency","Currency","toBytes","issuer","AccountID","assertMptIsValid","leadingByte","mptIssuanceID","Hash192","mpt_issuance_id","Error","fromParser","parser","isIOU","peek","read","isMPT","numBytes","toJSON","isNative","isPositive","sign","msb","readUInt32BE","slice","lsb","BinaryParser","mantissa","b1","b2","bytesToHex","mptID","indexOf","decimal","lt","p","precision","verifyNoDecimal","exports","hexToBytes"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/ripple-binary-codec/src/types/amount.ts"],"sourcesContent":["import { BinaryParser } from '../serdes/binary-parser'\n\nimport { AccountID } from './account-id'\nimport { Currency } from './currency'\nimport { JsonObject, SerializedType } from './serialized-type'\nimport BigNumber from 'bignumber.js'\nimport { bytesToHex, concat, hexToBytes } from '@xrplf/isomorphic/utils'\nimport { readUInt32BE, writeUInt32BE } from '../utils'\nimport { Hash192 } from './hash-192'\n\n/**\n * Constants for validating amounts\n */\nconst MIN_IOU_EXPONENT = -96\nconst MAX_IOU_EXPONENT = 80\nconst MAX_IOU_PRECISION = 16\nconst MAX_DROPS = new BigNumber('1e17')\nconst MIN_XRP = new BigNumber('1e-6')\nconst mask = BigInt(0x00000000ffffffff)\nconst mptMask = BigInt(0x8000000000000000)\n\n/**\n * BigNumber configuration for Amount IOUs\n */\nBigNumber.config({\n  EXPONENTIAL_AT: [\n    MIN_IOU_EXPONENT - MAX_IOU_PRECISION,\n    MAX_IOU_EXPONENT + MAX_IOU_PRECISION,\n  ],\n})\n\ninterface AmountObjectIOU extends JsonObject {\n  value: string\n  currency: string\n  issuer: string\n}\n\ninterface AmountObjectMPT extends JsonObject {\n  value: string\n  mpt_issuance_id: string\n}\n\n/**\n * Interface for JSON objects that represent amounts\n */\ntype AmountObject = AmountObjectIOU | AmountObjectMPT\n\n/**\n * Type guard for AmountObjectIOU\n */\nfunction isAmountObjectIOU(arg): arg is AmountObjectIOU {\n  const keys = Object.keys(arg).sort()\n\n  return (\n    keys.length === 3 &&\n    keys[0] === 'currency' &&\n    keys[1] === 'issuer' &&\n    keys[2] === 'value'\n  )\n}\n\n/**\n * Type guard for AmountObjectMPT\n */\nfunction isAmountObjectMPT(arg): arg is AmountObjectMPT {\n  const keys = Object.keys(arg).sort()\n\n  return (\n    keys.length === 2 && keys[0] === 'mpt_issuance_id' && keys[1] === 'value'\n  )\n}\n\n/**\n * Class for serializing/Deserializing Amounts\n */\nclass Amount extends SerializedType {\n  static defaultAmount: Amount = new Amount(hexToBytes('4000000000000000'))\n\n  constructor(bytes: Uint8Array) {\n    super(bytes ?? Amount.defaultAmount.bytes)\n  }\n\n  /**\n   * Construct an amount from an IOU, MPT or string amount\n   *\n   * @param value An Amount, object representing an IOU, or a string\n   *     representing an integer amount\n   * @returns An Amount object\n   */\n  static from<T extends Amount | AmountObject | string>(value: T): Amount {\n    if (value instanceof Amount) {\n      return value\n    }\n\n    let amount = new Uint8Array(8)\n    if (typeof value === 'string') {\n      Amount.assertXrpIsValid(value)\n\n      const number = BigInt(value)\n\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)]\n      writeUInt32BE(intBuf[0], Number(number >> BigInt(32)), 0)\n      writeUInt32BE(intBuf[1], Number(number & BigInt(mask)), 0)\n\n      amount = concat(intBuf)\n\n      amount[0] |= 0x40\n\n      return new Amount(amount)\n    }\n\n    if (isAmountObjectIOU(value)) {\n      const number = new BigNumber(value.value)\n      Amount.assertIouIsValid(number)\n\n      if (number.isZero()) {\n        amount[0] |= 0x80\n      } else {\n        const integerNumberString = number\n          .times(`1e${-((number.e || 0) - 15)}`)\n          .abs()\n          .toString()\n\n        const num = BigInt(integerNumberString)\n        const intBuf = [new Uint8Array(4), new Uint8Array(4)]\n        writeUInt32BE(intBuf[0], Number(num >> BigInt(32)), 0)\n        writeUInt32BE(intBuf[1], Number(num & BigInt(mask)), 0)\n\n        amount = concat(intBuf)\n\n        amount[0] |= 0x80\n\n        if (number.gt(new BigNumber(0))) {\n          amount[0] |= 0x40\n        }\n\n        const exponent = (number.e || 0) - 15\n        const exponentByte = 97 + exponent\n        amount[0] |= exponentByte >>> 2\n        amount[1] |= (exponentByte & 0x03) << 6\n      }\n\n      const currency = Currency.from(value.currency).toBytes()\n      const issuer = AccountID.from(value.issuer).toBytes()\n      return new Amount(concat([amount, currency, issuer]))\n    }\n\n    if (isAmountObjectMPT(value)) {\n      Amount.assertMptIsValid(value.value)\n\n      let leadingByte = new Uint8Array(1)\n      leadingByte[0] |= 0x60\n\n      const num = BigInt(value.value)\n\n      const intBuf = [new Uint8Array(4), new Uint8Array(4)]\n      writeUInt32BE(intBuf[0], Number(num >> BigInt(32)), 0)\n      writeUInt32BE(intBuf[1], Number(num & BigInt(mask)), 0)\n\n      amount = concat(intBuf)\n\n      const mptIssuanceID = Hash192.from(value.mpt_issuance_id).toBytes()\n      return new Amount(concat([leadingByte, amount, mptIssuanceID]))\n    }\n\n    throw new Error('Invalid type to construct an Amount')\n  }\n\n  /**\n   * Read an amount from a BinaryParser\n   *\n   * @param parser BinaryParser to read the Amount from\n   * @returns An Amount object\n   */\n  static fromParser(parser: BinaryParser): Amount {\n    const isIOU = parser.peek() & 0x80\n    if (isIOU) return new Amount(parser.read(48))\n\n    // the amount can be either MPT or XRP at this point\n    const isMPT = parser.peek() & 0x20\n    const numBytes = isMPT ? 33 : 8\n    return new Amount(parser.read(numBytes))\n  }\n\n  /**\n   * Get the JSON representation of this Amount\n   *\n   * @returns the JSON interpretation of this.bytes\n   */\n  toJSON(): AmountObject | string {\n    if (this.isNative()) {\n      const bytes = this.bytes\n      const isPositive = bytes[0] & 0x40\n      const sign = isPositive ? '' : '-'\n      bytes[0] &= 0x3f\n\n      const msb = BigInt(readUInt32BE(bytes.slice(0, 4), 0))\n      const lsb = BigInt(readUInt32BE(bytes.slice(4), 0))\n      const num = (msb << BigInt(32)) | lsb\n\n      return `${sign}${num.toString()}`\n    }\n\n    if (this.isIOU()) {\n      const parser = new BinaryParser(this.toString())\n      const mantissa = parser.read(8)\n      const currency = Currency.fromParser(parser) as Currency\n      const issuer = AccountID.fromParser(parser) as AccountID\n\n      const b1 = mantissa[0]\n      const b2 = mantissa[1]\n\n      const isPositive = b1 & 0x40\n      const sign = isPositive ? '' : '-'\n      const exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97\n\n      mantissa[0] = 0\n      mantissa[1] &= 0x3f\n      const value = new BigNumber(`${sign}0x${bytesToHex(mantissa)}`).times(\n        `1e${exponent}`,\n      )\n      Amount.assertIouIsValid(value)\n\n      return {\n        value: value.toString(),\n        currency: currency.toJSON(),\n        issuer: issuer.toJSON(),\n      }\n    }\n\n    if (this.isMPT()) {\n      const parser = new BinaryParser(this.toString())\n      const leadingByte = parser.read(1)\n      const amount = parser.read(8)\n      const mptID = Hash192.fromParser(parser) as Hash192\n\n      const isPositive = leadingByte[0] & 0x40\n      const sign = isPositive ? '' : '-'\n\n      const msb = BigInt(readUInt32BE(amount.slice(0, 4), 0))\n      const lsb = BigInt(readUInt32BE(amount.slice(4), 0))\n      const num = (msb << BigInt(32)) | lsb\n\n      return {\n        value: `${sign}${num.toString()}`,\n        mpt_issuance_id: mptID.toString(),\n      }\n    }\n\n    throw new Error('Invalid amount to construct JSON')\n  }\n\n  /**\n   * Validate XRP amount\n   *\n   * @param amount String representing XRP amount\n   * @returns void, but will throw if invalid amount\n   */\n  private static assertXrpIsValid(amount: string): void {\n    if (amount.indexOf('.') !== -1) {\n      throw new Error(`${amount.toString()} is an illegal amount`)\n    }\n\n    const decimal = new BigNumber(amount)\n    if (!decimal.isZero()) {\n      if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {\n        throw new Error(`${amount.toString()} is an illegal amount`)\n      }\n    }\n  }\n\n  /**\n   * Validate IOU.value amount\n   *\n   * @param decimal BigNumber object representing IOU.value\n   * @returns void, but will throw if invalid amount\n   */\n  private static assertIouIsValid(decimal: BigNumber): void {\n    if (!decimal.isZero()) {\n      const p = decimal.precision()\n      const e = (decimal.e || 0) - 15\n      if (\n        p > MAX_IOU_PRECISION ||\n        e > MAX_IOU_EXPONENT ||\n        e < MIN_IOU_EXPONENT\n      ) {\n        throw new Error('Decimal precision out of range')\n      }\n      this.verifyNoDecimal(decimal)\n    }\n  }\n\n  /**\n   * Validate MPT.value amount\n   *\n   * @param decimal BigNumber object representing MPT.value\n   * @returns void, but will throw if invalid amount\n   */\n  private static assertMptIsValid(amount: string): void {\n    if (amount.indexOf('.') !== -1) {\n      throw new Error(`${amount.toString()} is an illegal amount`)\n    }\n\n    const decimal = new BigNumber(amount)\n    if (!decimal.isZero()) {\n      if (decimal < BigNumber(0)) {\n        throw new Error(`${amount.toString()} is an illegal amount`)\n      }\n\n      if (Number(BigInt(amount) & BigInt(mptMask)) != 0) {\n        throw new Error(`${amount.toString()} is an illegal amount`)\n      }\n    }\n  }\n\n  /**\n   * Ensure that the value after being multiplied by the exponent does not\n   * contain a decimal.\n   *\n   * @param decimal a Decimal object\n   * @returns a string of the object without a decimal\n   */\n  private static verifyNoDecimal(decimal: BigNumber): void {\n    const integerNumberString = decimal\n      .times(`1e${-((decimal.e || 0) - 15)}`)\n      .abs()\n      .toString()\n\n    if (integerNumberString.indexOf('.') !== -1) {\n      throw new Error('Decimal place found in integerNumberString')\n    }\n  }\n\n  /**\n   * Test if this amount is in units of Native Currency(XRP)\n   *\n   * @returns true if Native (XRP)\n   */\n  private isNative(): boolean {\n    return (this.bytes[0] & 0x80) === 0 && (this.bytes[0] & 0x20) === 0\n  }\n\n  /**\n   * Test if this amount is in units of MPT\n   *\n   * @returns true if MPT\n   */\n  private isMPT(): boolean {\n    return (this.bytes[0] & 0x80) === 0 && (this.bytes[0] & 0x20) !== 0\n  }\n\n  /**\n   * Test if this amount is in units of IOU\n   *\n   * @returns true if IOU\n   */\n  private isIOU(): boolean {\n    return (this.bytes[0] & 0x80) !== 0\n  }\n}\n\nexport { Amount, AmountObject }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}