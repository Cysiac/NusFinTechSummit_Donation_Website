{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateOfferCreate = exports.OfferCreateFlags = void 0;\nconst errors_1 = require(\"../../errors\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nvar OfferCreateFlags;\n(function (OfferCreateFlags) {\n  OfferCreateFlags[OfferCreateFlags[\"tfPassive\"] = 65536] = \"tfPassive\";\n  OfferCreateFlags[OfferCreateFlags[\"tfImmediateOrCancel\"] = 131072] = \"tfImmediateOrCancel\";\n  OfferCreateFlags[OfferCreateFlags[\"tfFillOrKill\"] = 262144] = \"tfFillOrKill\";\n  OfferCreateFlags[OfferCreateFlags[\"tfSell\"] = 524288] = \"tfSell\";\n  OfferCreateFlags[OfferCreateFlags[\"tfHybrid\"] = 1048576] = \"tfHybrid\";\n})(OfferCreateFlags || (exports.OfferCreateFlags = OfferCreateFlags = {}));\nfunction validateOfferCreate(tx) {\n  (0, common_1.validateBaseTransaction)(tx);\n  if (tx.TakerGets === undefined) {\n    throw new errors_1.ValidationError('OfferCreate: missing field TakerGets');\n  }\n  if (tx.TakerPays === undefined) {\n    throw new errors_1.ValidationError('OfferCreate: missing field TakerPays');\n  }\n  if (typeof tx.TakerGets !== 'string' && !(0, common_1.isAmount)(tx.TakerGets)) {\n    throw new errors_1.ValidationError('OfferCreate: invalid TakerGets');\n  }\n  if (typeof tx.TakerPays !== 'string' && !(0, common_1.isAmount)(tx.TakerPays)) {\n    throw new errors_1.ValidationError('OfferCreate: invalid TakerPays');\n  }\n  if (tx.Expiration !== undefined && typeof tx.Expiration !== 'number') {\n    throw new errors_1.ValidationError('OfferCreate: invalid Expiration');\n  }\n  if (tx.OfferSequence !== undefined && typeof tx.OfferSequence !== 'number') {\n    throw new errors_1.ValidationError('OfferCreate: invalid OfferSequence');\n  }\n  (0, common_1.validateOptionalField)(tx, 'DomainID', common_1.isDomainID, {\n    txType: 'OfferCreate',\n    paramName: 'DomainID'\n  });\n  if (tx.DomainID == null && (0, utils_1.hasFlag)(tx, OfferCreateFlags.tfHybrid, 'tfHybrid')) {\n    throw new errors_1.ValidationError('OfferCreate: tfHybrid flag cannot be set if DomainID is not present');\n  }\n}\nexports.validateOfferCreate = validateOfferCreate;","map":{"version":3,"names":["errors_1","require","utils_1","common_1","OfferCreateFlags","exports","validateOfferCreate","tx","validateBaseTransaction","TakerGets","undefined","ValidationError","TakerPays","isAmount","Expiration","OfferSequence","validateOptionalField","isDomainID","txType","paramName","DomainID","hasFlag","tfHybrid"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/models/transactions/offerCreate.ts"],"sourcesContent":["import { ValidationError } from '../../errors'\nimport { Amount } from '../common'\nimport { hasFlag } from '../utils'\n\nimport {\n  BaseTransaction,\n  GlobalFlagsInterface,\n  validateBaseTransaction,\n  isAmount,\n  validateOptionalField,\n  isDomainID,\n} from './common'\n\n/**\n * Transaction Flags for an OfferCreate Transaction.\n *\n * @category Transaction Flags\n */\nexport enum OfferCreateFlags {\n  /**\n   * If enabled, the offer does not consume offers that exactly match it, and\n   * instead becomes an Offer object in the ledger. It still consumes offers\n   * that cross it.\n   */\n  tfPassive = 0x00010000,\n  /**\n   * Treat the offer as an Immediate or Cancel order. If enabled, the offer\n   * never becomes a ledger object: it only tries to match existing offers in\n   * the ledger. If the offer cannot match any offers immediately, it executes\n   * \"successfully\" without trading any currency. In this case, the transaction\n   * has the result code tesSUCCESS, but creates no Offer objects in the ledger.\n   */\n  tfImmediateOrCancel = 0x00020000,\n  /**\n   * Treat the offer as a Fill or Kill order . Only try to match existing\n   * offers in the ledger, and only do so if the entire TakerPays quantity can\n   * be obtained. If the fix1578 amendment is enabled and the offer cannot be\n   * executed when placed, the transaction has the result code tecKILLED;\n   * otherwise, the transaction uses the result code tesSUCCESS even when it was\n   * killed without trading any currency.\n   */\n  tfFillOrKill = 0x00040000,\n  /**\n   * Exchange the entire TakerGets amount, even if it means obtaining more than\n   * the TakerPays amount in exchange.\n   */\n  tfSell = 0x00080000,\n  /**\n   * Indicates the offer is hybrid. (meaning it is part of both a domain and open order book)\n   * This flag cannot be set if the offer doesn't have a DomainID\n   */\n  tfHybrid = 0x00100000,\n}\n\n/**\n * Map of flags to boolean values representing {@link OfferCreate} transaction\n * flags.\n *\n * @category Transaction Flags\n *\n * @example\n * ```typescript\n * const tx: OfferCreate = {\n * Account: 'rhFcpWDHLqpBmX4ezWiA5VLSS4e1BHqhHd',\n * TakerGets: '43000.51',\n * TakerPays: '12928290425',\n * TransactionType: 'OfferCreate',\n * Flags: {\n *   tfPassive: true,\n *   tfFillOrKill: true,\n *  },\n * }\n *\n * // Autofill the tx to see how flags actually look compared to the interface usage.\n * const autofilledTx = await client.autofill(tx)\n * console.log(autofilledTx)\n * // {\n * // Account: 'rhFcpWDHLqpBmX4ezWiA5VLSS4e1BHqhHd',\n * // TakerGets: '43000.51',\n * // TakerPays: '12928290425',\n * // TransactionType: 'OfferCreate',\n * // Flags: 327680,\n * // Sequence: 21970384,\n * // Fee: '12',\n * // LastLedgerSequence: 21970404\n * // }\n * ```\n */\nexport interface OfferCreateFlagsInterface extends GlobalFlagsInterface {\n  tfPassive?: boolean\n  tfImmediateOrCancel?: boolean\n  tfFillOrKill?: boolean\n  tfSell?: boolean\n  tfHybrid?: boolean\n}\n\n/**\n * An OfferCreate transaction is effectively a limit order . It defines an\n * intent to exchange currencies, and creates an Offer object if not completely.\n * Fulfilled when placed. Offers can be partially fulfilled.\n *\n * @category Transaction Models\n */\nexport interface OfferCreate extends BaseTransaction {\n  TransactionType: 'OfferCreate'\n  Flags?: number | OfferCreateFlagsInterface\n  /**\n   * Time after which the offer is no longer active, in seconds since the.\n   * Ripple Epoch.\n   */\n  Expiration?: number\n  /** An offer to delete first, specified in the same way as OfferCancel. */\n  OfferSequence?: number\n  /** The amount and type of currency being provided by the offer creator. */\n  TakerGets: Amount\n  /** The amount and type of currency being requested by the offer creator. */\n  TakerPays: Amount\n  /** The domain that the offer must be a part of. */\n  DomainID?: string\n}\n\n/**\n * Verify the form and type of an OfferCreate at runtime.\n *\n * @param tx - An OfferCreate Transaction.\n * @throws When the OfferCreate is Malformed.\n */\nexport function validateOfferCreate(tx: Record<string, unknown>): void {\n  validateBaseTransaction(tx)\n\n  if (tx.TakerGets === undefined) {\n    throw new ValidationError('OfferCreate: missing field TakerGets')\n  }\n\n  if (tx.TakerPays === undefined) {\n    throw new ValidationError('OfferCreate: missing field TakerPays')\n  }\n\n  if (typeof tx.TakerGets !== 'string' && !isAmount(tx.TakerGets)) {\n    throw new ValidationError('OfferCreate: invalid TakerGets')\n  }\n\n  if (typeof tx.TakerPays !== 'string' && !isAmount(tx.TakerPays)) {\n    throw new ValidationError('OfferCreate: invalid TakerPays')\n  }\n\n  if (tx.Expiration !== undefined && typeof tx.Expiration !== 'number') {\n    throw new ValidationError('OfferCreate: invalid Expiration')\n  }\n\n  if (tx.OfferSequence !== undefined && typeof tx.OfferSequence !== 'number') {\n    throw new ValidationError('OfferCreate: invalid OfferSequence')\n  }\n\n  validateOptionalField(tx, 'DomainID', isDomainID, {\n    txType: 'OfferCreate',\n    paramName: 'DomainID',\n  })\n\n  if (\n    tx.DomainID == null &&\n    hasFlag(tx, OfferCreateFlags.tfHybrid, 'tfHybrid')\n  ) {\n    throw new ValidationError(\n      'OfferCreate: tfHybrid flag cannot be set if DomainID is not present',\n    )\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AAEA,MAAAE,QAAA,GAAAF,OAAA;AAcA,IAAYG,gBAkCX;AAlCD,WAAYA,gBAAgB;EAM1BA,gBAAA,CAAAA,gBAAA,oCAAsB;EAQtBA,gBAAA,CAAAA,gBAAA,yDAAgC;EAShCA,gBAAA,CAAAA,gBAAA,2CAAyB;EAKzBA,gBAAA,CAAAA,gBAAA,+BAAmB;EAKnBA,gBAAA,CAAAA,gBAAA,oCAAqB;AACvB,CAAC,EAlCWA,gBAAgB,KAAAC,OAAA,CAAAD,gBAAA,GAAhBA,gBAAgB;AA6G5B,SAAgBE,mBAAmBA,CAACC,EAA2B;EAC7D,IAAAJ,QAAA,CAAAK,uBAAuB,EAACD,EAAE,CAAC;EAE3B,IAAIA,EAAE,CAACE,SAAS,KAAKC,SAAS,EAAE;IAC9B,MAAM,IAAIV,QAAA,CAAAW,eAAe,CAAC,sCAAsC,CAAC;;EAGnE,IAAIJ,EAAE,CAACK,SAAS,KAAKF,SAAS,EAAE;IAC9B,MAAM,IAAIV,QAAA,CAAAW,eAAe,CAAC,sCAAsC,CAAC;;EAGnE,IAAI,OAAOJ,EAAE,CAACE,SAAS,KAAK,QAAQ,IAAI,CAAC,IAAAN,QAAA,CAAAU,QAAQ,EAACN,EAAE,CAACE,SAAS,CAAC,EAAE;IAC/D,MAAM,IAAIT,QAAA,CAAAW,eAAe,CAAC,gCAAgC,CAAC;;EAG7D,IAAI,OAAOJ,EAAE,CAACK,SAAS,KAAK,QAAQ,IAAI,CAAC,IAAAT,QAAA,CAAAU,QAAQ,EAACN,EAAE,CAACK,SAAS,CAAC,EAAE;IAC/D,MAAM,IAAIZ,QAAA,CAAAW,eAAe,CAAC,gCAAgC,CAAC;;EAG7D,IAAIJ,EAAE,CAACO,UAAU,KAAKJ,SAAS,IAAI,OAAOH,EAAE,CAACO,UAAU,KAAK,QAAQ,EAAE;IACpE,MAAM,IAAId,QAAA,CAAAW,eAAe,CAAC,iCAAiC,CAAC;;EAG9D,IAAIJ,EAAE,CAACQ,aAAa,KAAKL,SAAS,IAAI,OAAOH,EAAE,CAACQ,aAAa,KAAK,QAAQ,EAAE;IAC1E,MAAM,IAAIf,QAAA,CAAAW,eAAe,CAAC,oCAAoC,CAAC;;EAGjE,IAAAR,QAAA,CAAAa,qBAAqB,EAACT,EAAE,EAAE,UAAU,EAAEJ,QAAA,CAAAc,UAAU,EAAE;IAChDC,MAAM,EAAE,aAAa;IACrBC,SAAS,EAAE;GACZ,CAAC;EAEF,IACEZ,EAAE,CAACa,QAAQ,IAAI,IAAI,IACnB,IAAAlB,OAAA,CAAAmB,OAAO,EAACd,EAAE,EAAEH,gBAAgB,CAACkB,QAAQ,EAAE,UAAU,CAAC,EAClD;IACA,MAAM,IAAItB,QAAA,CAAAW,eAAe,CACvB,qEAAqE,CACtE;;AAEL;AAxCAN,OAAA,CAAAC,mBAAA,GAAAA,mBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}