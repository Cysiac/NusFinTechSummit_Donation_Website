{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.combineBatchSigners = exports.signMultiBatch = void 0;\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst ripple_keypairs_1 = require(\"ripple-keypairs\");\nconst errors_1 = require(\"../errors\");\nconst models_1 = require(\"../models\");\nconst batch_1 = require(\"../models/transactions/batch\");\nconst hashes_1 = require(\"../utils/hashes\");\nconst utils_1 = require(\"./utils\");\nfunction constructBatchSignerObject(batchAccount, wallet, signature, multisignAddress = false) {\n  let batchSigner;\n  if (multisignAddress) {\n    batchSigner = {\n      BatchSigner: {\n        Account: batchAccount,\n        Signers: [{\n          Signer: {\n            Account: multisignAddress,\n            SigningPubKey: wallet.publicKey,\n            TxnSignature: signature\n          }\n        }]\n      }\n    };\n  } else {\n    batchSigner = {\n      BatchSigner: {\n        Account: batchAccount,\n        SigningPubKey: wallet.publicKey,\n        TxnSignature: signature\n      }\n    };\n  }\n  return batchSigner;\n}\nfunction signMultiBatch(wallet, transaction, opts = {}) {\n  var _a;\n  const batchAccount = (_a = opts.batchAccount) !== null && _a !== void 0 ? _a : wallet.classicAddress;\n  let multisignAddress = false;\n  if (typeof opts.multisign === 'string') {\n    multisignAddress = opts.multisign;\n  } else if (opts.multisign) {\n    multisignAddress = wallet.classicAddress;\n  }\n  if (transaction.TransactionType !== 'Batch') {\n    throw new errors_1.ValidationError('Must be a Batch transaction.');\n  }\n  (0, models_1.validate)(transaction);\n  const involvedAccounts = new Set(transaction.RawTransactions.map(raw => raw.RawTransaction.Account));\n  if (!involvedAccounts.has(batchAccount)) {\n    throw new errors_1.ValidationError('Must be signing for an address submitting a transaction in the Batch.');\n  }\n  const fieldsToSign = {\n    flags: transaction.Flags,\n    txIDs: transaction.RawTransactions.map(rawTx => (0, hashes_1.hashSignedTx)(rawTx.RawTransaction))\n  };\n  const signature = (0, ripple_keypairs_1.sign)((0, ripple_binary_codec_1.encodeForSigningBatch)(fieldsToSign), wallet.privateKey);\n  transaction.BatchSigners = [constructBatchSignerObject(batchAccount, wallet, signature, multisignAddress)];\n}\nexports.signMultiBatch = signMultiBatch;\nfunction combineBatchSigners(transactions) {\n  if (transactions.length === 0) {\n    throw new errors_1.ValidationError('There are 0 transactions to combine.');\n  }\n  const decodedTransactions = transactions.map(txOrBlob => {\n    return (0, utils_1.getDecodedTransaction)(txOrBlob);\n  });\n  decodedTransactions.forEach(tx => {\n    if (tx.TransactionType !== 'Batch') {\n      throw new errors_1.ValidationError('TransactionType must be `Batch`.');\n    }\n    (0, batch_1.validateBatch)(tx);\n    if (tx.BatchSigners == null || tx.BatchSigners.length === 0) {\n      throw new errors_1.ValidationError('For combining Batch transaction signatures, all transactions must include a BatchSigners field containing an array of signatures.');\n    }\n    if (tx.TxnSignature != null || tx.Signers != null) {\n      throw new errors_1.ValidationError('Batch transaction must be unsigned.');\n    }\n  });\n  const batchTransactions = decodedTransactions;\n  validateBatchTransactionEquivalence(batchTransactions);\n  return (0, ripple_binary_codec_1.encode)(getTransactionWithAllBatchSigners(batchTransactions));\n}\nexports.combineBatchSigners = combineBatchSigners;\nfunction validateBatchTransactionEquivalence(transactions) {\n  const exampleTransaction = JSON.stringify({\n    flags: transactions[0].Flags,\n    transactionIDs: transactions[0].RawTransactions.map(rawTx => (0, hashes_1.hashSignedTx)(rawTx.RawTransaction))\n  });\n  if (transactions.slice(1).some(tx => JSON.stringify({\n    flags: tx.Flags,\n    transactionIDs: tx.RawTransactions.map(rawTx => (0, hashes_1.hashSignedTx)(rawTx.RawTransaction))\n  }) !== exampleTransaction)) {\n    throw new errors_1.ValidationError('Flags and transaction hashes are not the same for all provided transactions.');\n  }\n}\nfunction getTransactionWithAllBatchSigners(transactions) {\n  const sortedSigners = transactions.flatMap(tx => {\n    var _a;\n    return (_a = tx.BatchSigners) !== null && _a !== void 0 ? _a : [];\n  }).filter(signer => signer.BatchSigner.Account !== transactions[0].Account).sort((signer1, signer2) => (0, utils_1.compareSigners)(signer1.BatchSigner, signer2.BatchSigner));\n  return Object.assign(Object.assign({}, transactions[0]), {\n    BatchSigners: sortedSigners\n  });\n}","map":{"version":3,"names":["ripple_binary_codec_1","require","ripple_keypairs_1","errors_1","models_1","batch_1","hashes_1","utils_1","constructBatchSignerObject","batchAccount","wallet","signature","multisignAddress","batchSigner","BatchSigner","Account","Signers","Signer","SigningPubKey","publicKey","TxnSignature","signMultiBatch","transaction","opts","_a","classicAddress","multisign","TransactionType","ValidationError","validate","involvedAccounts","Set","RawTransactions","map","raw","RawTransaction","has","fieldsToSign","flags","Flags","txIDs","rawTx","hashSignedTx","sign","encodeForSigningBatch","privateKey","BatchSigners","exports","combineBatchSigners","transactions","length","decodedTransactions","txOrBlob","getDecodedTransaction","forEach","tx","validateBatch","batchTransactions","validateBatchTransactionEquivalence","encode","getTransactionWithAllBatchSigners","exampleTransaction","JSON","stringify","transactionIDs","slice","some","sortedSigners","flatMap","filter","signer","sort","signer1","signer2","compareSigners","Object","assign"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/Wallet/batchSigner.ts"],"sourcesContent":["import { encode, encodeForSigningBatch } from 'ripple-binary-codec'\nimport { sign } from 'ripple-keypairs'\n\nimport { ValidationError } from '../errors'\nimport { Batch, Transaction, validate } from '../models'\nimport { BatchSigner, validateBatch } from '../models/transactions/batch'\nimport { hashSignedTx } from '../utils/hashes'\n\nimport { compareSigners, getDecodedTransaction } from './utils'\n\nimport type { Wallet } from './index'\n\n// eslint-disable-next-line max-params -- okay for helper function\nfunction constructBatchSignerObject(\n  batchAccount: string,\n  wallet: Wallet,\n  signature: string,\n  multisignAddress: string | false = false,\n): BatchSigner {\n  let batchSigner: BatchSigner\n  if (multisignAddress) {\n    batchSigner = {\n      BatchSigner: {\n        Account: batchAccount,\n        Signers: [\n          {\n            Signer: {\n              Account: multisignAddress,\n              SigningPubKey: wallet.publicKey,\n              TxnSignature: signature,\n            },\n          },\n        ],\n      },\n    }\n  } else {\n    batchSigner = {\n      BatchSigner: {\n        Account: batchAccount,\n        SigningPubKey: wallet.publicKey,\n        TxnSignature: signature,\n      },\n    }\n  }\n  return batchSigner\n}\n\n/**\n * Sign a multi-account Batch transaction.\n *\n * @param wallet - Wallet instance.\n * @param transaction - The Batch transaction to sign.\n * @param opts - Additional options for regular key and multi-signing complexity.\n * @param opts.batchAccount - The account submitting the inner Batch transaction, on behalf of which is this signature.\n * @param opts.multisign - Specify true/false to use multisign or actual address (classic/x-address) to make multisign tx request.\n *                       The actual address is only needed in the case of regular key usage.\n * @throws ValidationError if the transaction is malformed.\n */\nexport function signMultiBatch(\n  wallet: Wallet,\n  transaction: Batch,\n  opts: { batchAccount?: string; multisign?: boolean | string } = {},\n): void {\n  const batchAccount = opts.batchAccount ?? wallet.classicAddress\n  let multisignAddress: boolean | string = false\n  if (typeof opts.multisign === 'string') {\n    multisignAddress = opts.multisign\n  } else if (opts.multisign) {\n    multisignAddress = wallet.classicAddress\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- for JS purposes\n  if (transaction.TransactionType !== 'Batch') {\n    throw new ValidationError('Must be a Batch transaction.')\n  }\n  /*\n   * This will throw a more clear error for JS users if the supplied transaction has incorrect formatting\n   */\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- validate does not accept Transaction type\n  validate(transaction as unknown as Record<string, unknown>)\n\n  const involvedAccounts = new Set(\n    transaction.RawTransactions.map((raw) => raw.RawTransaction.Account),\n  )\n  if (!involvedAccounts.has(batchAccount)) {\n    throw new ValidationError(\n      'Must be signing for an address submitting a transaction in the Batch.',\n    )\n  }\n  const fieldsToSign = {\n    flags: transaction.Flags,\n    txIDs: transaction.RawTransactions.map((rawTx) =>\n      hashSignedTx(rawTx.RawTransaction),\n    ),\n  }\n  const signature = sign(encodeForSigningBatch(fieldsToSign), wallet.privateKey)\n\n  // eslint-disable-next-line no-param-reassign -- okay for signing\n  transaction.BatchSigners = [\n    constructBatchSignerObject(\n      batchAccount,\n      wallet,\n      signature,\n      multisignAddress,\n    ),\n  ]\n}\n\n/**\n * Takes several transactions with BatchSigners fields (in object or blob form) and creates a\n * single transaction with all BatchSigners that then gets signed and returned.\n *\n * @param transactions The transactions to combine `BatchSigners` values on.\n * @returns A single signed Transaction which has all BatchSigners from transactions within it.\n * @throws ValidationError if:\n * - There were no transactions given to sign\n * @category Signing\n */\nexport function combineBatchSigners(\n  transactions: Array<Batch | string>,\n): string {\n  if (transactions.length === 0) {\n    throw new ValidationError('There are 0 transactions to combine.')\n  }\n\n  const decodedTransactions: Transaction[] = transactions.map((txOrBlob) => {\n    return getDecodedTransaction(txOrBlob)\n  })\n\n  decodedTransactions.forEach((tx) => {\n    if (tx.TransactionType !== 'Batch') {\n      throw new ValidationError('TransactionType must be `Batch`.')\n    }\n    /*\n     * This will throw a more clear error for JS users if any of the supplied transactions has incorrect formatting\n     */\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- validate does not accept Transaction type\n    validateBatch(tx as unknown as Record<string, unknown>)\n    if (tx.BatchSigners == null || tx.BatchSigners.length === 0) {\n      throw new ValidationError(\n        'For combining Batch transaction signatures, all transactions must include a BatchSigners field containing an array of signatures.',\n      )\n    }\n\n    if (tx.TxnSignature != null || tx.Signers != null) {\n      throw new ValidationError('Batch transaction must be unsigned.')\n    }\n  })\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- checked above\n  const batchTransactions = decodedTransactions as Batch[]\n\n  validateBatchTransactionEquivalence(batchTransactions)\n\n  return encode(getTransactionWithAllBatchSigners(batchTransactions))\n}\n\n/**\n * The transactions should all be equal except for the 'Signers' field.\n *\n * @param transactions - An array of Transactions which are expected to be equal other than 'Signers'.\n * @throws ValidationError if the transactions are not equal in any field other than 'Signers'.\n */\nfunction validateBatchTransactionEquivalence(transactions: Batch[]): void {\n  const exampleTransaction = JSON.stringify({\n    flags: transactions[0].Flags,\n    transactionIDs: transactions[0].RawTransactions.map((rawTx) =>\n      hashSignedTx(rawTx.RawTransaction),\n    ),\n  })\n  if (\n    transactions.slice(1).some(\n      (tx) =>\n        JSON.stringify({\n          flags: tx.Flags,\n          transactionIDs: tx.RawTransactions.map((rawTx) =>\n            hashSignedTx(rawTx.RawTransaction),\n          ),\n        }) !== exampleTransaction,\n    )\n  ) {\n    throw new ValidationError(\n      'Flags and transaction hashes are not the same for all provided transactions.',\n    )\n  }\n}\n\nfunction getTransactionWithAllBatchSigners(transactions: Batch[]): Batch {\n  // Signers must be sorted in the combined transaction - See compareSigners' documentation for more details\n  const sortedSigners: BatchSigner[] = transactions\n    .flatMap((tx) => tx.BatchSigners ?? [])\n    .filter((signer) => signer.BatchSigner.Account !== transactions[0].Account)\n    .sort((signer1, signer2) =>\n      compareSigners(signer1.BatchSigner, signer2.BatchSigner),\n    )\n\n  return { ...transactions[0], BatchSigners: sortedSigners }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}