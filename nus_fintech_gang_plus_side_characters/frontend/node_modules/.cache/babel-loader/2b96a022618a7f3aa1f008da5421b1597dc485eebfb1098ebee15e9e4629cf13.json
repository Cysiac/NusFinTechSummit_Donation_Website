{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateMPTokenIssuanceSet = exports.MPTokenIssuanceSetFlags = void 0;\nconst errors_1 = require(\"../../errors\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nvar MPTokenIssuanceSetFlags;\n(function (MPTokenIssuanceSetFlags) {\n  MPTokenIssuanceSetFlags[MPTokenIssuanceSetFlags[\"tfMPTLock\"] = 1] = \"tfMPTLock\";\n  MPTokenIssuanceSetFlags[MPTokenIssuanceSetFlags[\"tfMPTUnlock\"] = 2] = \"tfMPTUnlock\";\n})(MPTokenIssuanceSetFlags || (exports.MPTokenIssuanceSetFlags = MPTokenIssuanceSetFlags = {}));\nfunction validateMPTokenIssuanceSet(tx) {\n  var _a, _b, _c;\n  (0, common_1.validateBaseTransaction)(tx);\n  (0, common_1.validateRequiredField)(tx, 'MPTokenIssuanceID', common_1.isString);\n  (0, common_1.validateOptionalField)(tx, 'Holder', common_1.isAccount);\n  const flags = (_a = tx.Flags) !== null && _a !== void 0 ? _a : 0;\n  const isTfMPTLock = typeof flags === 'number' ? (0, utils_1.isFlagEnabled)(flags, MPTokenIssuanceSetFlags.tfMPTLock) : (_b = flags.tfMPTLock) !== null && _b !== void 0 ? _b : false;\n  const isTfMPTUnlock = typeof flags === 'number' ? (0, utils_1.isFlagEnabled)(flags, MPTokenIssuanceSetFlags.tfMPTUnlock) : (_c = flags.tfMPTUnlock) !== null && _c !== void 0 ? _c : false;\n  if (isTfMPTLock && isTfMPTUnlock) {\n    throw new errors_1.ValidationError('MPTokenIssuanceSet: flag conflict');\n  }\n}\nexports.validateMPTokenIssuanceSet = validateMPTokenIssuanceSet;","map":{"version":3,"names":["errors_1","require","utils_1","common_1","MPTokenIssuanceSetFlags","exports","validateMPTokenIssuanceSet","tx","validateBaseTransaction","validateRequiredField","isString","validateOptionalField","isAccount","flags","_a","Flags","isTfMPTLock","isFlagEnabled","tfMPTLock","_b","isTfMPTUnlock","tfMPTUnlock","_c","ValidationError"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/models/transactions/MPTokenIssuanceSet.ts"],"sourcesContent":["import { ValidationError } from '../../errors'\nimport { isFlagEnabled } from '../utils'\n\nimport {\n  BaseTransaction,\n  isString,\n  validateBaseTransaction,\n  validateRequiredField,\n  Account,\n  validateOptionalField,\n  isAccount,\n  GlobalFlagsInterface,\n} from './common'\n\n/**\n * Transaction Flags for an MPTokenIssuanceSet Transaction.\n *\n * @category Transaction Flags\n */\nexport enum MPTokenIssuanceSetFlags {\n  /**\n   * If set, indicates that issuer locks the MPT\n   */\n  tfMPTLock = 0x00000001,\n  /**\n   * If set, indicates that issuer unlocks the MPT\n   */\n  tfMPTUnlock = 0x00000002,\n}\n\n/**\n * Map of flags to boolean values representing {@link MPTokenIssuanceSet} transaction\n * flags.\n *\n * @category Transaction Flags\n */\nexport interface MPTokenIssuanceSetFlagsInterface extends GlobalFlagsInterface {\n  tfMPTLock?: boolean\n  tfMPTUnlock?: boolean\n}\n\n/**\n * The MPTokenIssuanceSet transaction is used to globally lock/unlock a MPTokenIssuance,\n * or lock/unlock an individual's MPToken.\n */\nexport interface MPTokenIssuanceSet extends BaseTransaction {\n  TransactionType: 'MPTokenIssuanceSet'\n  /**\n   * Identifies the MPTokenIssuance\n   */\n  MPTokenIssuanceID: string\n  /**\n   * An optional XRPL Address of an individual token holder balance to lock/unlock.\n   * If omitted, this transaction will apply to all any accounts holding MPTs.\n   */\n  Holder?: Account\n  Flags?: number | MPTokenIssuanceSetFlagsInterface\n}\n\n/**\n * Verify the form and type of an MPTokenIssuanceSet at runtime.\n *\n * @param tx - An MPTokenIssuanceSet Transaction.\n * @throws When the MPTokenIssuanceSet is Malformed.\n */\nexport function validateMPTokenIssuanceSet(tx: Record<string, unknown>): void {\n  validateBaseTransaction(tx)\n  validateRequiredField(tx, 'MPTokenIssuanceID', isString)\n  validateOptionalField(tx, 'Holder', isAccount)\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Not necessary\n  const flags = (tx.Flags ?? 0) as number | MPTokenIssuanceSetFlagsInterface\n  const isTfMPTLock =\n    typeof flags === 'number'\n      ? isFlagEnabled(flags, MPTokenIssuanceSetFlags.tfMPTLock)\n      : (flags.tfMPTLock ?? false)\n\n  const isTfMPTUnlock =\n    typeof flags === 'number'\n      ? isFlagEnabled(flags, MPTokenIssuanceSetFlags.tfMPTUnlock)\n      : (flags.tfMPTUnlock ?? false)\n\n  if (isTfMPTLock && isTfMPTUnlock) {\n    throw new ValidationError('MPTokenIssuanceSet: flag conflict')\n  }\n}\n"],"mappings":";;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,OAAA,GAAAD,OAAA;AAEA,MAAAE,QAAA,GAAAF,OAAA;AAgBA,IAAYG,uBASX;AATD,WAAYA,uBAAuB;EAIjCA,uBAAA,CAAAA,uBAAA,gCAAsB;EAItBA,uBAAA,CAAAA,uBAAA,oCAAwB;AAC1B,CAAC,EATWA,uBAAuB,KAAAC,OAAA,CAAAD,uBAAA,GAAvBA,uBAAuB;AA8CnC,SAAgBE,0BAA0BA,CAACC,EAA2B;;EACpE,IAAAJ,QAAA,CAAAK,uBAAuB,EAACD,EAAE,CAAC;EAC3B,IAAAJ,QAAA,CAAAM,qBAAqB,EAACF,EAAE,EAAE,mBAAmB,EAAEJ,QAAA,CAAAO,QAAQ,CAAC;EACxD,IAAAP,QAAA,CAAAQ,qBAAqB,EAACJ,EAAE,EAAE,QAAQ,EAAEJ,QAAA,CAAAS,SAAS,CAAC;EAG9C,MAAMC,KAAK,GAAI,CAAAC,EAAA,GAAAP,EAAE,CAACQ,KAAK,cAAAD,EAAA,cAAAA,EAAA,GAAI,CAA+C;EAC1E,MAAME,WAAW,GACf,OAAOH,KAAK,KAAK,QAAQ,GACrB,IAAAX,OAAA,CAAAe,aAAa,EAACJ,KAAK,EAAET,uBAAuB,CAACc,SAAS,CAAC,GACtD,CAAAC,EAAA,GAAAN,KAAK,CAACK,SAAS,cAAAC,EAAA,cAAAA,EAAA,GAAI,KAAM;EAEhC,MAAMC,aAAa,GACjB,OAAOP,KAAK,KAAK,QAAQ,GACrB,IAAAX,OAAA,CAAAe,aAAa,EAACJ,KAAK,EAAET,uBAAuB,CAACiB,WAAW,CAAC,GACxD,CAAAC,EAAA,GAAAT,KAAK,CAACQ,WAAW,cAAAC,EAAA,cAAAA,EAAA,GAAI,KAAM;EAElC,IAAIN,WAAW,IAAII,aAAa,EAAE;IAChC,MAAM,IAAIpB,QAAA,CAAAuB,eAAe,CAAC,mCAAmC,CAAC;;AAElE;AApBAlB,OAAA,CAAAC,0BAAA,GAAAA,0BAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}