{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.STNumber = void 0;\nconst serialized_type_1 = require(\"./serialized-type\");\nconst utils_1 = require(\"../utils\");\n/**\n * Constants for mantissa and exponent normalization per XRPL Number spec.\n * These define allowed magnitude for mantissa and exponent after normalization.\n */\nconst MIN_MANTISSA = BigInt('1000000000000000');\nconst MAX_MANTISSA = BigInt('9999999999999999');\nconst MIN_EXPONENT = -32768;\nconst MAX_EXPONENT = 32768;\nconst DEFAULT_VALUE_EXPONENT = -2147483648;\n/**\n * Extract mantissa, exponent, and sign from a number string.\n *\n * @param val - The string representing the number (may be integer, decimal, or scientific notation).\n * @returns Object containing mantissa (BigInt), exponent (number), and isNegative (boolean).\n * @throws Error if the string cannot be parsed as a valid number.\n *\n * Examples:\n *   '123'        -> { mantissa: 123n, exponent: 0, isNegative: false }\n *   '-00123.45'  -> { mantissa: -12345n, exponent: -2, isNegative: true }\n *   '+7.1e2'     -> { mantissa: 71n, exponent: -1 + 2 = 1, isNegative: false }\n */\nfunction extractNumberPartsFromString(val) {\n  /**\n   * Regex for parsing decimal/float/scientific number strings with optional sign, integer, decimal, and exponent parts.\n   *\n   * Pattern: /^([-+]?)([0-9]+)(?:\\.([0-9]+))?(?:[eE]([+-]?[0-9]+))?$/\n   *\n   * Breakdown:\n   *   1. ([-+]?)         - Optional '+' or '-' sign at the start.\n   *   2. ([0-9]+)        - Integer part: one or more digits (leading zeros allowed).\n   *   3. (?:\\.([0-9]+))? - Optional decimal point followed by one or more digits.\n   *   4. (?:[eE]([+-]?[0-9]+))? - Optional exponent, starting with 'e' or 'E', optional sign, and digits.\n   *\n   * Notes:\n   *   - Leading zeros are accepted and normalized by code after parsing.\n   *   - Empty decimal ('123.') and missing integer ('.456') are NOT matched—must be fully specified.\n   */\n  // eslint-disable-next-line prefer-named-capture-group\n  const regex = /^([-+]?)([0-9]+)(?:\\.([0-9]+))?(?:[eE]([+-]?[0-9]+))?$/;\n  const match = regex.exec(val);\n  if (!match) throw new Error(`Unable to parse number from string: ${val}`);\n  const [, sign, intPart, fracPart, expPart] = match;\n  // Remove leading zeros (unless the entire intPart is zeros)\n  const cleanIntPart = intPart.replace(/^0+(?=\\d)/, '') || '0';\n  let mantissaStr = cleanIntPart;\n  let exponent = 0;\n  if (fracPart) {\n    mantissaStr += fracPart;\n    exponent -= fracPart.length;\n  }\n  if (expPart) exponent += parseInt(expPart, 10);\n  let mantissa = BigInt(mantissaStr);\n  if (sign === '-') mantissa = -mantissa;\n  const isNegative = mantissa < BigInt(0);\n  return {\n    mantissa,\n    exponent,\n    isNegative\n  };\n}\n/**\n * Normalize the mantissa and exponent to XRPL constraints.\n *\n * Ensures that after normalization, the mantissa is between MIN_MANTISSA and MAX_MANTISSA (unless zero).\n * Adjusts the exponent as needed by shifting the mantissa left/right (multiplying/dividing by 10).\n *\n * @param mantissa - The unnormalized mantissa (BigInt).\n * @param exponent - The unnormalized exponent (number).\n * @returns An object with normalized mantissa and exponent.\n * @throws Error if the number cannot be normalized within allowed exponent range.\n */\nfunction normalize(mantissa, exponent) {\n  let m = mantissa < BigInt(0) ? -mantissa : mantissa;\n  const isNegative = mantissa < BigInt(0);\n  while (m !== BigInt(0) && m < MIN_MANTISSA && exponent > MIN_EXPONENT) {\n    exponent -= 1;\n    m *= BigInt(10);\n  }\n  while (m > MAX_MANTISSA) {\n    if (exponent >= MAX_EXPONENT) throw new Error('Mantissa and exponent are too large');\n    exponent += 1;\n    m /= BigInt(10);\n  }\n  if (isNegative) m = -m;\n  return {\n    mantissa: m,\n    exponent\n  };\n}\n/**\n * STNumber: Encodes XRPL's \"Number\" type.\n *\n * - Always encoded as 12 bytes: 8-byte signed mantissa, 4-byte signed exponent, both big-endian.\n * - Can only be constructed from a valid number string or another STNumber instance.\n *\n * Usage:\n *   STNumber.from(\"1.2345e5\")\n *   STNumber.from(\"-123\")\n *   STNumber.fromParser(parser)\n */\nclass STNumber extends serialized_type_1.SerializedType {\n  /**\n   * Construct a STNumber from 12 bytes (8 for mantissa, 4 for exponent).\n   * @param bytes - 12-byte Uint8Array\n   * @throws Error if input is not a Uint8Array of length 12.\n   */\n  constructor(bytes) {\n    const used = bytes !== null && bytes !== void 0 ? bytes : STNumber.defaultBytes;\n    if (!(used instanceof Uint8Array) || used.length !== 12) {\n      throw new Error(`STNumber must be constructed from a 12-byte Uint8Array, got ${used === null || used === void 0 ? void 0 : used.length}`);\n    }\n    super(used);\n  }\n  /**\n   * Construct from a number string (or another STNumber).\n   *\n   * @param value - A string, or STNumber instance.\n   * @returns STNumber instance.\n   * @throws Error if not a string or STNumber.\n   */\n  static from(value) {\n    if (value instanceof STNumber) {\n      return value;\n    }\n    if (typeof value === 'string') {\n      return STNumber.fromValue(value);\n    }\n    throw new Error('STNumber.from: Only string or STNumber instance is supported');\n  }\n  /**\n   * Construct from a number string (integer, decimal, or scientific notation).\n   * Handles normalization to XRPL Number constraints.\n   *\n   * @param val - The number as a string (e.g. '1.23', '-123e5').\n   * @returns STNumber instance\n   * @throws Error if val is not a valid number string.\n   */\n  static fromValue(val) {\n    const {\n      mantissa,\n      exponent,\n      isNegative\n    } = extractNumberPartsFromString(val);\n    let normalizedMantissa;\n    let normalizedExponent;\n    if (mantissa === BigInt(0) && exponent === 0 && !isNegative) {\n      normalizedMantissa = BigInt(0);\n      normalizedExponent = DEFAULT_VALUE_EXPONENT;\n    } else {\n      ;\n      ({\n        mantissa: normalizedMantissa,\n        exponent: normalizedExponent\n      } = normalize(mantissa, exponent));\n    }\n    const bytes = new Uint8Array(12);\n    (0, utils_1.writeInt64BE)(bytes, normalizedMantissa, 0);\n    (0, utils_1.writeInt32BE)(bytes, normalizedExponent, 8);\n    return new STNumber(bytes);\n  }\n  /**\n   * Read a STNumber from a BinaryParser stream (12 bytes).\n   * @param parser - BinaryParser positioned at the start of a number\n   * @returns STNumber instance\n   */\n  static fromParser(parser) {\n    return new STNumber(parser.read(12));\n  }\n  /**\n   * Convert this STNumber to a normalized string representation.\n   * The output is decimal or scientific notation, depending on exponent range.\n   * Follows XRPL convention: zero is \"0\", other values are normalized to a canonical string.\n   *\n   * @returns String representation of the value\n   */\n  // eslint-disable-next-line complexity -- required\n  toJSON() {\n    const b = this.bytes;\n    if (!b || b.length !== 12) throw new Error('STNumber internal bytes not set or wrong length');\n    // Signed 64-bit mantissa\n    const mantissa = (0, utils_1.readInt64BE)(b, 0);\n    // Signed 32-bit exponent\n    const exponent = (0, utils_1.readInt32BE)(b, 8);\n    // Special zero: XRPL encodes canonical zero as mantissa=0, exponent=DEFAULT_VALUE_EXPONENT.\n    if (mantissa === BigInt(0) && exponent === DEFAULT_VALUE_EXPONENT) {\n      return '0';\n    }\n    if (exponent === 0) return mantissa.toString();\n    // Use scientific notation for small/large exponents, decimal otherwise\n    if (exponent < -25 || exponent > -5) {\n      return `${mantissa}e${exponent}`;\n    }\n    // Decimal rendering for -25 <= exp <= -5\n    const isNegative = mantissa < BigInt(0);\n    const mantissaAbs = mantissa < BigInt(0) ? -mantissa : mantissa;\n    const padPrefix = 27;\n    const padSuffix = 23;\n    const mantissaStr = mantissaAbs.toString();\n    const rawValue = '0'.repeat(padPrefix) + mantissaStr + '0'.repeat(padSuffix);\n    const OFFSET = exponent + 43;\n    const integerPart = rawValue.slice(0, OFFSET).replace(/^0+/, '') || '0';\n    const fractionPart = rawValue.slice(OFFSET).replace(/0+$/, '');\n    return `${isNegative ? '-' : ''}${integerPart}${fractionPart ? '.' + fractionPart : ''}`;\n  }\n}\nexports.STNumber = STNumber;\n/** 12 zero bytes, represents canonical zero. */\nSTNumber.defaultBytes = new Uint8Array(12);","map":{"version":3,"names":["serialized_type_1","require","utils_1","MIN_MANTISSA","BigInt","MAX_MANTISSA","MIN_EXPONENT","MAX_EXPONENT","DEFAULT_VALUE_EXPONENT","extractNumberPartsFromString","val","regex","match","exec","Error","sign","intPart","fracPart","expPart","cleanIntPart","replace","mantissaStr","exponent","length","parseInt","mantissa","isNegative","normalize","m","STNumber","SerializedType","constructor","bytes","used","defaultBytes","Uint8Array","from","value","fromValue","normalizedMantissa","normalizedExponent","writeInt64BE","writeInt32BE","fromParser","parser","read","toJSON","b","readInt64BE","readInt32BE","toString","mantissaAbs","padPrefix","padSuffix","rawValue","repeat","OFFSET","integerPart","slice","fractionPart","exports"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/ripple-binary-codec/src/types/st-number.ts"],"sourcesContent":["import { BinaryParser } from '../serdes/binary-parser'\nimport { SerializedType } from './serialized-type'\nimport { writeInt32BE, writeInt64BE, readInt32BE, readInt64BE } from '../utils'\n\n/**\n * Constants for mantissa and exponent normalization per XRPL Number spec.\n * These define allowed magnitude for mantissa and exponent after normalization.\n */\nconst MIN_MANTISSA = BigInt('1000000000000000')\nconst MAX_MANTISSA = BigInt('9999999999999999')\nconst MIN_EXPONENT = -32768\nconst MAX_EXPONENT = 32768\nconst DEFAULT_VALUE_EXPONENT = -2147483648\n\n/**\n * Extract mantissa, exponent, and sign from a number string.\n *\n * @param val - The string representing the number (may be integer, decimal, or scientific notation).\n * @returns Object containing mantissa (BigInt), exponent (number), and isNegative (boolean).\n * @throws Error if the string cannot be parsed as a valid number.\n *\n * Examples:\n *   '123'        -> { mantissa: 123n, exponent: 0, isNegative: false }\n *   '-00123.45'  -> { mantissa: -12345n, exponent: -2, isNegative: true }\n *   '+7.1e2'     -> { mantissa: 71n, exponent: -1 + 2 = 1, isNegative: false }\n */\nfunction extractNumberPartsFromString(val: string): {\n  mantissa: bigint\n  exponent: number\n  isNegative: boolean\n} {\n  /**\n   * Regex for parsing decimal/float/scientific number strings with optional sign, integer, decimal, and exponent parts.\n   *\n   * Pattern: /^([-+]?)([0-9]+)(?:\\.([0-9]+))?(?:[eE]([+-]?[0-9]+))?$/\n   *\n   * Breakdown:\n   *   1. ([-+]?)         - Optional '+' or '-' sign at the start.\n   *   2. ([0-9]+)        - Integer part: one or more digits (leading zeros allowed).\n   *   3. (?:\\.([0-9]+))? - Optional decimal point followed by one or more digits.\n   *   4. (?:[eE]([+-]?[0-9]+))? - Optional exponent, starting with 'e' or 'E', optional sign, and digits.\n   *\n   * Notes:\n   *   - Leading zeros are accepted and normalized by code after parsing.\n   *   - Empty decimal ('123.') and missing integer ('.456') are NOT matched—must be fully specified.\n   */\n  // eslint-disable-next-line prefer-named-capture-group\n  const regex = /^([-+]?)([0-9]+)(?:\\.([0-9]+))?(?:[eE]([+-]?[0-9]+))?$/\n  const match = regex.exec(val)\n  if (!match) throw new Error(`Unable to parse number from string: ${val}`)\n\n  const [, sign, intPart, fracPart, expPart] = match\n  // Remove leading zeros (unless the entire intPart is zeros)\n  const cleanIntPart = intPart.replace(/^0+(?=\\d)/, '') || '0'\n\n  let mantissaStr = cleanIntPart\n  let exponent = 0\n\n  if (fracPart) {\n    mantissaStr += fracPart\n    exponent -= fracPart.length\n  }\n  if (expPart) exponent += parseInt(expPart, 10)\n\n  let mantissa = BigInt(mantissaStr)\n  if (sign === '-') mantissa = -mantissa\n  const isNegative = mantissa < BigInt(0)\n\n  return { mantissa, exponent, isNegative }\n}\n\n/**\n * Normalize the mantissa and exponent to XRPL constraints.\n *\n * Ensures that after normalization, the mantissa is between MIN_MANTISSA and MAX_MANTISSA (unless zero).\n * Adjusts the exponent as needed by shifting the mantissa left/right (multiplying/dividing by 10).\n *\n * @param mantissa - The unnormalized mantissa (BigInt).\n * @param exponent - The unnormalized exponent (number).\n * @returns An object with normalized mantissa and exponent.\n * @throws Error if the number cannot be normalized within allowed exponent range.\n */\nfunction normalize(\n  mantissa: bigint,\n  exponent: number,\n): { mantissa: bigint; exponent: number } {\n  let m = mantissa < BigInt(0) ? -mantissa : mantissa\n  const isNegative = mantissa < BigInt(0)\n\n  while (m !== BigInt(0) && m < MIN_MANTISSA && exponent > MIN_EXPONENT) {\n    exponent -= 1\n    m *= BigInt(10)\n  }\n  while (m > MAX_MANTISSA) {\n    if (exponent >= MAX_EXPONENT)\n      throw new Error('Mantissa and exponent are too large')\n    exponent += 1\n    m /= BigInt(10)\n  }\n  if (isNegative) m = -m\n  return { mantissa: m, exponent }\n}\n\n/**\n * STNumber: Encodes XRPL's \"Number\" type.\n *\n * - Always encoded as 12 bytes: 8-byte signed mantissa, 4-byte signed exponent, both big-endian.\n * - Can only be constructed from a valid number string or another STNumber instance.\n *\n * Usage:\n *   STNumber.from(\"1.2345e5\")\n *   STNumber.from(\"-123\")\n *   STNumber.fromParser(parser)\n */\nexport class STNumber extends SerializedType {\n  /** 12 zero bytes, represents canonical zero. */\n  static defaultBytes = new Uint8Array(12)\n\n  /**\n   * Construct a STNumber from 12 bytes (8 for mantissa, 4 for exponent).\n   * @param bytes - 12-byte Uint8Array\n   * @throws Error if input is not a Uint8Array of length 12.\n   */\n  constructor(bytes?: Uint8Array) {\n    const used = bytes ?? STNumber.defaultBytes\n    if (!(used instanceof Uint8Array) || used.length !== 12) {\n      throw new Error(\n        `STNumber must be constructed from a 12-byte Uint8Array, got ${used?.length}`,\n      )\n    }\n    super(used)\n  }\n\n  /**\n   * Construct from a number string (or another STNumber).\n   *\n   * @param value - A string, or STNumber instance.\n   * @returns STNumber instance.\n   * @throws Error if not a string or STNumber.\n   */\n  static from(value: unknown): STNumber {\n    if (value instanceof STNumber) {\n      return value\n    }\n    if (typeof value === 'string') {\n      return STNumber.fromValue(value)\n    }\n    throw new Error(\n      'STNumber.from: Only string or STNumber instance is supported',\n    )\n  }\n\n  /**\n   * Construct from a number string (integer, decimal, or scientific notation).\n   * Handles normalization to XRPL Number constraints.\n   *\n   * @param val - The number as a string (e.g. '1.23', '-123e5').\n   * @returns STNumber instance\n   * @throws Error if val is not a valid number string.\n   */\n  static fromValue(val: string): STNumber {\n    const { mantissa, exponent, isNegative } = extractNumberPartsFromString(val)\n    let normalizedMantissa: bigint\n    let normalizedExponent: number\n\n    if (mantissa === BigInt(0) && exponent === 0 && !isNegative) {\n      normalizedMantissa = BigInt(0)\n      normalizedExponent = DEFAULT_VALUE_EXPONENT\n    } else {\n      ;({ mantissa: normalizedMantissa, exponent: normalizedExponent } =\n        normalize(mantissa, exponent))\n    }\n\n    const bytes = new Uint8Array(12)\n    writeInt64BE(bytes, normalizedMantissa, 0)\n    writeInt32BE(bytes, normalizedExponent, 8)\n    return new STNumber(bytes)\n  }\n\n  /**\n   * Read a STNumber from a BinaryParser stream (12 bytes).\n   * @param parser - BinaryParser positioned at the start of a number\n   * @returns STNumber instance\n   */\n  static fromParser(parser: BinaryParser): STNumber {\n    return new STNumber(parser.read(12))\n  }\n\n  /**\n   * Convert this STNumber to a normalized string representation.\n   * The output is decimal or scientific notation, depending on exponent range.\n   * Follows XRPL convention: zero is \"0\", other values are normalized to a canonical string.\n   *\n   * @returns String representation of the value\n   */\n  // eslint-disable-next-line complexity -- required\n  toJSON(): string {\n    const b = this.bytes\n    if (!b || b.length !== 12)\n      throw new Error('STNumber internal bytes not set or wrong length')\n\n    // Signed 64-bit mantissa\n    const mantissa = readInt64BE(b, 0)\n    // Signed 32-bit exponent\n    const exponent = readInt32BE(b, 8)\n\n    // Special zero: XRPL encodes canonical zero as mantissa=0, exponent=DEFAULT_VALUE_EXPONENT.\n    if (mantissa === BigInt(0) && exponent === DEFAULT_VALUE_EXPONENT) {\n      return '0'\n    }\n    if (exponent === 0) return mantissa.toString()\n\n    // Use scientific notation for small/large exponents, decimal otherwise\n    if (exponent < -25 || exponent > -5) {\n      return `${mantissa}e${exponent}`\n    }\n\n    // Decimal rendering for -25 <= exp <= -5\n    const isNegative = mantissa < BigInt(0)\n    const mantissaAbs = mantissa < BigInt(0) ? -mantissa : mantissa\n\n    const padPrefix = 27\n    const padSuffix = 23\n    const mantissaStr = mantissaAbs.toString()\n    const rawValue = '0'.repeat(padPrefix) + mantissaStr + '0'.repeat(padSuffix)\n    const OFFSET = exponent + 43\n    const integerPart = rawValue.slice(0, OFFSET).replace(/^0+/, '') || '0'\n    const fractionPart = rawValue.slice(OFFSET).replace(/0+$/, '')\n\n    return `${isNegative ? '-' : ''}${integerPart}${\n      fractionPart ? '.' + fractionPart : ''\n    }`\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}