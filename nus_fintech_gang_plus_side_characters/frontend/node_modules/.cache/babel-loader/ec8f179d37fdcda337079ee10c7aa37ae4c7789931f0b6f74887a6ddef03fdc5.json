{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePayment = exports.PaymentFlags = void 0;\nconst errors_1 = require(\"../../errors\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nvar PaymentFlags;\n(function (PaymentFlags) {\n  PaymentFlags[PaymentFlags[\"tfNoRippleDirect\"] = 65536] = \"tfNoRippleDirect\";\n  PaymentFlags[PaymentFlags[\"tfPartialPayment\"] = 131072] = \"tfPartialPayment\";\n  PaymentFlags[PaymentFlags[\"tfLimitQuality\"] = 262144] = \"tfLimitQuality\";\n})(PaymentFlags || (exports.PaymentFlags = PaymentFlags = {}));\nfunction validatePayment(tx) {\n  (0, common_1.validateBaseTransaction)(tx);\n  if (tx.Amount === undefined) {\n    throw new errors_1.ValidationError('PaymentTransaction: missing field Amount');\n  }\n  if (!(0, common_1.isAmount)(tx.Amount)) {\n    throw new errors_1.ValidationError('PaymentTransaction: invalid Amount');\n  }\n  (0, common_1.validateRequiredField)(tx, 'Destination', common_1.isAccount);\n  (0, common_1.validateOptionalField)(tx, 'DestinationTag', common_1.isNumber);\n  (0, common_1.validateCredentialsList)(tx.CredentialIDs, tx.TransactionType, true, common_1.MAX_AUTHORIZED_CREDENTIALS);\n  if (tx.InvoiceID !== undefined && typeof tx.InvoiceID !== 'string') {\n    throw new errors_1.ValidationError('PaymentTransaction: InvoiceID must be a string');\n  }\n  (0, common_1.validateOptionalField)(tx, 'DomainID', common_1.isDomainID, {\n    txType: 'PaymentTransaction',\n    paramName: 'DomainID'\n  });\n  if (tx.Paths !== undefined && !isPaths(tx.Paths)) {\n    throw new errors_1.ValidationError('PaymentTransaction: invalid Paths');\n  }\n  if (tx.SendMax !== undefined && !(0, common_1.isAmount)(tx.SendMax)) {\n    throw new errors_1.ValidationError('PaymentTransaction: invalid SendMax');\n  }\n  checkPartialPayment(tx);\n}\nexports.validatePayment = validatePayment;\nfunction checkPartialPayment(tx) {\n  var _a;\n  if (tx.DeliverMin != null) {\n    if (tx.Flags == null) {\n      throw new errors_1.ValidationError('PaymentTransaction: tfPartialPayment flag required with DeliverMin');\n    }\n    const flags = tx.Flags;\n    const isTfPartialPayment = typeof flags === 'number' ? (0, utils_1.isFlagEnabled)(flags, PaymentFlags.tfPartialPayment) : (_a = flags.tfPartialPayment) !== null && _a !== void 0 ? _a : false;\n    if (!isTfPartialPayment) {\n      throw new errors_1.ValidationError('PaymentTransaction: tfPartialPayment flag required with DeliverMin');\n    }\n    if (!(0, common_1.isAmount)(tx.DeliverMin)) {\n      throw new errors_1.ValidationError('PaymentTransaction: invalid DeliverMin');\n    }\n  }\n}\nfunction isPathStep(pathStep) {\n  if (pathStep.account !== undefined && typeof pathStep.account !== 'string') {\n    return false;\n  }\n  if (pathStep.currency !== undefined && typeof pathStep.currency !== 'string') {\n    return false;\n  }\n  if (pathStep.issuer !== undefined && typeof pathStep.issuer !== 'string') {\n    return false;\n  }\n  if (pathStep.account !== undefined && pathStep.currency === undefined && pathStep.issuer === undefined) {\n    return true;\n  }\n  if (pathStep.currency !== undefined || pathStep.issuer !== undefined) {\n    return true;\n  }\n  return false;\n}\nfunction isPath(path) {\n  if (!Array.isArray(path) || path.length === 0) {\n    return false;\n  }\n  for (const pathStep of path) {\n    if (!isPathStep(pathStep)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPaths(paths) {\n  if (!(0, common_1.isArray)(paths) || paths.length === 0) {\n    return false;\n  }\n  for (const path of paths) {\n    if (!(0, common_1.isArray)(path) || path.length === 0) {\n      return false;\n    }\n    if (!isPath(path)) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["errors_1","require","utils_1","common_1","PaymentFlags","exports","validatePayment","tx","validateBaseTransaction","Amount","undefined","ValidationError","isAmount","validateRequiredField","isAccount","validateOptionalField","isNumber","validateCredentialsList","CredentialIDs","TransactionType","MAX_AUTHORIZED_CREDENTIALS","InvoiceID","isDomainID","txType","paramName","Paths","isPaths","SendMax","checkPartialPayment","DeliverMin","Flags","flags","isTfPartialPayment","isFlagEnabled","tfPartialPayment","_a","isPathStep","pathStep","account","currency","issuer","isPath","path","Array","isArray","length","paths"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/models/transactions/payment.ts"],"sourcesContent":["import { ValidationError } from '../../errors'\nimport { Amount, Path, MPTAmount } from '../common'\nimport { isFlagEnabled } from '../utils'\n\nimport {\n  BaseTransaction,\n  isAmount,\n  GlobalFlagsInterface,\n  validateBaseTransaction,\n  isAccount,\n  isDomainID,\n  validateRequiredField,\n  validateOptionalField,\n  isNumber,\n  Account,\n  validateCredentialsList,\n  MAX_AUTHORIZED_CREDENTIALS,\n  isArray,\n} from './common'\nimport type { TransactionMetadataBase } from './metadata'\n\n/**\n * Enum representing values for Payment Transaction Flags.\n *\n * @category Transaction Flags\n */\nexport enum PaymentFlags {\n  /**\n   * Do not use the default path; only use paths included in the Paths field.\n   * This is intended to force the transaction to take arbitrage opportunities.\n   * Most clients do not need this.\n   */\n  tfNoRippleDirect = 0x00010000,\n  /**\n   * If the specified Amount cannot be sent without spending more than SendMax,\n   * reduce the received amount instead of failing outright. See Partial.\n   * Payments for more details.\n   */\n  tfPartialPayment = 0x00020000,\n  /**\n   * Only take paths where all the conversions have an input:output ratio that\n   * is equal or better than the ratio of Amount:SendMax. See Limit Quality for\n   * details.\n   */\n  tfLimitQuality = 0x00040000,\n}\n\n/**\n * Map of flags to boolean values representing {@link Payment} transaction\n * flags.\n *\n * @category Transaction Flags\n *\n * @example\n * ```typescript\n * const partialPayment: Payment = {\n *  TransactionType: 'Payment',\n *  Account: 'rM9WCfJU6udpFkvKThRaFHDMsp7L8rpgN',\n *  Amount: {\n *    currency: 'FOO',\n *    value: '4000',\n *    issuer: 'rPzwM2JfCSDjhbesdTCqFjWWdK7eFtTwZz',\n *  },\n *  Destination: 'rPzwM2JfCSDjhbesdTCqFjWWdK7eFtTwZz',\n *  Flags: {\n *    tfPartialPayment: true\n *  }\n * }\n *\n * // Autofill the tx to see how flags actually look compared to the interface usage.\n * const autofilledTx = await client.autofill(partialPayment)\n * console.log(autofilledTx)\n * // {\n * //  TransactionType: 'Payment',\n * //  Account: 'rM9WCfJU6udpFkvKThRaFHDMsp7L8rpgN',\n * //  Amount: {\n * //   currency: 'FOO',\n * //   value: '4000',\n * //   issuer: 'rPzwM2JfCSDjhbesdTCqFjWWdK7eFtTwZz'\n * //  },\n * //  Destination: 'rPzwM2JfCSDjhbesdTCqFjWWdK7eFtTwZz',\n * //  Flags: 131072,\n * //  Sequence: 21970996,\n * //  Fee: '12',\n * //  LastLedgerSequence: 21971016\n * // }\n * ```\n */\nexport interface PaymentFlagsInterface extends GlobalFlagsInterface {\n  /**\n   * Do not use the default path; only use paths included in the Paths field.\n   * This is intended to force the transaction to take arbitrage opportunities.\n   * Most clients do not need this.\n   */\n  tfNoRippleDirect?: boolean\n  /**\n   * If the specified Amount cannot be sent without spending more than SendMax,\n   * reduce the received amount instead of failing outright. See Partial.\n   * Payments for more details.\n   */\n  tfPartialPayment?: boolean\n  /**\n   * Only take paths where all the conversions have an input:output ratio that\n   * is equal or better than the ratio of Amount:SendMax. See Limit Quality for\n   * details.\n   */\n  tfLimitQuality?: boolean\n}\n\n/**\n * A Payment transaction represents a transfer of value from one account to\n * another.\n *\n * @category Transaction Models\n */\nexport interface Payment extends BaseTransaction {\n  TransactionType: 'Payment'\n  /**\n   * The amount of currency to deliver. For non-XRP amounts, the nested field\n   * names MUST be lower-case. If the tfPartialPayment flag is set, deliver up\n   * to this amount instead.\n   */\n  Amount: Amount | MPTAmount\n\n  DeliverMax?: Amount | MPTAmount\n\n  /** The unique address of the account receiving the payment. */\n  Destination: Account\n  /**\n   * Arbitrary tag that identifies the reason for the payment to the\n   * destination, or a hosted recipient to pay.\n   */\n  DestinationTag?: number\n  /**\n   * Arbitrary 256-bit hash representing a specific reason or identifier for\n   * this payment.\n   */\n  InvoiceID?: string\n  /**\n   * Array of payment paths to be used for this transaction. Must be omitted\n   * for XRP-to-XRP transactions.\n   */\n  Paths?: Path[]\n  /**\n   * Highest amount of source currency this transaction is allowed to cost,\n   * including transfer fees, exchange rates, and slippage . Does not include\n   * the XRP destroyed as a cost for submitting the transaction. For non-XRP\n   * amounts, the nested field names MUST be lower-case. Must be supplied for\n   * cross-currency/cross-issue payments. Must be omitted for XRP-to-XRP\n   * Payments.\n   */\n  SendMax?: Amount | MPTAmount\n  /**\n   * Minimum amount of destination currency this transaction should deliver.\n   * Only valid if this is a partial payment. For non-XRP amounts, the nested\n   * field names are lower-case.\n   */\n  DeliverMin?: Amount | MPTAmount\n  /**\n   * Credentials associated with the sender of this transaction.\n   * The credentials included must not be expired.\n   */\n  CredentialIDs?: string[]\n  /**\n   * The domain the sender intends to use. Both the sender and destination must\n   * be part of this domain. The DomainID can be included if the sender intends\n   * it to be a cross-currency payment (i.e. if the payment is going to interact\n   * with the DEX). The domain will only play it's role if there is a path that\n   * crossing an orderbook.\n   *\n   * Note: it's still possible that DomainID is included but the payment does\n   * not interact with DEX, it simply means that the DomainID will be ignored\n   * during payment paths.\n   */\n  DomainID?: string\n  Flags?: number | PaymentFlagsInterface\n}\n\nexport interface PaymentMetadata extends TransactionMetadataBase {\n  DeliveredAmount?: Amount | MPTAmount\n  delivered_amount?: Amount | MPTAmount | 'unavailable'\n}\n\n/**\n * Verify the form and type of a Payment at runtime.\n *\n * @param tx - A Payment Transaction.\n * @throws When the Payment is malformed.\n */\nexport function validatePayment(tx: Record<string, unknown>): void {\n  validateBaseTransaction(tx)\n\n  if (tx.Amount === undefined) {\n    throw new ValidationError('PaymentTransaction: missing field Amount')\n  }\n\n  if (!isAmount(tx.Amount)) {\n    throw new ValidationError('PaymentTransaction: invalid Amount')\n  }\n\n  validateRequiredField(tx, 'Destination', isAccount)\n  validateOptionalField(tx, 'DestinationTag', isNumber)\n\n  validateCredentialsList(\n    tx.CredentialIDs,\n    tx.TransactionType,\n    true,\n    MAX_AUTHORIZED_CREDENTIALS,\n  )\n\n  if (tx.InvoiceID !== undefined && typeof tx.InvoiceID !== 'string') {\n    throw new ValidationError('PaymentTransaction: InvoiceID must be a string')\n  }\n\n  validateOptionalField(tx, 'DomainID', isDomainID, {\n    txType: 'PaymentTransaction',\n    paramName: 'DomainID',\n  })\n\n  if (tx.Paths !== undefined && !isPaths(tx.Paths)) {\n    throw new ValidationError('PaymentTransaction: invalid Paths')\n  }\n\n  if (tx.SendMax !== undefined && !isAmount(tx.SendMax)) {\n    throw new ValidationError('PaymentTransaction: invalid SendMax')\n  }\n\n  checkPartialPayment(tx)\n}\n\nfunction checkPartialPayment(tx: Record<string, unknown>): void {\n  if (tx.DeliverMin != null) {\n    if (tx.Flags == null) {\n      throw new ValidationError(\n        'PaymentTransaction: tfPartialPayment flag required with DeliverMin',\n      )\n    }\n\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Only used by JS\n    const flags = tx.Flags as number | PaymentFlagsInterface\n    const isTfPartialPayment =\n      typeof flags === 'number'\n        ? isFlagEnabled(flags, PaymentFlags.tfPartialPayment)\n        : (flags.tfPartialPayment ?? false)\n\n    if (!isTfPartialPayment) {\n      throw new ValidationError(\n        'PaymentTransaction: tfPartialPayment flag required with DeliverMin',\n      )\n    }\n\n    if (!isAmount(tx.DeliverMin)) {\n      throw new ValidationError('PaymentTransaction: invalid DeliverMin')\n    }\n  }\n}\n\nfunction isPathStep(pathStep: Record<string, unknown>): boolean {\n  if (pathStep.account !== undefined && typeof pathStep.account !== 'string') {\n    return false\n  }\n  if (\n    pathStep.currency !== undefined &&\n    typeof pathStep.currency !== 'string'\n  ) {\n    return false\n  }\n  if (pathStep.issuer !== undefined && typeof pathStep.issuer !== 'string') {\n    return false\n  }\n  if (\n    pathStep.account !== undefined &&\n    pathStep.currency === undefined &&\n    pathStep.issuer === undefined\n  ) {\n    return true\n  }\n  if (pathStep.currency !== undefined || pathStep.issuer !== undefined) {\n    return true\n  }\n  return false\n}\n\nfunction isPath(path: unknown): path is Path {\n  if (!Array.isArray(path) || path.length === 0) {\n    return false\n  }\n  for (const pathStep of path) {\n    if (!isPathStep(pathStep)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isPaths(paths: unknown): paths is Path[] {\n  if (!isArray(paths) || paths.length === 0) {\n    return false\n  }\n\n  for (const path of paths) {\n    if (!isArray(path) || path.length === 0) {\n      return false\n    }\n\n    if (!isPath(path)) {\n      return false\n    }\n  }\n\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}