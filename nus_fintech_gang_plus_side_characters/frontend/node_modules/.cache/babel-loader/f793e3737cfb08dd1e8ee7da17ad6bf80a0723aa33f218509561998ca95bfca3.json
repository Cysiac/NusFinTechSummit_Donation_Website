{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashStateTree = exports.hashTxTree = exports.hashLedgerHeader = exports.hashSignedTx = void 0;\nconst utils_1 = require(\"@xrplf/isomorphic/utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst ripple_binary_codec_1 = require(\"ripple-binary-codec\");\nconst errors_1 = require(\"../../errors\");\nconst common_1 = require(\"../../models/transactions/common\");\nconst utils_2 = require(\"../../models/utils\");\nconst HashPrefix_1 = __importDefault(require(\"./HashPrefix\"));\nconst sha512Half_1 = __importDefault(require(\"./sha512Half\"));\nconst SHAMap_1 = __importStar(require(\"./SHAMap\"));\nconst HEX = 16;\nfunction intToHex(integer, byteLength) {\n  const foo = Number(integer).toString(HEX).padStart(byteLength * 2, '0');\n  return foo;\n}\nfunction bigintToHex(integerString, byteLength) {\n  const hex = new bignumber_js_1.default(integerString).toString(HEX);\n  return hex.padStart(byteLength * 2, '0');\n}\nfunction addLengthPrefix(hex) {\n  const length = hex.length / 2;\n  if (length <= 192) {\n    return (0, utils_1.bytesToHex)([length]) + hex;\n  }\n  if (length <= 12480) {\n    const prefix = length - 193;\n    return (0, utils_1.bytesToHex)([193 + (prefix >>> 8), prefix & 0xff]) + hex;\n  }\n  if (length <= 918744) {\n    const prefix = length - 12481;\n    return (0, utils_1.bytesToHex)([241 + (prefix >>> 16), prefix >>> 8 & 0xff, prefix & 0xff]) + hex;\n  }\n  throw new errors_1.XrplError('Variable integer overflow.');\n}\nfunction hashSignedTx(tx) {\n  let txBlob;\n  let txObject;\n  if (typeof tx === 'string') {\n    txBlob = tx;\n    txObject = (0, ripple_binary_codec_1.decode)(tx);\n  } else {\n    txBlob = (0, ripple_binary_codec_1.encode)(tx);\n    txObject = tx;\n  }\n  if (txObject.TxnSignature === undefined && txObject.Signers === undefined && txObject.SigningPubKey === undefined && !(0, utils_2.hasFlag)(txObject, common_1.GlobalFlags.tfInnerBatchTxn, 'tfInnerBatchTxn')) {\n    throw new errors_1.ValidationError('The transaction must be signed to hash it.');\n  }\n  const prefix = HashPrefix_1.default.TRANSACTION_ID.toString(16).toUpperCase();\n  return (0, sha512Half_1.default)(prefix.concat(txBlob));\n}\nexports.hashSignedTx = hashSignedTx;\nfunction hashLedgerHeader(ledgerHeader) {\n  const prefix = HashPrefix_1.default.LEDGER.toString(HEX).toUpperCase();\n  const ledger = prefix + intToHex(Number(ledgerHeader.ledger_index), 4) + bigintToHex(ledgerHeader.total_coins, 8) + ledgerHeader.parent_hash + ledgerHeader.transaction_hash + ledgerHeader.account_hash + intToHex(ledgerHeader.parent_close_time, 4) + intToHex(ledgerHeader.close_time, 4) + intToHex(ledgerHeader.close_time_resolution, 1) + intToHex(ledgerHeader.close_flags, 1);\n  return (0, sha512Half_1.default)(ledger);\n}\nexports.hashLedgerHeader = hashLedgerHeader;\nfunction hashTxTree(transactions) {\n  var _a;\n  const shamap = new SHAMap_1.default();\n  for (const txJSON of transactions) {\n    const txBlobHex = (0, ripple_binary_codec_1.encode)(txJSON);\n    const metaHex = (0, ripple_binary_codec_1.encode)((_a = txJSON.metaData) !== null && _a !== void 0 ? _a : {});\n    const txHash = hashSignedTx(txBlobHex);\n    const data = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex);\n    shamap.addItem(txHash, data, SHAMap_1.NodeType.TRANSACTION_METADATA);\n  }\n  return shamap.hash;\n}\nexports.hashTxTree = hashTxTree;\nfunction hashStateTree(entries) {\n  const shamap = new SHAMap_1.default();\n  entries.forEach(ledgerEntry => {\n    const data = (0, ripple_binary_codec_1.encode)(ledgerEntry);\n    shamap.addItem(ledgerEntry.index, data, SHAMap_1.NodeType.ACCOUNT_STATE);\n  });\n  return shamap.hash;\n}\nexports.hashStateTree = hashStateTree;\nfunction computeTransactionHash(ledger, options) {\n  const {\n    transaction_hash\n  } = ledger;\n  if (!options.computeTreeHashes) {\n    return transaction_hash;\n  }\n  if (ledger.transactions == null) {\n    throw new errors_1.ValidationError('transactions is missing from the ledger');\n  }\n  const transactionHash = hashTxTree(ledger.transactions);\n  if (transaction_hash !== transactionHash) {\n    throw new errors_1.ValidationError('transactionHash in header' + ' does not match computed hash of transactions', {\n      transactionHashInHeader: transaction_hash,\n      computedHashOfTransactions: transactionHash\n    });\n  }\n  return transactionHash;\n}\nfunction computeStateHash(ledger, options) {\n  const {\n    account_hash\n  } = ledger;\n  if (!options.computeTreeHashes) {\n    return account_hash;\n  }\n  if (ledger.accountState == null) {\n    throw new errors_1.ValidationError('accountState is missing from the ledger');\n  }\n  const stateHash = hashStateTree(ledger.accountState);\n  if (account_hash !== stateHash) {\n    throw new errors_1.ValidationError('stateHash in header does not match computed hash of state');\n  }\n  return stateHash;\n}\nfunction hashLedger(ledger, options = {}) {\n  const subhashes = {\n    transaction_hash: computeTransactionHash(ledger, options),\n    account_hash: computeStateHash(ledger, options)\n  };\n  return hashLedgerHeader(Object.assign(Object.assign({}, ledger), subhashes));\n}\nexports.default = hashLedger;","map":{"version":3,"names":["utils_1","require","bignumber_js_1","__importDefault","ripple_binary_codec_1","errors_1","common_1","utils_2","HashPrefix_1","sha512Half_1","SHAMap_1","__importStar","HEX","intToHex","integer","byteLength","foo","Number","toString","padStart","bigintToHex","integerString","hex","default","addLengthPrefix","length","bytesToHex","prefix","XrplError","hashSignedTx","tx","txBlob","txObject","decode","encode","TxnSignature","undefined","Signers","SigningPubKey","hasFlag","GlobalFlags","tfInnerBatchTxn","ValidationError","TRANSACTION_ID","toUpperCase","concat","exports","hashLedgerHeader","ledgerHeader","LEDGER","ledger","ledger_index","total_coins","parent_hash","transaction_hash","account_hash","parent_close_time","close_time","close_time_resolution","close_flags","hashTxTree","transactions","shamap","txJSON","txBlobHex","metaHex","_a","metaData","txHash","data","addItem","NodeType","TRANSACTION_METADATA","hash","hashStateTree","entries","forEach","ledgerEntry","index","ACCOUNT_STATE","computeTransactionHash","options","computeTreeHashes","transactionHash","transactionHashInHeader","computedHashOfTransactions","computeStateHash","accountState","stateHash","hashLedger","subhashes","Object","assign"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/utils/hashes/hashLedger.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-magic-numbers -- this file mimics\n   behavior in rippled. Magic numbers are used for lengths and conditions */\n/* eslint-disable no-bitwise  -- this file mimics behavior in rippled. It uses\n   bitwise operators for and-ing numbers with a mask and bit shifting. */\n\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\nimport BigNumber from 'bignumber.js'\nimport { decode, encode } from 'ripple-binary-codec'\n\nimport { ValidationError, XrplError } from '../../errors'\nimport { APIVersion } from '../../models'\nimport { LedgerEntry } from '../../models/ledger'\nimport { LedgerVersionMap } from '../../models/ledger/Ledger'\nimport { Transaction, TransactionMetadata } from '../../models/transactions'\nimport { GlobalFlags } from '../../models/transactions/common'\nimport { hasFlag } from '../../models/utils'\n\nimport HashPrefix from './HashPrefix'\nimport sha512Half from './sha512Half'\nimport SHAMap, { NodeType } from './SHAMap'\n\nconst HEX = 16\n\ninterface HashLedgerHeaderOptions {\n  computeTreeHashes?: boolean\n}\n\nfunction intToHex(integer: number, byteLength: number): string {\n  const foo = Number(integer)\n    .toString(HEX)\n    .padStart(byteLength * 2, '0')\n\n  return foo\n}\n\nfunction bigintToHex(\n  integerString: string | number | BigNumber,\n  byteLength: number,\n): string {\n  const hex = new BigNumber(integerString).toString(HEX)\n  return hex.padStart(byteLength * 2, '0')\n}\n\nfunction addLengthPrefix(hex: string): string {\n  const length = hex.length / 2\n  if (length <= 192) {\n    return bytesToHex([length]) + hex\n  }\n  if (length <= 12480) {\n    const prefix = length - 193\n    return bytesToHex([193 + (prefix >>> 8), prefix & 0xff]) + hex\n  }\n  if (length <= 918744) {\n    const prefix = length - 12481\n    return (\n      bytesToHex([\n        241 + (prefix >>> 16),\n        (prefix >>> 8) & 0xff,\n        prefix & 0xff,\n      ]) + hex\n    )\n  }\n  throw new XrplError('Variable integer overflow.')\n}\n\n/**\n * Hashes the Transaction object as the ledger does. Throws if the transaction is unsigned.\n *\n * @param tx - A transaction to hash. Tx may be in binary blob form. Tx must be signed.\n * @returns A hash of tx.\n * @throws ValidationError if the Transaction is unsigned.\n * @category Utilities\n */\nexport function hashSignedTx(tx: Transaction | string): string {\n  let txBlob: string\n  let txObject: Transaction\n  if (typeof tx === 'string') {\n    txBlob = tx\n    /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions -- Required until updated in binary codec. */\n    txObject = decode(tx) as unknown as Transaction\n  } else {\n    txBlob = encode(tx)\n    txObject = tx\n  }\n\n  if (\n    txObject.TxnSignature === undefined &&\n    txObject.Signers === undefined &&\n    txObject.SigningPubKey === undefined &&\n    !hasFlag(txObject, GlobalFlags.tfInnerBatchTxn, 'tfInnerBatchTxn')\n  ) {\n    throw new ValidationError('The transaction must be signed to hash it.')\n  }\n\n  const prefix = HashPrefix.TRANSACTION_ID.toString(16).toUpperCase()\n  return sha512Half(prefix.concat(txBlob))\n}\n\n/**\n * Compute the hash of a ledger.\n *\n * @param ledgerHeader - Ledger to compute the hash of.\n * @returns The hash of the ledger.\n * @category Utilities\n */\nexport function hashLedgerHeader(\n  ledgerHeader: LedgerVersionMap<APIVersion>,\n): string {\n  const prefix = HashPrefix.LEDGER.toString(HEX).toUpperCase()\n\n  const ledger =\n    prefix +\n    intToHex(Number(ledgerHeader.ledger_index), 4) +\n    bigintToHex(ledgerHeader.total_coins, 8) +\n    ledgerHeader.parent_hash +\n    ledgerHeader.transaction_hash +\n    ledgerHeader.account_hash +\n    intToHex(ledgerHeader.parent_close_time, 4) +\n    intToHex(ledgerHeader.close_time, 4) +\n    intToHex(ledgerHeader.close_time_resolution, 1) +\n    intToHex(ledgerHeader.close_flags, 1)\n\n  return sha512Half(ledger)\n}\n\n/**\n * Compute the root hash of the SHAMap containing all transactions.\n *\n * @param transactions - List of Transactions.\n * @returns The root hash of the SHAMap.\n * @category Utilities\n */\nexport function hashTxTree(\n  transactions: Array<Transaction & { metaData?: TransactionMetadata }>,\n): string {\n  const shamap = new SHAMap()\n  for (const txJSON of transactions) {\n    const txBlobHex = encode(txJSON)\n    const metaHex = encode(txJSON.metaData ?? {})\n    const txHash = hashSignedTx(txBlobHex)\n    const data = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex)\n    shamap.addItem(txHash, data, NodeType.TRANSACTION_METADATA)\n  }\n\n  return shamap.hash\n}\n\n/**\n * Compute the state hash of a list of LedgerEntries.\n *\n * @param entries - List of LedgerEntries.\n * @returns Hash of SHAMap that consists of all entries.\n * @category Utilities\n */\nexport function hashStateTree(entries: LedgerEntry[]): string {\n  const shamap = new SHAMap()\n\n  entries.forEach((ledgerEntry) => {\n    const data = encode(ledgerEntry)\n    shamap.addItem(ledgerEntry.index, data, NodeType.ACCOUNT_STATE)\n  })\n\n  return shamap.hash\n}\n\nfunction computeTransactionHash(\n  ledger: LedgerVersionMap<APIVersion>,\n  options: HashLedgerHeaderOptions,\n): string {\n  const { transaction_hash } = ledger\n\n  if (!options.computeTreeHashes) {\n    return transaction_hash\n  }\n\n  if (ledger.transactions == null) {\n    throw new ValidationError('transactions is missing from the ledger')\n  }\n\n  const transactionHash = hashTxTree(ledger.transactions)\n\n  if (transaction_hash !== transactionHash) {\n    throw new ValidationError(\n      'transactionHash in header' +\n        ' does not match computed hash of transactions',\n      {\n        transactionHashInHeader: transaction_hash,\n        computedHashOfTransactions: transactionHash,\n      },\n    )\n  }\n\n  return transactionHash\n}\n\nfunction computeStateHash(\n  ledger: LedgerVersionMap<APIVersion>,\n  options: HashLedgerHeaderOptions,\n): string {\n  const { account_hash } = ledger\n\n  if (!options.computeTreeHashes) {\n    return account_hash\n  }\n\n  if (ledger.accountState == null) {\n    throw new ValidationError('accountState is missing from the ledger')\n  }\n\n  const stateHash = hashStateTree(ledger.accountState)\n\n  if (account_hash !== stateHash) {\n    throw new ValidationError(\n      'stateHash in header does not match computed hash of state',\n    )\n  }\n\n  return stateHash\n}\n\n/**\n * Compute the hash of a ledger.\n *\n * @param ledger - Ledger to compute the hash for.\n * @param options - Allow client to recompute Transaction and State Hashes.\n * @param options.computeTreeHashes - Whether to recompute the Transaction and State Hashes.\n * @returns The has of ledger.\n * @category Utilities\n */\nfunction hashLedger(\n  ledger: LedgerVersionMap<APIVersion>,\n  options: {\n    computeTreeHashes?: boolean\n  } = {},\n): string {\n  const subhashes = {\n    transaction_hash: computeTransactionHash(ledger, options),\n    account_hash: computeStateHash(ledger, options),\n  }\n  return hashLedgerHeader({ ...ledger, ...subhashes })\n}\n\nexport default hashLedger\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}