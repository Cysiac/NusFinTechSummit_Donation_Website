{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateVaultCreate = exports.VaultCreateFlags = exports.VaultWithdrawalPolicy = void 0;\nconst errors_1 = require(\"../../errors\");\nconst utils_1 = require(\"../utils\");\nconst mptokenMetadata_1 = require(\"../utils/mptokenMetadata\");\nconst common_1 = require(\"./common\");\nvar VaultWithdrawalPolicy;\n(function (VaultWithdrawalPolicy) {\n  VaultWithdrawalPolicy[VaultWithdrawalPolicy[\"vaultStrategyFirstComeFirstServe\"] = 1] = \"vaultStrategyFirstComeFirstServe\";\n})(VaultWithdrawalPolicy || (exports.VaultWithdrawalPolicy = VaultWithdrawalPolicy = {}));\nvar VaultCreateFlags;\n(function (VaultCreateFlags) {\n  VaultCreateFlags[VaultCreateFlags[\"tfVaultPrivate\"] = 65536] = \"tfVaultPrivate\";\n  VaultCreateFlags[VaultCreateFlags[\"tfVaultShareNonTransferable\"] = 131072] = \"tfVaultShareNonTransferable\";\n})(VaultCreateFlags || (exports.VaultCreateFlags = VaultCreateFlags = {}));\nfunction validateVaultCreate(tx) {\n  (0, common_1.validateBaseTransaction)(tx);\n  (0, common_1.validateRequiredField)(tx, 'Asset', common_1.isCurrency);\n  (0, common_1.validateOptionalField)(tx, 'Data', common_1.isString);\n  (0, common_1.validateOptionalField)(tx, 'AssetsMaximum', common_1.isXRPLNumber);\n  (0, common_1.validateOptionalField)(tx, 'MPTokenMetadata', common_1.isString);\n  (0, common_1.validateOptionalField)(tx, 'WithdrawalPolicy', common_1.isNumber);\n  (0, common_1.validateOptionalField)(tx, 'DomainID', common_1.isString);\n  if (tx.Data !== undefined) {\n    const dataHex = tx.Data;\n    if (!(0, utils_1.isHex)(dataHex)) {\n      throw new errors_1.ValidationError('VaultCreate: Data must be a valid hex string');\n    }\n    const dataByteLength = dataHex.length / 2;\n    if (dataByteLength > common_1.VAULT_DATA_MAX_BYTE_LENGTH) {\n      throw new errors_1.ValidationError(`VaultCreate: Data exceeds ${common_1.VAULT_DATA_MAX_BYTE_LENGTH} bytes (actual: ${dataByteLength})`);\n    }\n  }\n  if (tx.MPTokenMetadata !== undefined) {\n    const metaHex = tx.MPTokenMetadata;\n    if (!(0, utils_1.isHex)(metaHex)) {\n      throw new errors_1.ValidationError('VaultCreate: MPTokenMetadata must be a valid non-empty hex string');\n    }\n    const metaByteLength = metaHex.length / 2;\n    if (metaByteLength > mptokenMetadata_1.MAX_MPT_META_BYTE_LENGTH) {\n      throw new errors_1.ValidationError(`VaultCreate: MPTokenMetadata exceeds ${mptokenMetadata_1.MAX_MPT_META_BYTE_LENGTH} bytes (actual: ${metaByteLength})`);\n    }\n  }\n  if (tx.DomainID !== undefined && !(0, utils_1.hasFlag)(tx, VaultCreateFlags.tfVaultPrivate, 'tfVaultPrivate')) {\n    throw new errors_1.ValidationError('VaultCreate: Cannot set DomainID unless tfVaultPrivate flag is set.');\n  }\n  if (tx.MPTokenMetadata != null) {\n    const validationMessages = (0, mptokenMetadata_1.validateMPTokenMetadata)(tx.MPTokenMetadata);\n    if (validationMessages.length > 0) {\n      const message = [mptokenMetadata_1.MPT_META_WARNING_HEADER, ...validationMessages.map(msg => `- ${msg}`)].join('\\n');\n      console.warn(message);\n    }\n  }\n}\nexports.validateVaultCreate = validateVaultCreate;","map":{"version":3,"names":["errors_1","require","utils_1","mptokenMetadata_1","common_1","VaultWithdrawalPolicy","exports","VaultCreateFlags","validateVaultCreate","tx","validateBaseTransaction","validateRequiredField","isCurrency","validateOptionalField","isString","isXRPLNumber","isNumber","Data","undefined","dataHex","isHex","ValidationError","dataByteLength","length","VAULT_DATA_MAX_BYTE_LENGTH","MPTokenMetadata","metaHex","metaByteLength","MAX_MPT_META_BYTE_LENGTH","DomainID","hasFlag","tfVaultPrivate","validationMessages","validateMPTokenMetadata","message","MPT_META_WARNING_HEADER","map","msg","join","console","warn"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/xrpl/src/models/transactions/vaultCreate.ts"],"sourcesContent":["import { ValidationError } from '../../errors'\nimport { Currency } from '../common'\nimport { hasFlag, isHex } from '../utils'\nimport {\n  MAX_MPT_META_BYTE_LENGTH,\n  MPT_META_WARNING_HEADER,\n  validateMPTokenMetadata,\n} from '../utils/mptokenMetadata'\n\nimport {\n  BaseTransaction,\n  validateBaseTransaction,\n  GlobalFlagsInterface,\n  validateOptionalField,\n  isNumber,\n  isCurrency,\n  validateRequiredField,\n  isString,\n  VAULT_DATA_MAX_BYTE_LENGTH,\n  XRPLNumber,\n  isXRPLNumber,\n} from './common'\n\n/**\n * Enum representing withdrawal strategies for a Vault.\n */\nexport enum VaultWithdrawalPolicy {\n  vaultStrategyFirstComeFirstServe = 0x0001,\n}\n\n/**\n * Enum representing values of {@link VaultCreate} transaction flags.\n *\n * @category Transaction Flags\n */\nexport enum VaultCreateFlags {\n  tfVaultPrivate = 0x00010000,\n  tfVaultShareNonTransferable = 0x00020000,\n}\n\n/**\n * Map of flags to boolean values representing {@link VaultCreate} transaction\n * flags.\n *\n * @category Transaction Flags\n */\nexport interface VaultCreateFlagsInterface extends GlobalFlagsInterface {\n  tfVaultPrivate?: boolean\n  tfVaultShareNonTransferable?: boolean\n}\n\n/**\n * The VaultCreate transaction creates a new Vault object.\n *\n * @category Transaction Models\n */\nexport interface VaultCreate extends BaseTransaction {\n  TransactionType: 'VaultCreate'\n\n  /**\n   * The asset (XRP, IOU or MPT) of the Vault.\n   */\n  Asset: Currency\n\n  /**\n   * Arbitrary Vault metadata, limited to 256 bytes.\n   */\n  Data?: string\n\n  /**\n   * The maximum asset amount that can be held in a vault.\n   */\n  AssetsMaximum?: XRPLNumber\n\n  /**\n   * Should follow {@link https://github.com/XRPLF/XRPL-Standards/tree/master/XLS-0089-multi-purpose-token-metadata-schema | XLS-89} standard.\n   * Use {@link encodeMPTokenMetadata} utility function to convert to convert {@link MPTokenMetadata} to a blob.\n   * Use {@link decodeMPTokenMetadata} utility function to convert from a blob to {@link MPTokenMetadata}.\n   *\n   * While adherence to the XLS-89d format is not mandatory, non-compliant metadata\n   * may not be discoverable by ecosystem tools such as explorers and indexers.\n   */\n  MPTokenMetadata?: string\n\n  /**\n   * Indicates the withdrawal strategy used by the Vault.\n   */\n  WithdrawalPolicy?: number\n\n  /**\n   * The PermissionedDomain object ID associated with the shares of this Vault.\n   */\n  DomainID?: string\n}\n\n/* eslint-disable max-lines-per-function -- Not needed to reduce function */\n/* eslint-disable max-statements -- required to do all field validations */\n/**\n * Verify the form and type of an {@link VaultCreate} at runtime.\n *\n * @param tx - A {@link VaultCreate} Transaction.\n * @throws When the {@link VaultCreate} is malformed.\n */\nexport function validateVaultCreate(tx: Record<string, unknown>): void {\n  validateBaseTransaction(tx)\n\n  validateRequiredField(tx, 'Asset', isCurrency)\n  validateOptionalField(tx, 'Data', isString)\n  validateOptionalField(tx, 'AssetsMaximum', isXRPLNumber)\n  validateOptionalField(tx, 'MPTokenMetadata', isString)\n  validateOptionalField(tx, 'WithdrawalPolicy', isNumber)\n  validateOptionalField(tx, 'DomainID', isString)\n\n  if (tx.Data !== undefined) {\n    const dataHex = tx.Data\n    if (!isHex(dataHex)) {\n      throw new ValidationError('VaultCreate: Data must be a valid hex string')\n    }\n    const dataByteLength = dataHex.length / 2\n    if (dataByteLength > VAULT_DATA_MAX_BYTE_LENGTH) {\n      throw new ValidationError(\n        `VaultCreate: Data exceeds ${VAULT_DATA_MAX_BYTE_LENGTH} bytes (actual: ${dataByteLength})`,\n      )\n    }\n  }\n\n  if (tx.MPTokenMetadata !== undefined) {\n    const metaHex = tx.MPTokenMetadata\n    if (!isHex(metaHex)) {\n      throw new ValidationError(\n        'VaultCreate: MPTokenMetadata must be a valid non-empty hex string',\n      )\n    }\n    const metaByteLength = metaHex.length / 2\n    if (metaByteLength > MAX_MPT_META_BYTE_LENGTH) {\n      throw new ValidationError(\n        `VaultCreate: MPTokenMetadata exceeds ${MAX_MPT_META_BYTE_LENGTH} bytes (actual: ${metaByteLength})`,\n      )\n    }\n  }\n\n  // If DomainID present, tfVaultPrivate must be set\n  if (\n    tx.DomainID !== undefined &&\n    !hasFlag(tx, VaultCreateFlags.tfVaultPrivate, 'tfVaultPrivate')\n  ) {\n    throw new ValidationError(\n      'VaultCreate: Cannot set DomainID unless tfVaultPrivate flag is set.',\n    )\n  }\n\n  if (tx.MPTokenMetadata != null) {\n    const validationMessages = validateMPTokenMetadata(tx.MPTokenMetadata)\n\n    if (validationMessages.length > 0) {\n      const message = [\n        MPT_META_WARNING_HEADER,\n        ...validationMessages.map((msg) => `- ${msg}`),\n      ].join('\\n')\n\n      // eslint-disable-next-line no-console -- Required here.\n      console.warn(message)\n    }\n  }\n}\n/* eslint-enable max-lines-per-function */\n/* eslint-enable max-statements */\n"],"mappings":";;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AAEA,MAAAC,OAAA,GAAAD,OAAA;AACA,MAAAE,iBAAA,GAAAF,OAAA;AAMA,MAAAG,QAAA,GAAAH,OAAA;AAiBA,IAAYI,qBAEX;AAFD,WAAYA,qBAAqB;EAC/BA,qBAAA,CAAAA,qBAAA,8EAAyC;AAC3C,CAAC,EAFWA,qBAAqB,KAAAC,OAAA,CAAAD,qBAAA,GAArBA,qBAAqB;AASjC,IAAYE,gBAGX;AAHD,WAAYA,gBAAgB;EAC1BA,gBAAA,CAAAA,gBAAA,8CAA2B;EAC3BA,gBAAA,CAAAA,gBAAA,yEAAwC;AAC1C,CAAC,EAHWA,gBAAgB,KAAAD,OAAA,CAAAC,gBAAA,GAAhBA,gBAAgB;AAoE5B,SAAgBC,mBAAmBA,CAACC,EAA2B;EAC7D,IAAAL,QAAA,CAAAM,uBAAuB,EAACD,EAAE,CAAC;EAE3B,IAAAL,QAAA,CAAAO,qBAAqB,EAACF,EAAE,EAAE,OAAO,EAAEL,QAAA,CAAAQ,UAAU,CAAC;EAC9C,IAAAR,QAAA,CAAAS,qBAAqB,EAACJ,EAAE,EAAE,MAAM,EAAEL,QAAA,CAAAU,QAAQ,CAAC;EAC3C,IAAAV,QAAA,CAAAS,qBAAqB,EAACJ,EAAE,EAAE,eAAe,EAAEL,QAAA,CAAAW,YAAY,CAAC;EACxD,IAAAX,QAAA,CAAAS,qBAAqB,EAACJ,EAAE,EAAE,iBAAiB,EAAEL,QAAA,CAAAU,QAAQ,CAAC;EACtD,IAAAV,QAAA,CAAAS,qBAAqB,EAACJ,EAAE,EAAE,kBAAkB,EAAEL,QAAA,CAAAY,QAAQ,CAAC;EACvD,IAAAZ,QAAA,CAAAS,qBAAqB,EAACJ,EAAE,EAAE,UAAU,EAAEL,QAAA,CAAAU,QAAQ,CAAC;EAE/C,IAAIL,EAAE,CAACQ,IAAI,KAAKC,SAAS,EAAE;IACzB,MAAMC,OAAO,GAAGV,EAAE,CAACQ,IAAI;IACvB,IAAI,CAAC,IAAAf,OAAA,CAAAkB,KAAK,EAACD,OAAO,CAAC,EAAE;MACnB,MAAM,IAAInB,QAAA,CAAAqB,eAAe,CAAC,8CAA8C,CAAC;;IAE3E,MAAMC,cAAc,GAAGH,OAAO,CAACI,MAAM,GAAG,CAAC;IACzC,IAAID,cAAc,GAAGlB,QAAA,CAAAoB,0BAA0B,EAAE;MAC/C,MAAM,IAAIxB,QAAA,CAAAqB,eAAe,CACvB,6BAA6BjB,QAAA,CAAAoB,0BAA0B,mBAAmBF,cAAc,GAAG,CAC5F;;;EAIL,IAAIb,EAAE,CAACgB,eAAe,KAAKP,SAAS,EAAE;IACpC,MAAMQ,OAAO,GAAGjB,EAAE,CAACgB,eAAe;IAClC,IAAI,CAAC,IAAAvB,OAAA,CAAAkB,KAAK,EAACM,OAAO,CAAC,EAAE;MACnB,MAAM,IAAI1B,QAAA,CAAAqB,eAAe,CACvB,mEAAmE,CACpE;;IAEH,MAAMM,cAAc,GAAGD,OAAO,CAACH,MAAM,GAAG,CAAC;IACzC,IAAII,cAAc,GAAGxB,iBAAA,CAAAyB,wBAAwB,EAAE;MAC7C,MAAM,IAAI5B,QAAA,CAAAqB,eAAe,CACvB,wCAAwClB,iBAAA,CAAAyB,wBAAwB,mBAAmBD,cAAc,GAAG,CACrG;;;EAKL,IACElB,EAAE,CAACoB,QAAQ,KAAKX,SAAS,IACzB,CAAC,IAAAhB,OAAA,CAAA4B,OAAO,EAACrB,EAAE,EAAEF,gBAAgB,CAACwB,cAAc,EAAE,gBAAgB,CAAC,EAC/D;IACA,MAAM,IAAI/B,QAAA,CAAAqB,eAAe,CACvB,qEAAqE,CACtE;;EAGH,IAAIZ,EAAE,CAACgB,eAAe,IAAI,IAAI,EAAE;IAC9B,MAAMO,kBAAkB,GAAG,IAAA7B,iBAAA,CAAA8B,uBAAuB,EAACxB,EAAE,CAACgB,eAAe,CAAC;IAEtE,IAAIO,kBAAkB,CAACT,MAAM,GAAG,CAAC,EAAE;MACjC,MAAMW,OAAO,GAAG,CACd/B,iBAAA,CAAAgC,uBAAuB,EACvB,GAAGH,kBAAkB,CAACI,GAAG,CAAEC,GAAG,IAAK,KAAKA,GAAG,EAAE,CAAC,CAC/C,CAACC,IAAI,CAAC,IAAI,CAAC;MAGZC,OAAO,CAACC,IAAI,CAACN,OAAO,CAAC;;;AAG3B;AA7DA5B,OAAA,CAAAE,mBAAA,GAAAA,mBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}