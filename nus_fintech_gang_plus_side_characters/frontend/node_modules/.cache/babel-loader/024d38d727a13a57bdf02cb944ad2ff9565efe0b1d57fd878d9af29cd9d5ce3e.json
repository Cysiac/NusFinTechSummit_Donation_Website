{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DER = exports.DERErr = void 0;\nexports._splitEndoScalar = _splitEndoScalar;\nexports._normFnElement = _normFnElement;\nexports.weierstrassN = weierstrassN;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\nexports.ecdh = ecdh;\nexports.ecdsa = ecdsa;\nexports.weierstrassPoints = weierstrassPoints;\nexports._legacyHelperEquat = _legacyHelperEquat;\nexports.weierstrass = weierstrass;\n/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_js_1 = require(\"@noble/hashes/hmac.js\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst utils_ts_1 = require(\"../utils.js\");\nconst curve_ts_1 = require(\"./curve.js\");\nconst modular_ts_1 = require(\"./modular.js\");\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */\nfunction _splitEndoScalar(k, basis, n) {\n  // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n  // Since part can be negative, we need to do this on point.\n  // TODO: verifyScalar function which consumes lambda\n  const [[a1, b1], [a2, b2]] = basis;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  // |k1|/|k2| is < sqrt(N), but can be negative.\n  // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n  let k1 = k - c1 * a1 - c2 * a2;\n  let k2 = -c1 * b1 - c2 * b2;\n  const k1neg = k1 < _0n;\n  const k2neg = k2 < _0n;\n  if (k1neg) k1 = -k1;\n  if (k2neg) k2 = -k2;\n  // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n  // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n  const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n; // Half bits of N\n  if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n    throw new Error('splitScalar (endomorphism): failed, k=' + k);\n  }\n  return {\n    k1neg,\n    k1,\n    k2neg,\n    k2\n  };\n}\nfunction validateSigFormat(format) {\n  if (!['compact', 'recovered', 'der'].includes(format)) throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n  return format;\n}\nfunction validateSigOpts(opts, def) {\n  const optsn = {};\n  for (let optName of Object.keys(def)) {\n    // @ts-ignore\n    optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n  }\n  (0, utils_ts_1._abool2)(optsn.lowS, 'lowS');\n  (0, utils_ts_1._abool2)(optsn.prehash, 'prehash');\n  if (optsn.format !== undefined) validateSigFormat(optsn.format);\n  return optsn;\n}\nclass DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexports.DERErr = DERErr;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexports.DER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag, data) => {\n      const {\n        Err: E\n      } = exports.DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);\n      if (len.length / 2 & 128) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : '';\n      const t = (0, utils_ts_1.numberToHexUnpadded)(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag, data) {\n      const {\n        Err: E\n      } = exports.DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 127;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = length << 8 | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return {\n        v,\n        l: data.subarray(pos + length)\n      };\n    }\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num) {\n      const {\n        Err: E\n      } = exports.DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = (0, utils_ts_1.numberToHexUnpadded)(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data) {\n      const {\n        Err: E\n      } = exports.DER;\n      if (data[0] & 128) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 128)) throw new E('invalid signature integer: unnecessary leading zero');\n      return (0, utils_ts_1.bytesToNumberBE)(data);\n    }\n  },\n  toSig(hex) {\n    // parse DER signature\n    const {\n      Err: E,\n      _int: int,\n      _tlv: tlv\n    } = exports.DER;\n    const data = (0, utils_ts_1.ensureBytes)('signature', hex);\n    const {\n      v: seqBytes,\n      l: seqLeftBytes\n    } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const {\n      v: rBytes,\n      l: rLeftBytes\n    } = tlv.decode(0x02, seqBytes);\n    const {\n      v: sBytes,\n      l: sLeftBytes\n    } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return {\n      r: int.decode(rBytes),\n      s: int.decode(sBytes)\n    };\n  },\n  hexFromSig(sig) {\n    const {\n      _tlv: tlv,\n      _int: int\n    } = exports.DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3),\n  _4n = BigInt(4);\nfunction _normFnElement(Fn, key) {\n  const {\n    BYTES: expected\n  } = Fn;\n  let num;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else {\n    let bytes = (0, utils_ts_1.ensureBytes)('private key', key);\n    try {\n      num = Fn.fromBytes(bytes);\n    } catch (error) {\n      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n    }\n  }\n  if (!Fn.isValidNot0(num)) throw new Error('invalid private key: out of range [1..N-1]');\n  return num;\n}\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nfunction weierstrassN(params, extraOpts = {}) {\n  const validated = (0, curve_ts_1._createCurveFields)('weierstrass', params, extraOpts);\n  const {\n    Fp,\n    Fn\n  } = validated;\n  let CURVE = validated.CURVE;\n  const {\n    h: cofactor,\n    n: CURVE_ORDER\n  } = CURVE;\n  (0, utils_ts_1._validateObject)(extraOpts, {}, {\n    allowInfinityPoint: 'boolean',\n    clearCofactor: 'function',\n    isTorsionFree: 'function',\n    fromBytes: 'function',\n    toBytes: 'function',\n    endo: 'object',\n    wrapPrivateKey: 'boolean'\n  });\n  const {\n    endo\n  } = extraOpts;\n  if (endo) {\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n    if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n    }\n  }\n  const lengths = getWLengths(Fp, Fn);\n  function assertCompressionIsSupported() {\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\n  }\n  // Implements IEEE P1363 point encoding\n  function pointToBytes(_c, point, isCompressed) {\n    const {\n      x,\n      y\n    } = point.toAffine();\n    const bx = Fp.toBytes(x);\n    (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');\n    if (isCompressed) {\n      assertCompressionIsSupported();\n      const hasEvenY = !Fp.isOdd(y);\n      return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);\n    } else {\n      return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n    }\n  }\n  function pointFromBytes(bytes) {\n    (0, utils_ts_1._abytes2)(bytes, undefined, 'Point');\n    const {\n      publicKey: comp,\n      publicKeyUncompressed: uncomp\n    } = lengths; // e.g. for 32-byte: 33, 65\n    const length = bytes.length;\n    const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // No actual validation is done here: use .assertValidity()\n    if (length === comp && (head === 0x02 || head === 0x03)) {\n      const x = Fp.fromBytes(tail);\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\n      const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n      let y;\n      try {\n        y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n      } catch (sqrtError) {\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n        throw new Error('bad point: is not on curve, sqrt error' + err);\n      }\n      assertCompressionIsSupported();\n      const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n      const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n      if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n      return {\n        x,\n        y\n      };\n    } else if (length === uncomp && head === 0x04) {\n      // TODO: more checks\n      const L = Fp.BYTES;\n      const x = Fp.fromBytes(tail.subarray(0, L));\n      const y = Fp.fromBytes(tail.subarray(L, L * 2));\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\n      return {\n        x,\n        y\n      };\n    } else {\n      throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n    }\n  }\n  const encodePoint = extraOpts.toBytes || pointToBytes;\n  const decodePoint = extraOpts.fromBytes || pointFromBytes;\n  function weierstrassEquation(x) {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x² * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x³ + a * x + b\n  }\n  // TODO: move top-level\n  /** Checks whether equation holds for given x, y: y² == x³ + ax + b */\n  function isValidXY(x, y) {\n    const left = Fp.sqr(y); // y²\n    const right = weierstrassEquation(x); // x³ + ax + b\n    return Fp.eql(left, right);\n  }\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y² = x³ + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n  // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n  function acoord(title, n, banZero = false) {\n    if (!Fp.isValid(n) || banZero && Fp.is0(n)) throw new Error(`bad point coordinate ${title}`);\n    return n;\n  }\n  function aprjpoint(other) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  function splitEndoScalarN(k) {\n    if (!endo || !endo.basises) throw new Error('no endo');\n    return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n  }\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)\n  const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {\n    const {\n      X,\n      Y,\n      Z\n    } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(Z, Fp.ONE)) return {\n      x: X,\n      y: Y\n    };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n    const x = Fp.mul(X, iz);\n    const y = Fp.mul(Y, iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return {\n      x: Fp.ZERO,\n      y: Fp.ZERO\n    };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return {\n      x,\n      y\n    };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = (0, utils_ts_1.memoized)(p => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const {\n      x,\n      y\n    } = p.toAffine();\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n    k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);\n    k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);\n    return k1p.add(k2p);\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).\n   * Default Point works in 2d / affine coordinates: (x, y).\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point {\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(X, Y, Z) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y, true);\n      this.Z = acoord('z', Z);\n      Object.freeze(this);\n    }\n    static CURVE() {\n      return CURVE;\n    }\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(p) {\n      const {\n        x,\n        y\n      } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n    static fromBytes(bytes) {\n      const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, undefined, 'point')));\n      P.assertValidity();\n      return P;\n    }\n    static fromHex(hex) {\n      return Point.fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex));\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(windowSize = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_3n); // random number\n      return this;\n    }\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    hasEvenY() {\n      const {\n        y\n      } = this.toAffine();\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n      return !Fp.isOdd(y);\n    }\n    /** Compare one point to another. */\n    equals(other) {\n      aprjpoint(other);\n      const {\n        X: X1,\n        Y: Y1,\n        Z: Z1\n      } = this;\n      const {\n        X: X2,\n        Y: Y2,\n        Z: Z2\n      } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate() {\n      return new Point(this.X, Fp.neg(this.Y), this.Z);\n    }\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const {\n        a,\n        b\n      } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const {\n        X: X1,\n        Y: Y1,\n        Z: Z1\n      } = this;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other) {\n      aprjpoint(other);\n      const {\n        X: X1,\n        Y: Y1,\n        Z: Z1\n      } = this;\n      const {\n        X: X2,\n        Y: Y2,\n        Z: Z2\n      } = other;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar) {\n      const {\n        endo\n      } = extraOpts;\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\n      let point, fake; // Fake point is used to const-time mult\n      const mul = n => wnaf.cached(this, n, p => (0, curve_ts_1.normalizeZ)(Point, p));\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const {\n          k1neg,\n          k1,\n          k2neg,\n          k2\n        } = splitEndoScalarN(scalar);\n        const {\n          p: k1p,\n          f: k1f\n        } = mul(k1);\n        const {\n          p: k2p,\n          f: k2f\n        } = mul(k2);\n        fake = k1f.add(k2f);\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n      } else {\n        const {\n          p,\n          f\n        } = mul(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];\n    }\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed secret key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc) {\n      const {\n        endo\n      } = extraOpts;\n      const p = this;\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\n      if (sc === _0n || p.is0()) return Point.ZERO;\n      if (sc === _1n) return p; // fast-path\n      if (wnaf.hasCache(this)) return this.multiply(sc);\n      if (endo) {\n        const {\n          k1neg,\n          k1,\n          k2neg,\n          k2\n        } = splitEndoScalarN(sc);\n        const {\n          p1,\n          p2\n        } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n      } else {\n        return wnaf.unsafe(p, sc);\n      }\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n      return sum.is0() ? undefined : sum;\n    }\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(invertedZ) {\n      return toAffineMemo(this, invertedZ);\n    }\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree() {\n      const {\n        isTorsionFree\n      } = extraOpts;\n      if (cofactor === _1n) return true;\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      return wnaf.unsafe(this, CURVE_ORDER).is0();\n    }\n    clearCofactor() {\n      const {\n        clearCofactor\n      } = extraOpts;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this);\n      return this.multiplyUnsafe(cofactor);\n    }\n    isSmallOrder() {\n      // can we use this.clearCofactor()?\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n    toBytes(isCompressed = true) {\n      (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');\n      this.assertValidity();\n      return encodePoint(Point, this, isCompressed);\n    }\n    toHex(isCompressed = true) {\n      return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));\n    }\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n    // TODO: remove\n    get px() {\n      return this.X;\n    }\n    get py() {\n      return this.X;\n    }\n    get pz() {\n      return this.Z;\n    }\n    toRawBytes(isCompressed = true) {\n      return this.toBytes(isCompressed);\n    }\n    _setWindowSize(windowSize) {\n      this.precompute(windowSize);\n    }\n    static normalizeZ(points) {\n      return (0, curve_ts_1.normalizeZ)(Point, points);\n    }\n    static msm(points, scalars) {\n      return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);\n    }\n    static fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n    }\n  }\n  // base / generator point\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n  // zero / infinity / identity point\n  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n  // math field\n  Point.Fp = Fp;\n  // scalar field\n  Point.Fn = Fn;\n  const bits = Fn.BITS;\n  const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u, v) => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return {\n      isValid: isQR,\n      value: tv3\n    };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u, v) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return {\n        isValid: isQR,\n        value: y\n      }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n  (0, modular_ts_1.validateField)(Fp);\n  const {\n    A,\n    B,\n    Z\n  } = opts;\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return u => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const {\n      isValid,\n      value\n    } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return {\n      x,\n      y\n    };\n  };\n}\nfunction getWLengths(Fp, Fn) {\n  return {\n    secretKey: Fn.BYTES,\n    publicKey: 1 + Fp.BYTES,\n    publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n    publicKeyHasPrefix: true,\n    signature: 2 * Fn.BYTES\n  };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nfunction ecdh(Point, ecdhOpts = {}) {\n  const {\n    Fn\n  } = Point;\n  const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;\n  const lengths = Object.assign(getWLengths(Point.Fp, Fn), {\n    seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER)\n  });\n  function isValidSecretKey(secretKey) {\n    try {\n      return !!_normFnElement(Fn, secretKey);\n    } catch (error) {\n      return false;\n    }\n  }\n  function isValidPublicKey(publicKey, isCompressed) {\n    const {\n      publicKey: comp,\n      publicKeyUncompressed\n    } = lengths;\n    try {\n      const l = publicKey.length;\n      if (isCompressed === true && l !== comp) return false;\n      if (isCompressed === false && l !== publicKeyUncompressed) return false;\n      return !!Point.fromBytes(publicKey);\n    } catch (error) {\n      return false;\n    }\n  }\n  /**\n   * Produces cryptographically secure secret key from random of size\n   * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n   */\n  function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n    return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed'), Fn.ORDER);\n  }\n  /**\n   * Computes public key for a secret key. Checks for validity of the secret key.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(secretKey, isCompressed = true) {\n    return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n  }\n  function keygen(seed) {\n    const secretKey = randomSecretKey(seed);\n    return {\n      secretKey,\n      publicKey: getPublicKey(secretKey)\n    };\n  }\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item) {\n    if (typeof item === 'bigint') return false;\n    if (item instanceof Point) return true;\n    const {\n      secretKey,\n      publicKey,\n      publicKeyUncompressed\n    } = lengths;\n    if (Fn.allowedLengths || secretKey === publicKey) return undefined;\n    const l = (0, utils_ts_1.ensureBytes)('key', item).length;\n    return l === publicKey || l === publicKeyUncompressed;\n  }\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from secret key A and public key B.\n   * Checks: 1) secret key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n    if (isProbPub(secretKeyA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicKeyB) === false) throw new Error('second arg must be public key');\n    const s = _normFnElement(Fn, secretKeyA);\n    const b = Point.fromHex(publicKeyB); // checks for being on-curve\n    return b.multiply(s).toBytes(isCompressed);\n  }\n  const utils = {\n    isValidSecretKey,\n    isValidPublicKey,\n    randomSecretKey,\n    // TODO: remove\n    isValidPrivateKey: isValidSecretKey,\n    randomPrivateKey: randomSecretKey,\n    normPrivateKeyToScalar: key => _normFnElement(Fn, key),\n    precompute(windowSize = 8, point = Point.BASE) {\n      return point.precompute(windowSize, false);\n    }\n  };\n  return Object.freeze({\n    getPublicKey,\n    getSharedSecret,\n    keygen,\n    Point,\n    utils,\n    lengths\n  });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nfunction ecdsa(Point, hash, ecdsaOpts = {}) {\n  (0, utils_1.ahash)(hash);\n  (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {\n    hmac: 'function',\n    lowS: 'boolean',\n    randomBytes: 'function',\n    bits2int: 'function',\n    bits2int_modN: 'function'\n  });\n  const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;\n  const hmac = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));\n  const {\n    Fp,\n    Fn\n  } = Point;\n  const {\n    ORDER: CURVE_ORDER,\n    BITS: fnBits\n  } = Fn;\n  const {\n    keygen,\n    getPublicKey,\n    getSharedSecret,\n    utils,\n    lengths\n  } = ecdh(Point, ecdsaOpts);\n  const defaultSigOpts = {\n    prehash: false,\n    lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n    format: undefined,\n    //'compact' as ECDSASigFormat,\n    extraEntropy: false\n  };\n  const defaultSigOpts_format = 'compact';\n  function isBiggerThanHalfOrder(number) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function validateRS(title, num) {\n    if (!Fn.isValidNot0(num)) throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n    return num;\n  }\n  function validateSigLength(bytes, format) {\n    validateSigFormat(format);\n    const size = lengths.signature;\n    const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n    return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);\n  }\n  /**\n   * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n   */\n  class Signature {\n    constructor(r, s, recovery) {\n      this.r = validateRS('r', r); // r in [1..N-1];\n      this.s = validateRS('s', s); // s in [1..N-1];\n      if (recovery != null) this.recovery = recovery;\n      Object.freeze(this);\n    }\n    static fromBytes(bytes, format = defaultSigOpts_format) {\n      validateSigLength(bytes, format);\n      let recid;\n      if (format === 'der') {\n        const {\n          r,\n          s\n        } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));\n        return new Signature(r, s);\n      }\n      if (format === 'recovered') {\n        recid = bytes[0];\n        format = 'compact';\n        bytes = bytes.subarray(1);\n      }\n      const L = Fn.BYTES;\n      const r = bytes.subarray(0, L);\n      const s = bytes.subarray(L, L * 2);\n      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n    }\n    static fromHex(hex, format) {\n      return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);\n    }\n    addRecoveryBit(recovery) {\n      return new Signature(this.r, this.s, recovery);\n    }\n    recoverPublicKey(messageHash) {\n      const FIELD_ORDER = Fp.ORDER;\n      const {\n        r,\n        s,\n        recovery: rec\n      } = this;\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      // ECDSA recovery is hard for cofactor > 1 curves.\n      // In sign, `r = q.x mod n`, and here we recover q.x from r.\n      // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n      // However, for cofactor>1, r+n may not get q.x:\n      // r+n*i would need to be done instead where i is unknown.\n      // To easily get i, we either need to:\n      // a. increase amount of valid recid values (4, 5...); OR\n      // b. prohibit non-prime-order signatures (recid > 1).\n      const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n      if (hasCofactor && rec > 1) throw new Error('recovery id is ambiguous for h>1 curve');\n      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n      if (!Fp.isValid(radj)) throw new Error('recovery id 2 or 3 invalid');\n      const x = Fp.toBytes(radj);\n      const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));\n      const ir = Fn.inv(radj); // r^-1\n      const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', messageHash)); // Truncate hash\n      const u1 = Fn.create(-h * ir); // -hr^-1\n      const u2 = Fn.create(s * ir); // sr^-1\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n      if (Q.is0()) throw new Error('point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS() {\n      return isBiggerThanHalfOrder(this.s);\n    }\n    toBytes(format = defaultSigOpts_format) {\n      validateSigFormat(format);\n      if (format === 'der') return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));\n      const r = Fn.toBytes(this.r);\n      const s = Fn.toBytes(this.s);\n      if (format === 'recovered') {\n        if (this.recovery == null) throw new Error('recovery bit must be present');\n        return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);\n      }\n      return (0, utils_ts_1.concatBytes)(r, s);\n    }\n    toHex(format) {\n      return (0, utils_ts_1.bytesToHex)(this.toBytes(format));\n    }\n    // TODO: remove\n    assertValidity() {}\n    static fromCompact(hex) {\n      return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'compact');\n    }\n    static fromDER(hex) {\n      return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'der');\n    }\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return this.toBytes('der');\n    }\n    toDERHex() {\n      return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));\n    }\n    toCompactRawBytes() {\n      return this.toBytes('compact');\n    }\n    toCompactHex() {\n      return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));\n    }\n  }\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {\n    // Our custom check \"just in case\", for protection against DoS\n    if (bytes.length > 8192) throw new Error('input is too large');\n    // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n    // for some cases, since bytes.length * 8 is not actual bitLength.\n    const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here\n    const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n    return delta > 0 ? num >> BigInt(delta) : num;\n  };\n  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {\n    return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n  };\n  // Pads output with zero as per spec\n  const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);\n  /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n  function int2octets(num) {\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n    (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n    return Fn.toBytes(num);\n  }\n  function validateMsgAndHash(message, prehash) {\n    (0, utils_ts_1._abytes2)(message, undefined, 'message');\n    return prehash ? (0, utils_ts_1._abytes2)(hash(message), undefined, 'prehashed message') : message;\n  }\n  /**\n   * Steps A, D of RFC6979 3.2.\n   * Creates RFC6979 seed; converts msg/privKey to numbers.\n   * Used only in sign, not in verify.\n   *\n   * Warning: we cannot assume here that message has same amount of bytes as curve order,\n   * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n   */\n  function prepSig(message, privateKey, opts) {\n    if (['recovered', 'canonical'].some(k => k in opts)) throw new Error('sign() legacy options not supported');\n    const {\n      lowS,\n      prehash,\n      extraEntropy\n    } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(message);\n    const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (extraEntropy != null && extraEntropy !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      // gen random bytes OR pass as-is\n      const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n      seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n    }\n    const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    // To transform k => Signature:\n    // q = k⋅G\n    // r = q.x mod n\n    // s = k^-1(m + rd) mod n\n    // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    function k2sig(kBytes) {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      // Important: all mod() calls here must be done over N\n      const k = bits2int(kBytes); // mod n, not mod p\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n      const ik = Fn.inv(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = k⋅G\n      const r = Fn.create(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = Fn.neg(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery); // use normS, not s\n    }\n    return {\n      seed,\n      k2sig\n    };\n  }\n  /**\n   * Signs message hash with a secret key.\n   *\n   * ```\n   * sign(m, d) where\n   *   k = rfc6979_hmac_drbg(m, d)\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr) / k mod n\n   * ```\n   */\n  function sign(message, secretKey, opts = {}) {\n    message = (0, utils_ts_1.ensureBytes)('message', message);\n    const {\n      seed,\n      k2sig\n    } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);\n    const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    return sig;\n  }\n  function tryParsingSig(sg) {\n    // Try to deduce format\n    let sig = undefined;\n    const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);\n    const isObj = !isHex && sg !== null && typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint';\n    if (!isHex && !isObj) throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n    if (isObj) {\n      sig = new Signature(sg.r, sg.s);\n    } else if (isHex) {\n      try {\n        sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'der');\n      } catch (derError) {\n        if (!(derError instanceof exports.DER.Err)) throw derError;\n      }\n      if (!sig) {\n        try {\n          sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'compact');\n        } catch (error) {\n          return false;\n        }\n      }\n    }\n    if (!sig) return false;\n    return sig;\n  }\n  /**\n   * Verifies a signature against message and public key.\n   * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n   * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   u1 = hs^-1 mod n\n   *   u2 = rs^-1 mod n\n   *   R = u1⋅G + u2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(signature, message, publicKey, opts = {}) {\n    const {\n      lowS,\n      prehash,\n      format\n    } = validateSigOpts(opts, defaultSigOpts);\n    publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);\n    message = validateMsgAndHash((0, utils_ts_1.ensureBytes)('message', message), prehash);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const sig = format === undefined ? tryParsingSig(signature) : Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', signature), format);\n    if (sig === false) return false;\n    try {\n      const P = Point.fromBytes(publicKey);\n      if (lowS && sig.hasHighS()) return false;\n      const {\n        r,\n        s\n      } = sig;\n      const h = bits2int_modN(message); // mod n, not mod p\n      const is = Fn.inv(s); // s^-1 mod n\n      const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n      const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1⋅G + u2⋅P\n      if (R.is0()) return false;\n      const v = Fn.create(R.x); // v = r.x mod n\n      return v === r;\n    } catch (e) {\n      return false;\n    }\n  }\n  function recoverPublicKey(signature, message, opts = {}) {\n    const {\n      prehash\n    } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash);\n    return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n  }\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    getSharedSecret,\n    utils,\n    lengths,\n    Point,\n    sign,\n    verify,\n    recoverPublicKey,\n    Signature,\n    hash\n  });\n}\n/** @deprecated use `weierstrass` in newer releases */\nfunction weierstrassPoints(c) {\n  const {\n    CURVE,\n    curveOpts\n  } = _weierstrass_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  return _weierstrass_new_output_to_legacy(c, Point);\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n  const CURVE = {\n    a: c.a,\n    b: c.b,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy\n  };\n  const Fp = c.Fp;\n  let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map(l => Math.ceil(l / 2)))) : undefined;\n  const Fn = (0, modular_ts_1.Field)(CURVE.n, {\n    BITS: c.nBitLength,\n    allowedLengths: allowedLengths,\n    modFromBytes: c.wrapPrivateKey\n  });\n  const curveOpts = {\n    Fp,\n    Fn,\n    allowInfinityPoint: c.allowInfinityPoint,\n    endo: c.endo,\n    isTorsionFree: c.isTorsionFree,\n    clearCofactor: c.clearCofactor,\n    fromBytes: c.fromBytes,\n    toBytes: c.toBytes\n  };\n  return {\n    CURVE,\n    curveOpts\n  };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n  const {\n    CURVE,\n    curveOpts\n  } = _weierstrass_legacy_opts_to_new(c);\n  const ecdsaOpts = {\n    hmac: c.hmac,\n    randomBytes: c.randomBytes,\n    lowS: c.lowS,\n    bits2int: c.bits2int,\n    bits2int_modN: c.bits2int_modN\n  };\n  return {\n    CURVE,\n    curveOpts,\n    hash: c.hash,\n    ecdsaOpts\n  };\n}\nfunction _legacyHelperEquat(Fp, a, b) {\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n   * @returns y²\n   */\n  function weierstrassEquation(x) {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x² * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b\n  }\n  return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n  const {\n    Fp,\n    Fn\n  } = Point;\n  function isWithinCurveOrder(num) {\n    return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);\n  }\n  const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n  return Object.assign({}, {\n    CURVE: c,\n    Point: Point,\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar: key => _normFnElement(Fn, key),\n    weierstrassEquation,\n    isWithinCurveOrder\n  });\n}\nfunction _ecdsa_new_output_to_legacy(c, _ecdsa) {\n  const Point = _ecdsa.Point;\n  return Object.assign({}, _ecdsa, {\n    ProjectivePoint: Point,\n    CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS))\n  });\n}\n// _ecdsa_legacy\nfunction weierstrass(c) {\n  const {\n    CURVE,\n    curveOpts,\n    hash,\n    ecdsaOpts\n  } = _ecdsa_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  const signs = ecdsa(Point, hash, ecdsaOpts);\n  return _ecdsa_new_output_to_legacy(c, signs);\n}","map":{"version":3,"names":["exports","_splitEndoScalar","_normFnElement","weierstrassN","SWUFpSqrtRatio","mapToCurveSimpleSWU","ecdh","ecdsa","weierstrassPoints","_legacyHelperEquat","weierstrass","hmac_js_1","require","utils_1","utils_ts_1","curve_ts_1","modular_ts_1","divNearest","num","den","_2n","k","basis","n","a1","b1","a2","b2","c1","c2","k1","k2","k1neg","_0n","k2neg","MAX_NUM","bitMask","Math","ceil","bitLen","_1n","Error","validateSigFormat","format","includes","validateSigOpts","opts","def","optsn","optName","Object","keys","undefined","_abool2","lowS","prehash","DERErr","constructor","m","DER","Err","_tlv","encode","tag","data","E","length","dataLen","len","numberToHexUnpadded","lenLen","t","decode","pos","first","isLong","lengthBytes","subarray","b","v","l","_int","hex","Number","parseInt","bytesToNumberBE","toSig","int","tlv","ensureBytes","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","r","s","hexFromSig","sig","rs","ss","seq","BigInt","_3n","_4n","Fn","key","BYTES","expected","bytes","fromBytes","error","isValidNot0","params","extraOpts","validated","_createCurveFields","Fp","CURVE","h","cofactor","CURVE_ORDER","_validateObject","allowInfinityPoint","clearCofactor","isTorsionFree","toBytes","endo","wrapPrivateKey","is0","a","beta","Array","isArray","basises","lengths","getWLengths","assertCompressionIsSupported","isOdd","pointToBytes","_c","point","isCompressed","x","y","toAffine","bx","hasEvenY","concatBytes","pprefix","Uint8Array","of","pointFromBytes","_abytes2","publicKey","comp","publicKeyUncompressed","uncomp","head","tail","isValid","y2","weierstrassEquation","sqrt","sqrtError","err","message","isYOdd","isHeadOdd","neg","L","isValidXY","encodePoint","decodePoint","x2","sqr","x3","mul","add","left","right","eql","Gx","Gy","_4a3","pow","_27b2","acoord","title","banZero","aprjpoint","other","Point","splitEndoScalarN","ORDER","toAffineMemo","memoized","p","iz","X","Y","Z","ONE","inv","zz","ZERO","assertValidMemo","finishEndo","endoBeta","k1p","k2p","negateCt","freeze","fromAffine","P","assertValidity","fromHex","precompute","windowSize","isLazy","wnaf","createCache","multiply","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","double","b3","X3","Y3","Z3","t0","t1","t2","t3","sub","t4","t5","subtract","scalar","fake","cached","normalizeZ","f","k1f","k2f","multiplyUnsafe","sc","hasCache","p1","p2","mulEndoUnsafe","unsafe","multiplyAndAddUnsafe","Q","sum","invertedZ","isSmallOrder","toHex","bytesToHex","toString","px","py","pz","toRawBytes","_setWindowSize","points","msm","scalars","pippenger","fromPrivateKey","privateKey","BASE","bits","BITS","wNAF","q","o","_2n_pow_c1_1","_2n_pow_c1","c3","c4","c5","c6","c7","sqrtRatio","u","tv1","tv2","tv3","tv5","tv4","isQR","cmov","i","tvv5","e1","value","y1","validateField","A","B","tv6","tv4_inv","FpInvertBatch","secretKey","publicKeyHasPrefix","signature","ecdhOpts","randomBytes_","randomBytes","assign","seed","getMinHashLength","isValidSecretKey","isValidPublicKey","randomSecretKey","mapHashToField","getPublicKey","keygen","isProbPub","item","allowedLengths","getSharedSecret","secretKeyA","publicKeyB","utils","isValidPrivateKey","randomPrivateKey","normPrivateKeyToScalar","hash","ecdsaOpts","ahash","hmac","bits2int","bits2int_modN","msgs","fnBits","defaultSigOpts","extraEntropy","defaultSigOpts_format","isBiggerThanHalfOrder","number","HALF","validateRS","validateSigLength","size","sizer","Signature","recovery","recid","hexToBytes","addRecoveryBit","recoverPublicKey","messageHash","FIELD_ORDER","rec","hasCofactor","radj","R","ir","u1","create","u2","hasHighS","fromCompact","fromDER","normalizeS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","bits2int_def","delta","bits2int_modN_def","ORDER_MASK","int2octets","aInRange","validateMsgAndHash","prepSig","some","h1int","d","seedArgs","e","push","k2sig","kBytes","ik","normS","sign","drbg","createHmacDrbg","outputLen","tryParsingSig","sg","isHex","isBytes","isObj","derError","verify","is","c","curveOpts","_weierstrass_legacy_opts_to_new","_weierstrass_new_output_to_legacy","allowedPrivateKeyLengths","from","Set","map","Field","nBitLength","modFromBytes","_ecdsa_legacy_opts_to_new","isWithinCurveOrder","inRange","ProjectivePoint","_ecdsa_new_output_to_legacy","_ecdsa","nLength","signs"],"sources":["/Users/caiyongsheng/Developer/nus_fintech_project/nus_fintech_gang_plus_side_characters/frontend/node_modules/@noble/curves/src/abstract/weierstrass.ts"],"sourcesContent":["/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils';\nimport {\n  _validateObject,\n  _abool2 as abool,\n  _abytes2 as abytes,\n  aInRange,\n  bitLen,\n  bitMask,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  createHmacDrbg,\n  ensureBytes,\n  hexToBytes,\n  inRange,\n  isBytes,\n  memoized,\n  numberToHexUnpadded,\n  randomBytes as randomBytesWeb,\n  type CHash,\n  type Hex,\n  type PrivKey,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  mulEndoUnsafe,\n  negateCt,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport {\n  Field,\n  FpInvertBatch,\n  getMinHashLength,\n  mapHashToField,\n  nLength,\n  validateField,\n  type IField,\n  type NLength,\n} from './modular.ts';\n\nexport type { AffinePoint };\nexport type HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\n\ntype EndoBasis = [[bigint, bigint], [bigint, bigint]];\n/**\n * When Weierstrass curve has `a=0`, it becomes Koblitz curve.\n * Koblitz curves allow using **efficiently-computable GLV endomorphism ψ**.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n *\n * Endomorphism consists of beta, lambda and splitScalar:\n *\n * 1. GLV endomorphism ψ transforms a point: `P = (x, y) ↦ ψ(P) = (β·x mod p, y)`\n * 2. GLV scalar decomposition transforms a scalar: `k ≡ k₁ + k₂·λ (mod n)`\n * 3. Then these are combined: `k·P = k₁·P + k₂·ψ(P)`\n * 4. Two 128-bit point-by-scalar multiplications + one point addition is faster than\n *    one 256-bit multiplication.\n *\n * where\n * * beta: β ∈ Fₚ with β³ = 1, β ≠ 1\n * * lambda: λ ∈ Fₙ with λ³ = 1, λ ≠ 1\n * * splitScalar decomposes k ↦ k₁, k₂, by using reduced basis vectors.\n *   Gauss lattice reduction calculates them from initial basis vectors `(n, 0), (-λ, 0)`\n *\n * Check out `test/misc/endomorphism.js` and\n * [gist](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n */\nexport type EndomorphismOpts = {\n  beta: bigint;\n  basises?: EndoBasis;\n  splitScalar?: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\n\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num: bigint, den: bigint) => (num + (num >= 0 ? den : -den) / _2n) / den;\n\nexport type ScalarEndoParts = { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k: bigint, basis: EndoBasis, n: bigint): ScalarEndoParts {\n  // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n  // Since part can be negative, we need to do this on point.\n  // TODO: verifyScalar function which consumes lambda\n  const [[a1, b1], [a2, b2]] = basis;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  // |k1|/|k2| is < sqrt(N), but can be negative.\n  // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n  let k1 = k - c1 * a1 - c2 * a2;\n  let k2 = -c1 * b1 - c2 * b2;\n  const k1neg = k1 < _0n;\n  const k2neg = k2 < _0n;\n  if (k1neg) k1 = -k1;\n  if (k2neg) k2 = -k2;\n  // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n  // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n  if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n    throw new Error('splitScalar (endomorphism): failed, k=' + k);\n  }\n  return { k1neg, k1, k2neg, k2 };\n}\n\nexport type ECDSASigFormat = 'compact' | 'recovered' | 'der';\nexport type ECDSARecoverOpts = {\n  prehash?: boolean;\n};\nexport type ECDSAVerifyOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASigFormat;\n};\nexport type ECDSASignOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASigFormat;\n  extraEntropy?: Uint8Array | boolean;\n};\n\nfunction validateSigFormat(format: string): ECDSASigFormat {\n  if (!['compact', 'recovered', 'der'].includes(format))\n    throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n  return format as ECDSASigFormat;\n}\n\nfunction validateSigOpts<T extends ECDSASignOpts, D extends Required<ECDSASignOpts>>(\n  opts: T,\n  def: D\n): Required<ECDSASignOpts> {\n  const optsn: ECDSASignOpts = {};\n  for (let optName of Object.keys(def)) {\n    // @ts-ignore\n    optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n  }\n  abool(optsn.lowS!, 'lowS');\n  abool(optsn.prehash!, 'prehash');\n  if (optsn.format !== undefined) validateSigFormat(optsn.format);\n  return optsn as Required<ECDSASignOpts>;\n}\n\n/** Instance methods for 3D XYZ projective points. */\nexport interface WeierstrassPoint<T> extends CurvePoint<T, WeierstrassPoint<T>> {\n  /** projective X coordinate. Different from affine x. */\n  readonly X: T;\n  /** projective Y coordinate. Different from affine y. */\n  readonly Y: T;\n  /** projective z coordinate */\n  readonly Z: T;\n  /** affine x coordinate. Different from projective X. */\n  get x(): T;\n  /** affine y coordinate. Different from projective Y. */\n  get y(): T;\n  /** Encodes point using IEEE P1363 (DER) encoding. First byte is 2/3/4. Default = isCompressed. */\n  toBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  /** @deprecated use `.X` */\n  readonly px: T;\n  /** @deprecated use `.Y` */\n  readonly py: T;\n  /** @deprecated use `.Z` */\n  readonly pz: T;\n  /** @deprecated use `toBytes` */\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  /** @deprecated use `multiplyUnsafe` */\n  multiplyAndAddUnsafe(\n    Q: WeierstrassPoint<T>,\n    a: bigint,\n    b: bigint\n  ): WeierstrassPoint<T> | undefined;\n  /** @deprecated use `p.y % 2n === 0n` */\n  hasEvenY(): boolean;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n}\n\n/** Static methods for 3D XYZ projective points. */\nexport interface WeierstrassPointCons<T> extends CurvePointCons<WeierstrassPoint<T>> {\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  new (X: T, Y: T, Z: T): WeierstrassPoint<T>;\n  CURVE(): WeierstrassOpts<T>;\n  /** @deprecated use `Point.BASE.multiply(Point.Fn.fromBytes(privateKey))` */\n  fromPrivateKey(privateKey: PrivKey): WeierstrassPoint<T>;\n  /** @deprecated use `import { normalizeZ } from '@noble/curves/abstract/curve.js';` */\n  normalizeZ(points: WeierstrassPoint<T>[]): WeierstrassPoint<T>[];\n  /** @deprecated use `import { pippenger } from '@noble/curves/abstract/curve.js';` */\n  msm(points: WeierstrassPoint<T>[], scalars: bigint[]): WeierstrassPoint<T>;\n}\n\n/**\n * Weierstrass curve options.\n *\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor, usually 1. h*n is group order; n is subgroup order\n * * a: formula param, must be in field of p\n * * b: formula param, must be in field of p\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type WeierstrassOpts<T> = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b: T;\n  Gx: T;\n  Gy: T;\n}>;\n\n// When a cofactor != 1, there can be an effective methods to:\n// 1. Determine whether a point is torsion-free\n// 2. Clear torsion component\n// wrapPrivateKey: bls12-381 requires mod(n) instead of rejecting keys >= n\nexport type WeierstrassExtraOpts<T> = Partial<{\n  Fp: IField<T>;\n  Fn: IField<bigint>;\n  allowInfinityPoint: boolean;\n  endo: EndomorphismOpts;\n  isTorsionFree: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => boolean;\n  clearCofactor: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => WeierstrassPoint<T>;\n  fromBytes: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes: (\n    c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ) => Uint8Array;\n}>;\n\n/**\n * Options for ECDSA signatures over a Weierstrass curve.\n *\n * * lowS: (default: true) whether produced / verified signatures occupy low half of ecdsaOpts.p. Prevents malleability.\n * * hmac: (default: noble-hashes hmac) function, would be used to init hmac-drbg for k generation.\n * * randomBytes: (default: webcrypto os-level CSPRNG) custom method for fetching secure randomness.\n * * bits2int, bits2int_modN: used in sigs, sometimes overridden by curves\n */\nexport type ECDSAOpts = Partial<{\n  lowS: boolean;\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  bits2int: (bytes: Uint8Array) => bigint;\n  bits2int_modN: (bytes: Uint8Array) => bigint;\n}>;\n\n/**\n * Elliptic Curve Diffie-Hellman interface.\n * Provides keygen, secret-to-public conversion, calculating shared secrets.\n */\nexport interface ECDH {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (secretKeyA: PrivKey, publicKeyB: Hex, isCompressed?: boolean) => Uint8Array;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    isValidSecretKey: (secretKey: PrivKey) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, isCompressed?: boolean) => boolean;\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `isValidSecretKey` */\n    isValidPrivateKey: (secretKey: PrivKey) => boolean;\n    /** @deprecated use `Point.Fn.fromBytes()` */\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    /** @deprecated use `point.precompute()` */\n    precompute: (windowSize?: number, point?: WeierstrassPoint<bigint>) => WeierstrassPoint<bigint>;\n  };\n  lengths: CurveLengths;\n}\n\n/**\n * ECDSA interface.\n * Only supported for prime fields, not Fp2 (extension fields).\n */\nexport interface ECDSA extends ECDH {\n  sign: (message: Hex, secretKey: PrivKey, opts?: ECDSASignOpts) => ECDSASigRecovered;\n  verify: (\n    signature: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    opts?: ECDSAVerifyOpts\n  ) => boolean;\n  recoverPublicKey(signature: Uint8Array, message: Uint8Array, opts?: ECDSARecoverOpts): Uint8Array;\n  Signature: ECDSASignatureCons;\n}\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexport type IDER = {\n  // asn.1 DER encoding utils\n  Err: typeof DERErr;\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => string;\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\n  };\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string;\n    decode(data: Uint8Array): bigint;\n  };\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\n};\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER: IDER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string): string => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    },\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = ensureBytes('signature', hex);\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function _normFnElement(Fn: IField<bigint>, key: PrivKey): bigint {\n  const { BYTES: expected } = Fn;\n  let num: bigint;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else {\n    let bytes = ensureBytes('private key', key);\n    try {\n      num = Fn.fromBytes(bytes);\n    } catch (error) {\n      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n    }\n  }\n  if (!Fn.isValidNot0(num)) throw new Error('invalid private key: out of range [1..N-1]');\n  return num;\n}\n\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nexport function weierstrassN<T>(\n  params: WeierstrassOpts<T>,\n  extraOpts: WeierstrassExtraOpts<T> = {}\n): WeierstrassPointCons<T> {\n  const validated = _createCurveFields('weierstrass', params, extraOpts);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as WeierstrassOpts<T>;\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  _validateObject(\n    extraOpts,\n    {},\n    {\n      allowInfinityPoint: 'boolean',\n      clearCofactor: 'function',\n      isTorsionFree: 'function',\n      fromBytes: 'function',\n      toBytes: 'function',\n      endo: 'object',\n      wrapPrivateKey: 'boolean',\n    }\n  );\n\n  const { endo } = extraOpts;\n  if (endo) {\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n    if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n    }\n  }\n\n  const lengths = getWLengths(Fp, Fn);\n\n  function assertCompressionIsSupported() {\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\n  }\n\n  // Implements IEEE P1363 point encoding\n  function pointToBytes(\n    _c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ): Uint8Array {\n    const { x, y } = point.toAffine();\n    const bx = Fp.toBytes(x);\n    abool(isCompressed, 'isCompressed');\n    if (isCompressed) {\n      assertCompressionIsSupported();\n      const hasEvenY = !Fp.isOdd!(y);\n      return concatBytes(pprefix(hasEvenY), bx);\n    } else {\n      return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n    }\n  }\n  function pointFromBytes(bytes: Uint8Array) {\n    abytes(bytes, undefined, 'Point');\n    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n    const length = bytes.length;\n    const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // No actual validation is done here: use .assertValidity()\n    if (length === comp && (head === 0x02 || head === 0x03)) {\n      const x = Fp.fromBytes(tail);\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\n      const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n      let y: T;\n      try {\n        y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n      } catch (sqrtError) {\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n        throw new Error('bad point: is not on curve, sqrt error' + err);\n      }\n      assertCompressionIsSupported();\n      const isYOdd = Fp.isOdd!(y); // (y & _1n) === _1n;\n      const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n      if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n      return { x, y };\n    } else if (length === uncomp && head === 0x04) {\n      // TODO: more checks\n      const L = Fp.BYTES;\n      const x = Fp.fromBytes(tail.subarray(0, L));\n      const y = Fp.fromBytes(tail.subarray(L, L * 2));\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\n      return { x, y };\n    } else {\n      throw new Error(\n        `bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`\n      );\n    }\n  }\n\n  const encodePoint = extraOpts.toBytes || pointToBytes;\n  const decodePoint = extraOpts.fromBytes || pointFromBytes;\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x² * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x³ + a * x + b\n  }\n\n  // TODO: move top-level\n  /** Checks whether equation holds for given x, y: y² == x³ + ax + b */\n  function isValidXY(x: T, y: T): boolean {\n    const left = Fp.sqr(y); // y²\n    const right = weierstrassEquation(x); // x³ + ax + b\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y² = x³ + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n  function acoord(title: string, n: T, banZero = false) {\n    if (!Fp.isValid(n) || (banZero && Fp.is0(n))) throw new Error(`bad point coordinate ${title}`);\n    return n;\n  }\n\n  function aprjpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n\n  function splitEndoScalarN(k: bigint) {\n    if (!endo || !endo.basises) throw new Error('no endo');\n    return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { X, Y, Z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(Z, Fp.ONE)) return { x: X, y: Y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n    const x = Fp.mul(X, iz);\n    const y = Fp.mul(Y, iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  function finishEndo(\n    endoBeta: EndomorphismOpts['beta'],\n    k1p: Point,\n    k2p: Point,\n    k1neg: boolean,\n    k2neg: boolean\n  ) {\n    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n    k1p = negateCt(k1neg, k1p);\n    k2p = negateCt(k2neg, k2p);\n    return k1p.add(k2p);\n  }\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).\n   * Default Point works in 2d / affine coordinates: (x, y).\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements WeierstrassPoint<T> {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: T;\n    readonly Y: T;\n    readonly Z: T;\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(X: T, Y: T, Z: T) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y, true);\n      this.Z = acoord('z', Z);\n      Object.freeze(this);\n    }\n\n    static CURVE(): WeierstrassOpts<T> {\n      return CURVE;\n    }\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    static fromBytes(bytes: Uint8Array): Point {\n      const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n      P.assertValidity();\n      return P;\n    }\n    static fromHex(hex: Hex): Point {\n      return Point.fromBytes(ensureBytes('pointHex', hex));\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(windowSize: number = 8, isLazy = true): Point {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_3n); // random number\n      return this;\n    }\n\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n      return !Fp.isOdd(y);\n    }\n\n    /** Compare one point to another. */\n    equals(other: Point): boolean {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate(): Point {\n      return new Point(this.X, Fp.neg(this.Y), this.Z);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo } = extraOpts;\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const mul = (n: bigint) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n        const { p: k1p, f: k1f } = mul(k1);\n        const { p: k2p, f: k2f } = mul(k2);\n        fake = k1f.add(k2f);\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n      } else {\n        const { p, f } = mul(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return normalizeZ(Point, [point, fake])[0];\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed secret key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo } = extraOpts;\n      const p = this as Point;\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\n      if (sc === _0n || p.is0()) return Point.ZERO;\n      if (sc === _1n) return p; // fast-path\n      if (wnaf.hasCache(this)) return this.multiply(sc);\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n      } else {\n        return wnaf.unsafe(p, sc);\n      }\n    }\n\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(invertedZ?: T): AffinePoint<T> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree(): boolean {\n      const { isTorsionFree } = extraOpts;\n      if (cofactor === _1n) return true;\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      return wnaf.unsafe(this, CURVE_ORDER).is0();\n    }\n\n    clearCofactor(): Point {\n      const { clearCofactor } = extraOpts;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    isSmallOrder(): boolean {\n      // can we use this.clearCofactor()?\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    toBytes(isCompressed = true): Uint8Array {\n      abool(isCompressed, 'isCompressed');\n      this.assertValidity();\n      return encodePoint(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return bytesToHex(this.toBytes(isCompressed));\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n\n    // TODO: remove\n    get px(): T {\n      return this.X;\n    }\n    get py(): T {\n      return this.X;\n    }\n    get pz(): T {\n      return this.Z;\n    }\n    toRawBytes(isCompressed = true): Uint8Array {\n      return this.toBytes(isCompressed);\n    }\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, points);\n    }\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n    }\n  }\n  const bits = Fn.BITS;\n  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/** Methods of ECDSA signature instance. */\nexport interface ECDSASignature {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  addRecoveryBit(recovery: number): ECDSASigRecovered;\n  hasHighS(): boolean;\n  toBytes(format?: string): Uint8Array;\n  toHex(format?: string): string;\n\n  /** @deprecated */\n  assertValidity(): void;\n  /** @deprecated */\n  normalizeS(): ECDSASignature;\n  /** @deprecated use standalone method `curve.recoverPublicKey(sig.toBytes('recovered'), msg)` */\n  recoverPublicKey(msgHash: Hex): WeierstrassPoint<bigint>;\n  /** @deprecated use `.toBytes('compact')` */\n  toCompactRawBytes(): Uint8Array;\n  /** @deprecated use `.toBytes('compact')` */\n  toCompactHex(): string;\n  /** @deprecated use `.toBytes('der')` */\n  toDERRawBytes(): Uint8Array;\n  /** @deprecated use `.toBytes('der')` */\n  toDERHex(): string;\n}\nexport type ECDSASigRecovered = ECDSASignature & {\n  readonly recovery: number;\n};\n/** Methods of ECDSA signature constructor. */\nexport type ECDSASignatureCons = {\n  new (r: bigint, s: bigint, recovery?: number): ECDSASignature;\n  fromBytes(bytes: Uint8Array, format?: ECDSASigFormat): ECDSASignature;\n  fromHex(hex: string, format?: ECDSASigFormat): ECDSASignature;\n\n  /** @deprecated use `.fromBytes(bytes, 'compact')` */\n  fromCompact(hex: Hex): ECDSASignature;\n  /** @deprecated use `.fromBytes(bytes, 'der')` */\n  fromDER(hex: Hex): ECDSASignature;\n};\n\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY: boolean): Uint8Array {\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(\n  Fp: IField<T>,\n  Z: T\n): (u: T, v: T) => { isValid: boolean; value: T } {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n): (u: T) => { x: T; y: T } {\n  validateField(Fp);\n  const { A, B, Z } = opts;\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n\nfunction getWLengths<T>(Fp: IField<T>, Fn: IField<bigint>) {\n  return {\n    secretKey: Fn.BYTES,\n    publicKey: 1 + Fp.BYTES,\n    publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n    publicKeyHasPrefix: true,\n    signature: 2 * Fn.BYTES,\n  };\n}\n\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(\n  Point: WeierstrassPointCons<bigint>,\n  ecdhOpts: { randomBytes?: (bytesLength?: number) => Uint8Array } = {}\n): ECDH {\n  const { Fn } = Point;\n  const randomBytes_ = ecdhOpts.randomBytes || randomBytesWeb;\n  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n\n  function isValidSecretKey(secretKey: PrivKey) {\n    try {\n      return !!_normFnElement(Fn, secretKey);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  function isValidPublicKey(publicKey: Uint8Array, isCompressed?: boolean): boolean {\n    const { publicKey: comp, publicKeyUncompressed } = lengths;\n    try {\n      const l = publicKey.length;\n      if (isCompressed === true && l !== comp) return false;\n      if (isCompressed === false && l !== publicKeyUncompressed) return false;\n      return !!Point.fromBytes(publicKey);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Produces cryptographically secure secret key from random of size\n   * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n   */\n  function randomSecretKey(seed = randomBytes_(lengths.seed)): Uint8Array {\n    return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n  }\n\n  /**\n   * Computes public key for a secret key. Checks for validity of the secret key.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(secretKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n  }\n\n  function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean | undefined {\n    if (typeof item === 'bigint') return false;\n    if (item instanceof Point) return true;\n    const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n    if (Fn.allowedLengths || secretKey === publicKey) return undefined;\n    const l = ensureBytes('key', item).length;\n    return l === publicKey || l === publicKeyUncompressed;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from secret key A and public key B.\n   * Checks: 1) secret key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(secretKeyA: PrivKey, publicKeyB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(secretKeyA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicKeyB) === false) throw new Error('second arg must be public key');\n    const s = _normFnElement(Fn, secretKeyA);\n    const b = Point.fromHex(publicKeyB); // checks for being on-curve\n    return b.multiply(s).toBytes(isCompressed);\n  }\n\n  const utils = {\n    isValidSecretKey,\n    isValidPublicKey,\n    randomSecretKey,\n\n    // TODO: remove\n    isValidPrivateKey: isValidSecretKey,\n    randomPrivateKey: randomSecretKey,\n    normPrivateKeyToScalar: (key: PrivKey) => _normFnElement(Fn, key),\n    precompute(windowSize = 8, point = Point.BASE): WeierstrassPoint<bigint> {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(\n  Point: WeierstrassPointCons<bigint>,\n  hash: CHash,\n  ecdsaOpts: ECDSAOpts = {}\n): ECDSA {\n  ahash(hash);\n  _validateObject(\n    ecdsaOpts,\n    {},\n    {\n      hmac: 'function',\n      lowS: 'boolean',\n      randomBytes: 'function',\n      bits2int: 'function',\n      bits2int_modN: 'function',\n    }\n  );\n\n  const randomBytes = ecdsaOpts.randomBytes || randomBytesWeb;\n  const hmac: HmacFnSync =\n    ecdsaOpts.hmac ||\n    (((key, ...msgs) => nobleHmac(hash, key, concatBytes(...msgs))) satisfies HmacFnSync);\n\n  const { Fp, Fn } = Point;\n  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n  const defaultSigOpts: Required<ECDSASignOpts> = {\n    prehash: false,\n    lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n    format: undefined as any, //'compact' as ECDSASigFormat,\n    extraEntropy: false,\n  };\n  const defaultSigOpts_format = 'compact';\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function validateRS(title: string, num: bigint): bigint {\n    if (!Fn.isValidNot0(num))\n      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n    return num;\n  }\n  function validateSigLength(bytes: Uint8Array, format: ECDSASigFormat) {\n    validateSigFormat(format);\n    const size = lengths.signature!;\n    const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n    return abytes(bytes, sizer, `${format} signature`);\n  }\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n   */\n  class Signature implements ECDSASignature {\n    readonly r: bigint;\n    readonly s: bigint;\n    readonly recovery?: number;\n    constructor(r: bigint, s: bigint, recovery?: number) {\n      this.r = validateRS('r', r); // r in [1..N-1];\n      this.s = validateRS('s', s); // s in [1..N-1];\n      if (recovery != null) this.recovery = recovery;\n      Object.freeze(this);\n    }\n\n    static fromBytes(bytes: Uint8Array, format: ECDSASigFormat = defaultSigOpts_format): Signature {\n      validateSigLength(bytes, format);\n      let recid: number | undefined;\n      if (format === 'der') {\n        const { r, s } = DER.toSig(abytes(bytes));\n        return new Signature(r, s);\n      }\n      if (format === 'recovered') {\n        recid = bytes[0];\n        format = 'compact';\n        bytes = bytes.subarray(1);\n      }\n      const L = Fn.BYTES;\n      const r = bytes.subarray(0, L);\n      const s = bytes.subarray(L, L * 2);\n      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n    }\n\n    static fromHex(hex: string, format?: ECDSASigFormat) {\n      return this.fromBytes(hexToBytes(hex), format);\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(messageHash: Hex): WeierstrassPoint<bigint> {\n      const FIELD_ORDER = Fp.ORDER;\n      const { r, s, recovery: rec } = this;\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n\n      // ECDSA recovery is hard for cofactor > 1 curves.\n      // In sign, `r = q.x mod n`, and here we recover q.x from r.\n      // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n      // However, for cofactor>1, r+n may not get q.x:\n      // r+n*i would need to be done instead where i is unknown.\n      // To easily get i, we either need to:\n      // a. increase amount of valid recid values (4, 5...); OR\n      // b. prohibit non-prime-order signatures (recid > 1).\n      const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n      if (hasCofactor && rec > 1) throw new Error('recovery id is ambiguous for h>1 curve');\n\n      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n      if (!Fp.isValid(radj)) throw new Error('recovery id 2 or 3 invalid');\n      const x = Fp.toBytes(radj);\n      const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));\n      const ir = Fn.inv(radj); // r^-1\n      const h = bits2int_modN(ensureBytes('msgHash', messageHash)); // Truncate hash\n      const u1 = Fn.create(-h * ir); // -hr^-1\n      const u2 = Fn.create(s * ir); // sr^-1\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n      if (Q.is0()) throw new Error('point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    toBytes(format: ECDSASigFormat = defaultSigOpts_format) {\n      validateSigFormat(format);\n      if (format === 'der') return hexToBytes(DER.hexFromSig(this));\n      const r = Fn.toBytes(this.r);\n      const s = Fn.toBytes(this.s);\n      if (format === 'recovered') {\n        if (this.recovery == null) throw new Error('recovery bit must be present');\n        return concatBytes(Uint8Array.of(this.recovery), r, s);\n      }\n      return concatBytes(r, s);\n    }\n\n    toHex(format?: ECDSASigFormat) {\n      return bytesToHex(this.toBytes(format));\n    }\n\n    // TODO: remove\n    assertValidity(): void {}\n    static fromCompact(hex: Hex) {\n      return Signature.fromBytes(ensureBytes('sig', hex), 'compact');\n    }\n    static fromDER(hex: Hex) {\n      return Signature.fromBytes(ensureBytes('sig', hex), 'der');\n    }\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return this.toBytes('der');\n    }\n    toDERHex() {\n      return bytesToHex(this.toBytes('der'));\n    }\n    toCompactRawBytes() {\n      return this.toBytes('compact');\n    }\n    toCompactHex() {\n      return bytesToHex(this.toBytes('compact'));\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    ecdsaOpts.bits2int ||\n    function bits2int_def(bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\", for protection against DoS\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    ecdsaOpts.bits2int_modN ||\n    function bits2int_modN_def(bytes: Uint8Array): bigint {\n      return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // Pads output with zero as per spec\n  const ORDER_MASK = bitMask(fnBits);\n  /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n  function int2octets(num: bigint): Uint8Array {\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n    aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n    return Fn.toBytes(num);\n  }\n\n  function validateMsgAndHash(message: Uint8Array, prehash: boolean) {\n    abytes(message, undefined, 'message');\n    return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n  }\n\n  /**\n   * Steps A, D of RFC6979 3.2.\n   * Creates RFC6979 seed; converts msg/privKey to numbers.\n   * Used only in sign, not in verify.\n   *\n   * Warning: we cannot assume here that message has same amount of bytes as curve order,\n   * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n   */\n  function prepSig(message: Uint8Array, privateKey: PrivKey, opts: ECDSASignOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(message);\n    const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (extraEntropy != null && extraEntropy !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      // gen random bytes OR pass as-is\n      const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    // To transform k => Signature:\n    // q = k⋅G\n    // r = q.x mod n\n    // s = k^-1(m + rd) mod n\n    // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      // Important: all mod() calls here must be done over N\n      const k = bits2int(kBytes); // mod n, not mod p\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n      const ik = Fn.inv(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = k⋅G\n      const r = Fn.create(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = Fn.neg(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n\n  /**\n   * Signs message hash with a secret key.\n   *\n   * ```\n   * sign(m, d) where\n   *   k = rfc6979_hmac_drbg(m, d)\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr) / k mod n\n   * ```\n   */\n  function sign(message: Hex, secretKey: PrivKey, opts: ECDSASignOpts = {}): RecoveredSignature {\n    message = ensureBytes('message', message);\n    const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = createHmacDrbg<RecoveredSignature>(hash.outputLen, Fn.BYTES, hmac);\n    const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    return sig;\n  }\n\n  function tryParsingSig(sg: Hex | SignatureLike) {\n    // Try to deduce format\n    let sig: Signature | undefined = undefined;\n    const isHex = typeof sg === 'string' || isBytes(sg);\n    const isObj =\n      !isHex &&\n      sg !== null &&\n      typeof sg === 'object' &&\n      typeof sg.r === 'bigint' &&\n      typeof sg.s === 'bigint';\n    if (!isHex && !isObj)\n      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n    if (isObj) {\n      sig = new Signature(sg.r, sg.s);\n    } else if (isHex) {\n      try {\n        sig = Signature.fromBytes(ensureBytes('sig', sg), 'der');\n      } catch (derError) {\n        if (!(derError instanceof DER.Err)) throw derError;\n      }\n      if (!sig) {\n        try {\n          sig = Signature.fromBytes(ensureBytes('sig', sg), 'compact');\n        } catch (error) {\n          return false;\n        }\n      }\n    }\n    if (!sig) return false;\n    return sig;\n  }\n\n  /**\n   * Verifies a signature against message and public key.\n   * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n   * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   u1 = hs^-1 mod n\n   *   u2 = rs^-1 mod n\n   *   R = u1⋅G + u2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    message: Hex,\n    publicKey: Hex,\n    opts: ECDSAVerifyOpts = {}\n  ): boolean {\n    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n    publicKey = ensureBytes('publicKey', publicKey);\n    message = validateMsgAndHash(ensureBytes('message', message), prehash);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const sig =\n      format === undefined\n        ? tryParsingSig(signature)\n        : Signature.fromBytes(ensureBytes('sig', signature as Hex), format);\n    if (sig === false) return false;\n    try {\n      const P = Point.fromBytes(publicKey);\n      if (lowS && sig.hasHighS()) return false;\n      const { r, s } = sig;\n      const h = bits2int_modN(message); // mod n, not mod p\n      const is = Fn.inv(s); // s^-1 mod n\n      const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n      const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1⋅G + u2⋅P\n      if (R.is0()) return false;\n      const v = Fn.create(R.x); // v = r.x mod n\n      return v === r;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function recoverPublicKey(\n    signature: Uint8Array,\n    message: Uint8Array,\n    opts: ECDSARecoverOpts = {}\n  ): Uint8Array {\n    const { prehash } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash);\n    return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n  }\n\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    getSharedSecret,\n    utils,\n    lengths,\n    Point,\n    sign,\n    verify,\n    recoverPublicKey,\n    Signature,\n    hash,\n  });\n}\n\n// TODO: remove everything below\n/** @deprecated use ECDSASignature */\nexport type SignatureType = ECDSASignature;\n/** @deprecated use ECDSASigRecovered */\nexport type RecoveredSignatureType = ECDSASigRecovered;\n/** @deprecated switch to Uint8Array signatures in format 'compact' */\nexport type SignatureLike = { r: bigint; s: bigint };\nexport type ECDSAExtraEntropy = Hex | boolean;\n/** @deprecated use `ECDSAExtraEntropy` */\nexport type Entropy = Hex | boolean;\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts;\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => WeierstrassPoint<T>;\n};\n/** @deprecated use ECDSASignOpts */\nexport type SignOpts = ECDSASignOpts;\n/** @deprecated use ECDSASignOpts */\nexport type VerOpts = ECDSAVerifyOpts;\n\n/** @deprecated use WeierstrassPoint */\nexport type ProjPointType<T> = WeierstrassPoint<T>;\n/** @deprecated use WeierstrassPointCons */\nexport type ProjConstructor<T> = WeierstrassPointCons<T>;\n/** @deprecated use ECDSASignatureCons */\nexport type SignatureConstructor = ECDSASignatureCons;\n\n// TODO: remove\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (\n    c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ) => Uint8Array;\n};\n\n// LegacyWeierstrassOpts\nexport type CurvePointsTypeWithLength<T> = Readonly<CurvePointsType<T> & Partial<NLength>>;\n\n// LegacyWeierstrass\nexport type CurvePointsRes<T> = {\n  Point: WeierstrassPointCons<T>;\n\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: CurvePointsType<T>;\n  /** @deprecated use `Point` */\n  ProjectivePoint: WeierstrassPointCons<T>;\n  /** @deprecated use `Point.Fn.fromBytes(privateKey)` */\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  /** @deprecated */\n  weierstrassEquation: (x: T) => T;\n  /** @deprecated use `Point.Fn.isValidNot0(num)` */\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// Aliases to legacy types\n// export type CurveType = LegacyECDSAOpts;\n// export type CurveFn = LegacyECDSA;\n// export type CurvePointsRes<T> = LegacyWeierstrass<T>;\n// export type CurvePointsType<T> = LegacyWeierstrassOpts<T>;\n// export type CurvePointsTypeWithLength<T> = LegacyWeierstrassOpts<T>;\n// export type BasicWCurve<T> = LegacyWeierstrassOpts<T>;\n\n/** @deprecated use `Uint8Array` */\nexport type PubKey = Hex | WeierstrassPoint<bigint>;\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac?: HmacFnSync;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\nexport type CurveFn = {\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: CurvePointsType<bigint>;\n  keygen: ECDSA['keygen'];\n  getPublicKey: ECDSA['getPublicKey'];\n  getSharedSecret: ECDSA['getSharedSecret'];\n  sign: ECDSA['sign'];\n  verify: ECDSA['verify'];\n  Point: WeierstrassPointCons<bigint>;\n  /** @deprecated use `Point` */\n  ProjectivePoint: WeierstrassPointCons<bigint>;\n  Signature: ECDSASignatureCons;\n  utils: ECDSA['utils'];\n  lengths: ECDSA['lengths'];\n};\n/** @deprecated use `weierstrass` in newer releases */\nexport function weierstrassPoints<T>(c: CurvePointsTypeWithLength<T>): CurvePointsRes<T> {\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  return _weierstrass_new_output_to_legacy(c, Point);\n}\nexport type WsPointComposed<T> = {\n  CURVE: WeierstrassOpts<T>;\n  curveOpts: WeierstrassExtraOpts<T>;\n};\nexport type WsComposed = {\n  /** @deprecated use `Point.CURVE()` */\n  CURVE: WeierstrassOpts<bigint>;\n  hash: CHash;\n  curveOpts: WeierstrassExtraOpts<bigint>;\n  ecdsaOpts: ECDSAOpts;\n};\nfunction _weierstrass_legacy_opts_to_new<T>(c: CurvePointsType<T>): WsPointComposed<T> {\n  const CURVE: WeierstrassOpts<T> = {\n    a: c.a,\n    b: c.b,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  let allowedLengths = c.allowedPrivateKeyLengths\n    ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))\n    : undefined;\n  const Fn = Field(CURVE.n, {\n    BITS: c.nBitLength,\n    allowedLengths: allowedLengths,\n    modFromBytes: c.wrapPrivateKey,\n  });\n  const curveOpts: WeierstrassExtraOpts<T> = {\n    Fp,\n    Fn,\n    allowInfinityPoint: c.allowInfinityPoint,\n    endo: c.endo,\n    isTorsionFree: c.isTorsionFree,\n    clearCofactor: c.clearCofactor,\n    fromBytes: c.fromBytes,\n    toBytes: c.toBytes,\n  };\n  return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c: CurveType): WsComposed {\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n  const ecdsaOpts: ECDSAOpts = {\n    hmac: c.hmac,\n    randomBytes: c.randomBytes,\n    lowS: c.lowS,\n    bits2int: c.bits2int,\n    bits2int_modN: c.bits2int_modN,\n  };\n  return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n}\nexport function _legacyHelperEquat<T>(Fp: IField<T>, a: T, b: T): (x: T) => T {\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n   * @returns y²\n   */\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x² * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b\n  }\n  return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy<T>(\n  c: CurvePointsType<T>,\n  Point: WeierstrassPointCons<T>\n): CurvePointsRes<T> {\n  const { Fp, Fn } = Point;\n  function isWithinCurveOrder(num: bigint): boolean {\n    return inRange(num, _1n, Fn.ORDER);\n  }\n  const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n  return Object.assign(\n    {},\n    {\n      CURVE: c,\n      Point: Point,\n      ProjectivePoint: Point,\n      normPrivateKeyToScalar: (key: PrivKey) => _normFnElement(Fn, key),\n      weierstrassEquation,\n      isWithinCurveOrder,\n    }\n  );\n}\nfunction _ecdsa_new_output_to_legacy(c: CurveType, _ecdsa: ECDSA): CurveFn {\n  const Point = _ecdsa.Point;\n  return Object.assign({}, _ecdsa, {\n    ProjectivePoint: Point,\n    CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS)),\n  });\n}\n\n// _ecdsa_legacy\nexport function weierstrass(c: CurveType): CurveFn {\n  const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n  const Point = weierstrassN(CURVE, curveOpts);\n  const signs = ecdsa(Point, hash, ecdsaOpts);\n  return _ecdsa_new_output_to_legacy(c, signs);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}